/*
 Navicat Premium Data Transfer

 Source Server         : local-mysql-docker
 Source Server Type    : MySQL
 Source Server Version : 80014
 Source Host           : 127.0.0.1:3306
 Source Schema         : db_puti

 Target Server Type    : MySQL
 Target Server Version : 80014
 File Encoding         : 65001

 Date: 27/01/2019 20:25:13
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for pt_comment
-- ----------------------------
DROP TABLE IF EXISTS `pt_comment`;
CREATE TABLE `pt_comment`  (
  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT '评论id',
  `parent_id` int(11) UNSIGNED NOT NULL DEFAULT 0 COMMENT '父评论id',
  `post_id` int(11) UNSIGNED NOT NULL DEFAULT 0 COMMENT '评论的文章或页面id',
  `content` text CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '评论内容',
  `if_visitor` tinyint(1) NOT NULL DEFAULT 1 COMMENT '是否游客;1是,0不是;默认游客',
  `commenter_user_id` int(11) UNSIGNED NOT NULL DEFAULT 0 COMMENT '评论者id;是游客时为0;默认为0',
  `commenter_name` tinytext CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '评论者名称',
  `commenter_email` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT '' COMMENT '评论者email',
  `commenter_url` varchar(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT '' COMMENT '评论者链接',
  `commenter_ip` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT '' COMMENT '评论者ip',
  `comment_date` datetime(0) NOT NULL ON UPDATE CURRENT_TIMESTAMP(0) COMMENT '评论时间',
  `comment_date_gmt` datetime(0) NOT NULL ON UPDATE CURRENT_TIMESTAMP(0) COMMENT '评论GMT标准时间',
  `approved` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT '1' COMMENT '是否通过(开启评论审核后，通过后显示)',
  `agent` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT '' COMMENT '评论来源agent',
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `comment_post_ID`(`post_id`) USING BTREE,
  INDEX `comment_date_gmt`(`comment_date_gmt`) USING BTREE,
  INDEX `comment_parent`(`parent_id`) USING BTREE,
  INDEX `comment_author_email`(`commenter_email`(10)) USING BTREE,
  INDEX `comment_approved_date_gmt`(`comment_date_gmt`, `approved`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Table structure for pt_comment_meta
-- ----------------------------
DROP TABLE IF EXISTS `pt_comment_meta`;
CREATE TABLE `pt_comment_meta`  (
  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT,
  `comment_id` int(11) UNSIGNED NOT NULL DEFAULT 0,
  `meta_key` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT '',
  `meta_value` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `comment_id`(`comment_id`) USING BTREE,
  INDEX `meta_key`(`meta_key`(191)) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Table structure for pt_link
-- ----------------------------
DROP TABLE IF EXISTS `pt_link`;
CREATE TABLE `pt_link`  (
  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT '链接id',
  `url` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT '' COMMENT '链接url',
  `name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT '' COMMENT '链接名称',
  `image` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT '' COMMENT '链接图像地址',
  `target` varchar(25) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT '' COMMENT '目标(如_blank)',
  `description` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT '' COMMENT '链接描述',
  `visible` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT 'Y' COMMENT '是否可见',
  `user_id` int(11) UNSIGNED NOT NULL DEFAULT 1 COMMENT '所属用户',
  `rating` int(11) NOT NULL DEFAULT 0 COMMENT '评分',
  `updated_time` datetime(0) NOT NULL COMMENT '更新时间',
  `notes` mediumtext CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL COMMENT '备注',
  `rss` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT '' COMMENT 'rss地址',
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `link_visible`(`visible`) USING BTREE,
  INDEX `link_owner_user`(`user_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Table structure for pt_option
-- ----------------------------
DROP TABLE IF EXISTS `pt_option`;
CREATE TABLE `pt_option`  (
  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT '配置id',
  `option_name` varchar(191) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT '' COMMENT '配置名称',
  `option_value` text CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '对应的值',
  `autoload` tinyint(1) NOT NULL DEFAULT 0 COMMENT '是否自动加载;默认0不自动加载',
  PRIMARY KEY (`id`) USING BTREE,
  UNIQUE INDEX `option_name`(`option_name`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 33 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of pt_option
-- ----------------------------
INSERT INTO `pt_option` VALUES (1, 'blog_name', '咖啡与代码', 1);
INSERT INTO `pt_option` VALUES (2, 'blog_description', '咖灰怪’s Blog', 1);
INSERT INTO `pt_option` VALUES (3, 'site_url', 'https://www.goozp.com', 1);
INSERT INTO `pt_option` VALUES (4, 'admin_email', 'gzp@goozp.com', 1);
INSERT INTO `pt_option` VALUES (5, 'users_can_register', 'off', 1);
INSERT INTO `pt_option` VALUES (6, 'timezone_string', 'Asia/Shanghai', 1);
INSERT INTO `pt_option` VALUES (7, 'default_category', '1', 0);
INSERT INTO `pt_option` VALUES (8, 'default_link_category', '0', 0);
INSERT INTO `pt_option` VALUES (9, 'show_on_front', 'posts', 1);
INSERT INTO `pt_option` VALUES (10, 'show_on_front_page', 'about', 1);
INSERT INTO `pt_option` VALUES (11, 'posts_per_page', '10', 1);
INSERT INTO `pt_option` VALUES (12, 'open_XML', 'on', 1);
INSERT INTO `pt_option` VALUES (13, 'article_comment_status', 'open', 1);
INSERT INTO `pt_option` VALUES (14, 'page_comment_status', 'open', 1);
INSERT INTO `pt_option` VALUES (15, 'comment_need_register', 'no', 1);
INSERT INTO `pt_option` VALUES (16, 'show_comment_page', 'on', 1);
INSERT INTO `pt_option` VALUES (17, 'comment_per_page', '15', 1);
INSERT INTO `pt_option` VALUES (18, 'comment_page_first', 'last', 1);
INSERT INTO `pt_option` VALUES (19, 'comment_page_top', 'new', 1);
INSERT INTO `pt_option` VALUES (20, 'comment_before_show', 'directly', 1);
INSERT INTO `pt_option` VALUES (21, 'show_avatar', 'on', 1);
INSERT INTO `pt_option` VALUES (22, 'image_thumbnail_width', '150', 0);
INSERT INTO `pt_option` VALUES (23, 'image_thumbnail_height', '150', 0);
INSERT INTO `pt_option` VALUES (24, 'image_medium_width', '300', 0);
INSERT INTO `pt_option` VALUES (25, 'image_medium_height', '300', 0);
INSERT INTO `pt_option` VALUES (26, 'image_large_width', '1024', 0);
INSERT INTO `pt_option` VALUES (27, 'image_large_height', '1024', 0);
INSERT INTO `pt_option` VALUES (28, 'site_description', '记录技术路上的点点滴滴；分享知识，分享快乐，分享生活。', 1);
INSERT INTO `pt_option` VALUES (29, 'site_keywords', '咖灰怪,咖啡与代码,独立博客,程序员,IT', 1);
INSERT INTO `pt_option` VALUES (30, 'footer_copyright', '<p> Copyright © 2017 <a id=\"\" href=\"http://www.goozp.com\" target=\"_blank\">goozp</a> All Rights Reserved. Powered by <a href=\"https://github.com/ZpGuo/zPhal\" target=\"_blank\" rel=\"nofollow\">zPhal</a></p>\r\n\r\n<p><a href=\"http://www.miitbeian.gov.cn/\" target=\"_blank\" rel=\"nofollow\">粤ICP备16013442号</a> | 本站运行于 阿里云</p>', 1);
INSERT INTO `pt_option` VALUES (31, 'show_project', '1', 1);
INSERT INTO `pt_option` VALUES (32, 'github_user', 'ZpGuo', 0);
INSERT INTO `pt_option` VALUES (33, 'github_show_repo', '[{\"id\":99091429,\"full_name\":\"ZpGuo\\/zPhal\",\"html_url\":\"https:\\/\\/github.com\\/ZpGuo\\/zPhal\",\"description\":\"\\u57fa\\u4e8ePhalcon\\u7684\\u5168\\u529f\\u80fd\\u5f00\\u6e90\\u535a\\u5ba2\\u7cfb\\u7edf\\u3002Open-sourced blog system for building high performance experience base on Phalcon framework.\",\"language\":\"PHP\",\"forks\":1,\"watchers\":6},{\"id\":100475173,\"full_name\":\"ZpGuo\\/zPhal-dockerfiles\",\"html_url\":\"https:\\/\\/github.com\\/ZpGuo\\/zPhal-dockerfiles\",\"description\":\"dockerfiles that support zPhal\'s working environment\",\"language\":\"Shell\",\"forks\":16,\"watchers\":26},{\"id\":81108781,\"full_name\":\"ZpGuo\\/Jumping\",\"html_url\":\"https:\\/\\/github.com\\/ZpGuo\\/Jumping\",\"description\":\"WordPress theme build using bootstrap.\",\"language\":\"PHP\",\"forks\":1,\"watchers\":2},{\"id\":85846583,\"full_name\":\"ZpGuo\\/SaltedFish\",\"html_url\":\"https:\\/\\/github.com\\/ZpGuo\\/SaltedFish\",\"description\":\"A wordpress Theme\",\"language\":\"PHP\",\"forks\":1,\"watchers\":1}]', 0);
INSERT INTO `pt_option` VALUES (34, 'site_language', '简体中文', 1);
INSERT INTO `pt_option` VALUES (35, 'current_theme', 'Emma', 1);

-- ----------------------------
-- Table structure for pt_post
-- ----------------------------
DROP TABLE IF EXISTS `pt_post`;
CREATE TABLE `pt_post`  (
  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT 'id',
  `user_id` int(11) UNSIGNED NOT NULL DEFAULT 0 COMMENT '发表人id',
  `post_type` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT 'article' COMMENT '类型：article，page',
  `title` text CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '标题',
  `content_markdown` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT 'markdown格式文章内容',
  `content_html` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT 'html格式文章内容',
  `slug` varchar(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT '' COMMENT '缩略名（用于url中展示）',
  `parent_id` int(11) UNSIGNED NOT NULL DEFAULT 0 COMMENT '父id（如果有）',
  `status` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT 'publish' COMMENT '状态:publish,draft,deleted',
  `comment_status` tinyint(1) NOT NULL DEFAULT 1 COMMENT '评论状态(是否开启);默认1开启；0关闭',
  `if_top` tinyint(1) NOT NULL DEFAULT 0 COMMENT '是否置顶；1置顶',
  `guid` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT '' COMMENT '唯一链接',
  `cover_picture` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT '' COMMENT '封面图片链接',
  `comment_count` int(11) NOT NULL DEFAULT 0 COMMENT '评论数目',
  `view_count` int(11) NOT NULL DEFAULT 0 COMMENT '浏览量',
  `posted_time` datetime(0) NULL DEFAULT NULL COMMENT '发表时间(UTC)',
  `created_time` datetime(0) NOT NULL COMMENT '创建时间(UTC)',
  `updated_time` datetime(0) NOT NULL COMMENT '更新时间(UTC)',
  `deleted_time` datetime(0) NULL DEFAULT NULL COMMENT '删除时间(UTC)',
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `post_parent`(`parent_id`) USING BTREE,
  INDEX `post_author`(`user_id`) USING BTREE,
  INDEX `type_status_date`(`id`, `post_type`, `status`) USING BTREE,
  INDEX `post_name`(`slug`(191)) USING BTREE,
  FULLTEXT INDEX `post_title`(`title`)
) ENGINE = InnoDB AUTO_INCREMENT = 86 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of pt_post
-- ----------------------------
INSERT INTO `pt_post` VALUES (3, 10, 'article', '走自己的路', '百度搜一下“成功的一百条秘诀”，唰唰唰好多条。再搜”成功的法则“，很好，唰唰唰又是好多条，什么成功的多少多少条法则啊，什么不成功的多少多少条原因啊，什么改变人生的多少多少条习惯啊，这种文章太多了。好吧，成功的一百条秘诀，第一条和第十条换一下，第多少多少条换一下，duang！又是一篇励志好文！\r\n\r\n说实在的，这种东西，太多了！从小到大，见到的太多了！即使你不喜欢看这些，在中国这种教育模式下，估计你也是“吸收”了很多这种类型的鼓励了，开学典礼校长发个话啊，班主任训话啊，多了多了。\r\n\r\n况且，父母的洗脑才是最主要的。都说中国的父母喜欢拿自家孩子和别人比，这倒是真的。我爸就是喜欢说别人的孩子多厉害，“那个谁谁谁的孩子啊，多厉害啊，去美国留学回来，开了多少家店了啊。”这个时候，我妈就会不开心了，“人家孩子考试不及格的时候你怎么不说？现在倒是来说。”当然，我妈也是这样的，而且最近经常会说这些，“那个那个叔叔，多厉害啊，你看他以前身无分文，现在风生水起啊！”是啊，是厉害啊，可是，我到了40岁，究竟是个什么样，还不知道呢啊，我不一定就差啊。\r\n\r\n“给我好好加油啊！你看人家马云，以前还是麦当劳收银员啊！你要向别人学习！你有什么课程啊能学到东西的你就去报！去听！”\r\n\r\n马云厉害啊，人家是传奇，但是，一直以来，我的理念是非常不喜欢向别人学习的。但是，可以参考。\r\n\r\n我们从小到大都是“向别人学习”，“向别人学习”，“向别人学习”。你究竟是谁啊，你还是你自己吗。成功人士的讲坛什么的，是挺多的，名人说过的话，也挺多的，可是，成功的永远就是那些给我们当楷模的。为什么？\r\n\r\n是的，假设马云开了个座谈会，分享自己成功的经验，100个人在场，听了。那么，为什么“马云”只有一个1个，而不是101个。“因为你们只听不做，没用！”好，100个人，听了之后付诸实践的，而不是听听就算了的，有10个。咦，那么为什么还是只有1个马云，而不是11个马云？好。10个人去做了，那么，做完了的，有几个？好吧，有2个。“那么，为什么没有3个马云！你告诉我！”因为，这两个人里，真的能力能达到马云那样吗？就像景德镇的陶瓷很出名，你去仿造，就能造出景德镇一样上好的陶瓷吗？不一定！\r\n\r\n不能否定将来一定没有第二个“马云”，但是，这个概率真的非常非常低！又说：“马云成功还没几年，并不能说明什么。”那好办，“马云”=？，再换个老点的名人呗，想换谁换谁，道理一样。\r\n\r\n马云是传奇，他走过的路他已经走过了，你再走一遍，他永远是在你前面，左手握“传”，右手握“奇”，笑着看你。\r\n\r\n两个人一起去割麦子，人家走在你前面，你在后面。人家走过的路，已经割完了，你跟着，你能割到啥！\r\n\r\n“不对啊，为什么马化腾跟在MSN后面，为毛QQ还是成功了啊！”“傻孩子，虽然目的一样，但是走的路不一样啊，美国人用QQ吗？并不。”\r\n\r\n“还是不对啊，为什么那啥啥啥走在前面，腾讯走在后面，还是被腾讯超过然后挤掉啊？”“傻孩子，人家来的晚，但是人家开法拉利啊，你开着拖拉机，也不换，这没办法咯。”这，就是是另一方面了。\r\n\r\n所以，我一直觉得，走自己的道路才是最主要的，要做自己，你可能不知道该怎么走接下来的路，但这正是你要做的事，去开辟你自己的道路，去成为下一个传奇。即使没成功，没事，真的没事，不是每个人都能达到所谓的“成功”，况且“成功”的定义对不同的人，都是不一样的。也许，你自己的目标，虽然很小，实现了，那就是成功了，你怕什么。\r\n\r\n我之前跟一位叔叔说过，“即使没成功，至少我努力过！”“一定能成功！不能这么说！”对，不能这么说。\r\n\r\n再多的励志道理，再多的优秀生活习惯，再多的经典案例，都不如自己脚踏实地去探索生活！未来是什么样，谁都不知道。\r\n\r\n真要说点励志故事的话吧，还是来点有用的，李开复的成功秘诀就是做最好的自己，只有突破自我才能到达成功的巅峰。\r\n\r\n所以，扯这么多，想说的就是，不要因为过于向往他人的成功而忘了你自己是个什么。当然，这只是我，一个只有22岁刚刚踏入社会的我的想法，未来我的看法会不会改变，我不知道。因为未来，谁都不知道。', '<p>百度搜一下“成功的一百条秘诀”，唰唰唰好多条。再搜”成功的法则“，很好，唰唰唰又是好多条，什么成功的多少多少条法则啊，什么不成功的多少多少条原因啊，什么改变人生的多少多少条习惯啊，这种文章太多了。好吧，成功的一百条秘诀，第一条和第十条换一下，第多少多少条换一下，duang！又是一篇励志好文！</p>\r\n<p>说实在的，这种东西，太多了！从小到大，见到的太多了！即使你不喜欢看这些，在中国这种教育模式下，估计你也是“吸收”了很多这种类型的鼓励了，开学典礼校长发个话啊，班主任训话啊，多了多了。</p>\r\n<p>况且，父母的洗脑才是最主要的。都说中国的父母喜欢拿自家孩子和别人比，这倒是真的。我爸就是喜欢说别人的孩子多厉害，“那个谁谁谁的孩子啊，多厉害啊，去美国留学回来，开了多少家店了啊。”这个时候，我妈就会不开心了，“人家孩子考试不及格的时候你怎么不说？现在倒是来说。”当然，我妈也是这样的，而且最近经常会说这些，“那个那个叔叔，多厉害啊，你看他以前身无分文，现在风生水起啊！”是啊，是厉害啊，可是，我到了40岁，究竟是个什么样，还不知道呢啊，我不一定就差啊。</p>\r\n<p>“给我好好加油啊！你看人家马云，以前还是麦当劳收银员啊！你要向别人学习！你有什么课程啊能学到东西的你就去报！去听！”</p>\r\n<p>马云厉害啊，人家是传奇，但是，一直以来，我的理念是非常不喜欢向别人学习的。但是，可以参考。</p>\r\n<p>我们从小到大都是“向别人学习”，“向别人学习”，“向别人学习”。你究竟是谁啊，你还是你自己吗。成功人士的讲坛什么的，是挺多的，名人说过的话，也挺多的，可是，成功的永远就是那些给我们当楷模的。为什么？</p>\r\n<p>是的，假设马云开了个座谈会，分享自己成功的经验，100个人在场，听了。那么，为什么“马云”只有一个1个，而不是101个。“因为你们只听不做，没用！”好，100个人，听了之后付诸实践的，而不是听听就算了的，有10个。咦，那么为什么还是只有1个马云，而不是11个马云？好。10个人去做了，那么，做完了的，有几个？好吧，有2个。“那么，为什么没有3个马云！你告诉我！”因为，这两个人里，真的能力能达到马云那样吗？就像景德镇的陶瓷很出名，你去仿造，就能造出景德镇一样上好的陶瓷吗？不一定！</p>\r\n<p>不能否定将来一定没有第二个“马云”，但是，这个概率真的非常非常低！又说：“马云成功还没几年，并不能说明什么。”那好办，“马云”=？，再换个老点的名人呗，想换谁换谁，道理一样。</p>\r\n<p>马云是传奇，他走过的路他已经走过了，你再走一遍，他永远是在你前面，左手握“传”，右手握“奇”，笑着看你。</p>\r\n<p>两个人一起去割麦子，人家走在你前面，你在后面。人家走过的路，已经割完了，你跟着，你能割到啥！</p>\r\n<p>“不对啊，为什么马化腾跟在MSN后面，为毛QQ还是成功了啊！”“傻孩子，虽然目的一样，但是走的路不一样啊，美国人用QQ吗？并不。”</p>\r\n<p>“还是不对啊，为什么那啥啥啥走在前面，腾讯走在后面，还是被腾讯超过然后挤掉啊？”“傻孩子，人家来的晚，但是人家开法拉利啊，你开着拖拉机，也不换，这没办法咯。”这，就是是另一方面了。</p>\r\n<p>所以，我一直觉得，走自己的道路才是最主要的，要做自己，你可能不知道该怎么走接下来的路，但这正是你要做的事，去开辟你自己的道路，去成为下一个传奇。即使没成功，没事，真的没事，不是每个人都能达到所谓的“成功”，况且“成功”的定义对不同的人，都是不一样的。也许，你自己的目标，虽然很小，实现了，那就是成功了，你怕什么。</p>\r\n<p>我之前跟一位叔叔说过，“即使没成功，至少我努力过！”“一定能成功！不能这么说！”对，不能这么说。</p>\r\n<p>再多的励志道理，再多的优秀生活习惯，再多的经典案例，都不如自己脚踏实地去探索生活！未来是什么样，谁都不知道。</p>\r\n<p>真要说点励志故事的话吧，还是来点有用的，李开复的成功秘诀就是做最好的自己，只有突破自我才能到达成功的巅峰。</p>\r\n<p>所以，扯这么多，想说的就是，不要因为过于向往他人的成功而忘了你自己是个什么。当然，这只是我，一个只有22岁刚刚踏入社会的我的想法，未来我的看法会不会改变，我不知道。因为未来，谁都不知道。</p>\r\n', '', 0, 'publish', 1, 0, '/article/3.html', '', 0, 101, '2016-03-03 13:59:01', '2016-03-03 13:59:01', '2018-01-04 17:50:13', NULL);
INSERT INTO `pt_post` VALUES (4, 10, 'article', '咸鱼要翻身——未来我的学习计划', '现在的一个状况是，PHP懂个基础，可以独立开发一个后台，APP接口，进行数据库操作，写点简单js。但是，都是最基础的操作，用最简单的方式实现功能，没有太多性能啊之类上的考虑，以目前的知识也无法考虑到，毕竟接触编程也不久，所以现在急于提升自己。\r\n\r\n虽然说，有些基础东西的东西也还没有彻底打扎实，但是总觉得这是一个过程，慢慢打就扎实了，所以还是觉得学点新技术比较好。但是问题来了，每当下班回到家坐在电脑前的时候，想学点东西，却不知道该从哪里开始。这时候发现了制定一个学习计划的重要性。所以列了一个清单，准备一条一条来，当然之后可能会调整，没关系，先照这个开始：\r\n\r\n**PHP相关：**\r\n\r\n1. 熟悉正则表达式，并能写正则。\r\n\r\n2. 如何使php代码更严谨。\r\n\r\n3. php实现冒泡排序，选择排序，插入排序和快速排序。\r\n\r\n4. 深入理解mysql数据库防sql注入。\r\n\r\n5. php开发之网站安全(SQL注入、验证码、刷新提交、漏洞扫描、DOS攻击、跨域攻击)\r\n\r\n6. 命名空间的探究，和高级功能。\r\n\r\n7. 魔术方法的应用；写实例。\r\n\r\n8. 序列化 (Serialize/Unserialize) 研究，与json的比较\r\n\r\n9. 自己封装一些常用的功能类：分页类；验证码类；图像处理类；文件上传类；数据验证类。\r\n\r\n10. php加密方法探究。\r\n\r\n11. api接口安全性问题(加密等)\r\n\r\n12. 影响mysql中innodb/myisam性能的配置选项。\r\n\r\n13. 索引探究：MyISAM与InnoDB的区别；MyISAM的主键索引和其它索引的区别；InnoDB的主键索引和其它索引的区别。\r\n\r\n14. php应用mysql事务；写实例。\r\n\r\n15. php文件“高级”操作。\r\n\r\n16. PHP“高级”图像操作。\r\n\r\n17. PHP设计模式。\r\n\r\n18. PHP SPL（标准库）使用。\r\n\r\n19. 深入了解HTTP协议。\r\n\r\n20. 了解浏览器的运行机制。\r\n\r\n21. AB并发测试与调优。\r\n\r\n22. 认识key-value存储系统（mencache，redis）\r\n\r\n23. 学习如何使用memcache\r\n\r\n24. 学习如何使用redis\r\n\r\n25. memcache与redis比较\r\n\r\n26. 了解Memcached的内存结构(slab机制)，redis了解常用数据类型底层实现存储结构(SDS/链表/SkipList/HashTable)等等。\r\n\r\n27. 了解一下Redis的事务、RDB、AO\r\n\r\n28. 什么是消息队列，如何实现消息队列。\r\n\r\n29. PHP+memcache实现消息队列\r\n\r\n30. 用php+redis实现消息队列\r\n\r\n31. php的缓存\r\n\r\n32. 用memcache和redis实现php缓存操作\r\n\r\n33. 什么是分布式架构，分布式与集群的区别，以及分布式如何实现。\r\n\r\n34. 了解mongodb，以及在php上的应用。\r\n\r\n35. 学习使用mongodb\r\n\r\n36. mongodb，redis，memcache比较。\r\n\r\n37. 什么是哈希算法？\r\n\r\n38. 一致性哈希的应用\r\n\r\n39. PHP hashTbale\r\n\r\n40. 什么是Socket编程，学习Socket编程。\r\n\r\n41. 编写php简单的Socket通信实例\r\n\r\n42. 学习Laravel框架\r\n\r\n43. 了解php-fpm的大部分配置选项和含义\r\n\r\n44. MySQL的核心关键技术，比如事务机制(隔离级别、锁等)、对触发器、 分区等技术。\r\n\r\n45. MySQL性能选项：innodb_log_buffer_size/back_log/table_open_cache/thread_cache_size/innodb_lock_wait_timeout等。\r\n\r\n46. MySQL性能：磁盘优化(SAS迁移到SSD)、服务器优化(内存、服务器本身配置)、连接池软件选择应用\r\n\r\n47. MySQL备份技术的深入熟悉，包括灾备 还原、对Binlog的深入理解，冷热备份，多IDC备份等\r\n\r\n48. Redis进阶：做一些复杂的数据结构的应用(zset做排行榜排序操作/事务处理用来保证原子性在秒杀类场景应用之类的使用操作)\r\n\r\n49. 一个高可用的Redis应用架构和集群\r\n\r\n50. php服务器压力测试和性能测试探究\r\n\r\n51. SQL优化总结\r\n\r\n52. 如何架构一个PHP高并发高负载系统\r\n\r\n53. 架构与部署(ECS、RDS、OCS、OSS、SLB)的研究\r\n\r\n**其它相关：**\r\n\r\n1. 学会搭建LAMP环境\r\n\r\n2. 不断熟悉linux下的操作命令\r\n\r\n3. 尝试svn和git\r\n\r\n4. 熟悉python\r\n\r\n5. 第一步：会用python写爬虫\r\n\r\n6. 学习shell编程\r\n\r\n7. 用shell小一些小脚本\r\n\r\n8. 学会用PS搞一些简单小东西\r\n\r\n9. 学习Node.js\r\n\r\n10. 学习React\r\n\r\n11. 学习React Native', '<p>现在的一个状况是，PHP懂个基础，可以独立开发一个后台，APP接口，进行数据库操作，写点简单js。但是，都是最基础的操作，用最简单的方式实现功能，没有太多性能啊之类上的考虑，以目前的知识也无法考虑到，毕竟接触编程也不久，所以现在急于提升自己。</p>\r\n<p>虽然说，有些基础东西的东西也还没有彻底打扎实，但是总觉得这是一个过程，慢慢打就扎实了，所以还是觉得学点新技术比较好。但是问题来了，每当下班回到家坐在电脑前的时候，想学点东西，却不知道该从哪里开始。这时候发现了制定一个学习计划的重要性。所以列了一个清单，准备一条一条来，当然之后可能会调整，没关系，先照这个开始：</p>\r\n<p><strong>PHP相关：</strong></p>\r\n<ol>\r\n<li><p>熟悉正则表达式，并能写正则。</p>\r\n</li><li><p>如何使php代码更严谨。</p>\r\n</li><li><p>php实现冒泡排序，选择排序，插入排序和快速排序。</p>\r\n</li><li><p>深入理解mysql数据库防sql注入。</p>\r\n</li><li><p>php开发之网站安全(SQL注入、验证码、刷新提交、漏洞扫描、DOS攻击、跨域攻击)</p>\r\n</li><li><p>命名空间的探究，和高级功能。</p>\r\n</li><li><p>魔术方法的应用；写实例。</p>\r\n</li><li><p>序列化 (Serialize/Unserialize) 研究，与json的比较</p>\r\n</li><li><p>自己封装一些常用的功能类：分页类；验证码类；图像处理类；文件上传类；数据验证类。</p>\r\n</li><li><p>php加密方法探究。</p>\r\n</li><li><p>api接口安全性问题(加密等)</p>\r\n</li><li><p>影响mysql中innodb/myisam性能的配置选项。</p>\r\n</li><li><p>索引探究：MyISAM与InnoDB的区别；MyISAM的主键索引和其它索引的区别；InnoDB的主键索引和其它索引的区别。</p>\r\n</li><li><p>php应用mysql事务；写实例。</p>\r\n</li><li><p>php文件“高级”操作。</p>\r\n</li><li><p>PHP“高级”图像操作。</p>\r\n</li><li><p>PHP设计模式。</p>\r\n</li><li><p>PHP SPL（标准库）使用。</p>\r\n</li><li><p>深入了解HTTP协议。</p>\r\n</li><li><p>了解浏览器的运行机制。</p>\r\n</li><li><p>AB并发测试与调优。</p>\r\n</li><li><p>认识key-value存储系统（mencache，redis）</p>\r\n</li><li><p>学习如何使用memcache</p>\r\n</li><li><p>学习如何使用redis</p>\r\n</li><li><p>memcache与redis比较</p>\r\n</li><li><p>了解Memcached的内存结构(slab机制)，redis了解常用数据类型底层实现存储结构(SDS/链表/SkipList/HashTable)等等。</p>\r\n</li><li><p>了解一下Redis的事务、RDB、AO</p>\r\n</li><li><p>什么是消息队列，如何实现消息队列。</p>\r\n</li><li><p>PHP+memcache实现消息队列</p>\r\n</li><li><p>用php+redis实现消息队列</p>\r\n</li><li><p>php的缓存</p>\r\n</li><li><p>用memcache和redis实现php缓存操作</p>\r\n</li><li><p>什么是分布式架构，分布式与集群的区别，以及分布式如何实现。</p>\r\n</li><li><p>了解mongodb，以及在php上的应用。</p>\r\n</li><li><p>学习使用mongodb</p>\r\n</li><li><p>mongodb，redis，memcache比较。</p>\r\n</li><li><p>什么是哈希算法？</p>\r\n</li><li><p>一致性哈希的应用</p>\r\n</li><li><p>PHP hashTbale</p>\r\n</li><li><p>什么是Socket编程，学习Socket编程。</p>\r\n</li><li><p>编写php简单的Socket通信实例</p>\r\n</li><li><p>学习Laravel框架</p>\r\n</li><li><p>了解php-fpm的大部分配置选项和含义</p>\r\n</li><li><p>MySQL的核心关键技术，比如事务机制(隔离级别、锁等)、对触发器、 分区等技术。</p>\r\n</li><li><p>MySQL性能选项：innodb_log_buffer_size/back_log/table_open_cache/thread_cache_size/innodb_lock_wait_timeout等。</p>\r\n</li><li><p>MySQL性能：磁盘优化(SAS迁移到SSD)、服务器优化(内存、服务器本身配置)、连接池软件选择应用</p>\r\n</li><li><p>MySQL备份技术的深入熟悉，包括灾备 还原、对Binlog的深入理解，冷热备份，多IDC备份等</p>\r\n</li><li><p>Redis进阶：做一些复杂的数据结构的应用(zset做排行榜排序操作/事务处理用来保证原子性在秒杀类场景应用之类的使用操作)</p>\r\n</li><li><p>一个高可用的Redis应用架构和集群</p>\r\n</li><li><p>php服务器压力测试和性能测试探究</p>\r\n</li><li><p>SQL优化总结</p>\r\n</li><li><p>如何架构一个PHP高并发高负载系统</p>\r\n</li><li><p>架构与部署(ECS、RDS、OCS、OSS、SLB)的研究</p>\r\n</li></ol>\r\n<p><strong>其它相关：</strong></p>\r\n<ol>\r\n<li><p>学会搭建LAMP环境</p>\r\n</li><li><p>不断熟悉linux下的操作命令</p>\r\n</li><li><p>尝试svn和git</p>\r\n</li><li><p>熟悉python</p>\r\n</li><li><p>第一步：会用python写爬虫</p>\r\n</li><li><p>学习shell编程</p>\r\n</li><li><p>用shell小一些小脚本</p>\r\n</li><li><p>学会用PS搞一些简单小东西</p>\r\n</li><li><p>学习Node.js</p>\r\n</li><li><p>学习React</p>\r\n</li><li><p>学习React Native</p>\r\n</li></ol>\r\n', '', 0, 'publish', 1, 0, '/article/4.html', '', 0, 89, '2016-09-30 08:08:27', '2016-09-30 08:08:27', '2018-01-07 04:11:07', NULL);
INSERT INTO `pt_post` VALUES (5, 10, 'article', '这世界不止眼前的苟且，还有诗和远方', '\r\n\r\n科技发展真是上了天一般，稍微一不留神，就与这时代的列车脱轨了。\r\n\r\n依稀记得小时候，趴在地上看报纸，报纸上说，电动汽车将在十年之后出现，那时候心里想着：车还能用电啊，老牛逼了！啥时候有啊！一心的期盼。\r\n\r\n那一年，微博才刚刚开始，而我，拿着诺基亚手机，刷着wap版微博。高二高三那段时间，每天放学回家晚上睡觉前，趟在床上，看看又有哪位明星加入了微博。大嘴姚晨盘踞粉丝榜第一；神奇的李开复；章子怡一如既往的稀土部队不加V；等等都是我茶余饭后无聊时打发的回忆。\r\n\r\n那一年，我依旧拿着诺基亚手机，用UC玩着传说中的网页版网游，点一下造兵造坦克，点一下出击攻城。只不过，玩的都是文字。\r\n\r\n那一年，iPhone横空出世。iPhone的价格，使得手握一台苹果，是多么的高逼格。\r\n\r\n那几年，互联网发展的速度，远比我们想的要快得多。而我们，一不留神，就脱轨了。\r\n\r\n大学报考志愿，心怀着对计算机的渴望的翅膀扑腾扑腾，却被父母拍了下来。环境科学，一个在我还没入学时心中的印象是跟园林相关一类的专业，进去后发现要学生物，学化学，学生物化学，学能源等等。\r\n\r\n因为性格的原因，话少，死宅。死宅到什么程度？有一次基友约我出去吃寿司。\r\n“走啊走啊。我买美团券！四人餐，超便宜！”\r\n“吃得饱？”\r\n“四人餐啊！”\r\n“对啊，不是团购吗！不是一个意思！”\r\n那时候的我，对于美团这一类软件，毫无概念。理论上，宅家里应该更对APP更熟才对？因为没事下软件玩一玩？但是我却没有。在日益取代PC端的移动端面前，我毫无概念。一方面，移动端app逐渐走进生活日常，出去浪更能接触常用app，而死宅只能对着电脑自娱自乐了；再一个，那时候的我还停留在手机只要能打电话发短信玩微信就行了的阶段，所以我买的手机是便宜的，省钱，高端黑科技与我又毫无关联了。经济基础和时代观念成为了与时代接轨的要素，而我只能庆幸自己是最早注册微信的用户之一，以至于不会当别人问我微信时还不知道微信是什么鬼而报了QQ号。\r\n\r\n那时候的我，对未来没有任何的概念，迷茫。可能跟很多大学生一样，迷茫。在环境科学这一块，其实兴趣并不大，我甚至想象不出将来毕业后的场景。在当今中国，所谓的环保重视是很有限的，说环境科学要火也是有限的，因为经济不管怎么都是第一要素，环境治理是基于经济发展的，经济倒退何来钱去治理。即使环境重视起来了，也是一门小众学科，环境治理不可能让所有人停下手上的工作，而只需要一批人去做就行。当然，36行行行出状元也是对的，走环境这条路也一样，不管走什么路，有心去做努力就能做好，不管如何问心无愧。四年了，环境科学也没见就火起来了，柴静也救不了你。也许，是因为，我的兴趣点，偏了。\r\n\r\n毕业后的我，果然，转行了。毫无防备，毫无征兆，顺其自然地，走上了IT的路子。一个从未接触过的领域，而且是技术类的领域，我竟一点也不怂，相反，这段时间的工作中，感觉特别充实，总是莫名其妙地上班下班一天就过去了。\r\n\r\n当然，人是要有追求的，不能单纯地当一个快乐的码农，要往更高的方向瞅一瞅（当然快乐的码农也没错，人各有志）。不要永远等着老司机来带你，列车一直在开，挤不挤得上，看本事了。\r\n', '<p>科技发展真是上了天一般，稍微一不留神，就与这时代的列车脱轨了。</p>\r\n<p>依稀记得小时候，趴在地上看报纸，报纸上说，电动汽车将在十年之后出现，那时候心里想着：车还能用电啊，老牛逼了！啥时候有啊！一心的期盼。</p>\r\n<p>那一年，微博才刚刚开始，而我，拿着诺基亚手机，刷着wap版微博。高二高三那段时间，每天放学回家晚上睡觉前，趟在床上，看看又有哪位明星加入了微博。大嘴姚晨盘踞粉丝榜第一；神奇的李开复；章子怡一如既往的稀土部队不加V；等等都是我茶余饭后无聊时打发的回忆。</p>\r\n<p>那一年，我依旧拿着诺基亚手机，用UC玩着传说中的网页版网游，点一下造兵造坦克，点一下出击攻城。只不过，玩的都是文字。</p>\r\n<p>那一年，iPhone横空出世。iPhone的价格，使得手握一台苹果，是多么的高逼格。</p>\r\n<p>那几年，互联网发展的速度，远比我们想的要快得多。而我们，一不留神，就脱轨了。</p>\r\n<p>大学报考志愿，心怀着对计算机的渴望的翅膀扑腾扑腾，却被父母拍了下来。环境科学，一个在我还没入学时心中的印象是跟园林相关一类的专业，进去后发现要学生物，学化学，学生物化学，学能源等等。</p>\r\n<p>因为性格的原因，话少，死宅。死宅到什么程度？有一次基友约我出去吃寿司。<br>“走啊走啊。我买美团券！四人餐，超便宜！”<br>“吃得饱？”<br>“四人餐啊！”<br>“对啊，不是团购吗！不是一个意思！”<br>那时候的我，对于美团这一类软件，毫无概念。理论上，宅家里应该更对APP更熟才对？因为没事下软件玩一玩？但是我却没有。在日益取代PC端的移动端面前，我毫无概念。一方面，移动端app逐渐走进生活日常，出去浪更能接触常用app，而死宅只能对着电脑自娱自乐了；再一个，那时候的我还停留在手机只要能打电话发短信玩微信就行了的阶段，所以我买的手机是便宜的，省钱，高端黑科技与我又毫无关联了。经济基础和时代观念成为了与时代接轨的要素，而我只能庆幸自己是最早注册微信的用户之一，以至于不会当别人问我微信时还不知道微信是什么鬼而报了QQ号。</p>\r\n<p>那时候的我，对未来没有任何的概念，迷茫。可能跟很多大学生一样，迷茫。在环境科学这一块，其实兴趣并不大，我甚至想象不出将来毕业后的场景。在当今中国，所谓的环保重视是很有限的，说环境科学要火也是有限的，因为经济不管怎么都是第一要素，环境治理是基于经济发展的，经济倒退何来钱去治理。即使环境重视起来了，也是一门小众学科，环境治理不可能让所有人停下手上的工作，而只需要一批人去做就行。当然，36行行行出状元也是对的，走环境这条路也一样，不管走什么路，有心去做努力就能做好，不管如何问心无愧。四年了，环境科学也没见就火起来了，柴静也救不了你。也许，是因为，我的兴趣点，偏了。</p>\r\n<p>毕业后的我，果然，转行了。毫无防备，毫无征兆，顺其自然地，走上了IT的路子。一个从未接触过的领域，而且是技术类的领域，我竟一点也不怂，相反，这段时间的工作中，感觉特别充实，总是莫名其妙地上班下班一天就过去了。</p>\r\n<p>当然，人是要有追求的，不能单纯地当一个快乐的码农，要往更高的方向瞅一瞅（当然快乐的码农也没错，人各有志）。不要永远等着老司机来带你，列车一直在开，挤不挤得上，看本事了。</p>\r\n', '', 0, 'publish', 1, 0, '/article/5.html', '', 0, 89, '2016-09-14 07:16:48', '2016-09-14 07:16:48', '2018-01-04 17:58:31', NULL);
INSERT INTO `pt_post` VALUES (6, 10, 'article', '2016年回顾总结', '2016年，可以说是最折腾的一年。2016的最后一天，是在广州的医院里陪老妈度过的。\r\n\r\n先回顾一下学习工作方面吧，实际上一月份才开始找工作，过年前几天拼了命找呀，就想着年后上班，主要是想在上海稳下来。然后第一份工作，B2B电商平台，卖食品的，实际上我在看到这套程序代码的时候，我是有点接受不来，因为连我这种刚出来混的都觉得这代码有点low。当然，每一份工作都会有所收获，在这里我学到了:熟悉了Ecshop电商系统，基本上能做ecshop的二次开发;用这个项目练了练手，熟悉了一下学了不久的php，熟悉了一些开发过程中中可能会用到的工具，理念，调试方法等等;自己了解了微信公众平台的开发。\r\n\r\n第一份工作时间不长，三个月没转正，我就走了，原因是ecshop的二次开发，对于我这种初学者来说，每天重复着在ecshop里添加一些简单的功能，填别人挖的坑，对于我来说提高不大。刚出来混，还是学习深入一点的东西比较好。接下来，一个金融公司，这时候开始独立做app后台了。说实话一开始有点慌，后来过几天之后，就得心应手了，因为比较自由，连框架的选用都是我自己决定，只要我实现了功能就行。在这里，我学会了:熟练了ThinkPHP框架;熟练了命名空间面向对象等一些新的特性;理解了App后台和接口的一些概念，并且能够独立完成这些内容;学会设计一个简单的数据库等。\r\n\r\n第二份工作也干得不长，这个项目做完之后，没上线，反而是被停掉了。本来打算至少待一年的，没办法，后来就准备回深圳了。第三份工作，也就是现在，才一个多月，现在准备开始一个云平台的项目。来到这边，我觉得将会有很大的提高，因为其它人也很年轻，也在学习，我有更多的时间去学习和接触新的东西。就这一个多月的时间里，我已经逐渐地在了解学习Redis，composer，git，Nginx等内容了。而且在未来我也要自己抽一些时间去做一些东西了。\r\n\r\n总体上，2016年，从上海到深圳，在工作上我觉得是很充实的，学到的东西还是挺多的，而且碰到的同事也都非常不错。就是年尾老妈突然生病这个有点蛋疼，也幸好是回来广东回来得早。\r\n\r\n对于2017，技术上，我希望自己能够掌握laravel，swoole，vue.js，不说熟练至少熟悉Linux，看完mysql那本书(真正掌握mysql)，完成一个属于自己的项目，如果有时间学习一下数据结构和算法。生活上，老妈身体健康调整好心态，女朋友顺利来广东，一家人开开心心。当然，要开始想办法赚钱了，现在压力有点大。\r\n', '<p>2016年，可以说是最折腾的一年。2016的最后一天，是在广州的医院里陪老妈度过的。</p>\r\n<p>先回顾一下学习工作方面吧，实际上一月份才开始找工作，过年前几天拼了命找呀，就想着年后上班，主要是想在上海稳下来。然后第一份工作，B2B电商平台，卖食品的，实际上我在看到这套程序代码的时候，我是有点接受不来，因为连我这种刚出来混的都觉得这代码有点low。当然，每一份工作都会有所收获，在这里我学到了:熟悉了Ecshop电商系统，基本上能做ecshop的二次开发;用这个项目练了练手，熟悉了一下学了不久的php，熟悉了一些开发过程中中可能会用到的工具，理念，调试方法等等;自己了解了微信公众平台的开发。</p>\r\n<p>第一份工作时间不长，三个月没转正，我就走了，原因是ecshop的二次开发，对于我这种初学者来说，每天重复着在ecshop里添加一些简单的功能，填别人挖的坑，对于我来说提高不大。刚出来混，还是学习深入一点的东西比较好。接下来，一个金融公司，这时候开始独立做app后台了。说实话一开始有点慌，后来过几天之后，就得心应手了，因为比较自由，连框架的选用都是我自己决定，只要我实现了功能就行。在这里，我学会了:熟练了ThinkPHP框架;熟练了命名空间面向对象等一些新的特性;理解了App后台和接口的一些概念，并且能够独立完成这些内容;学会设计一个简单的数据库等。</p>\r\n<p>第二份工作也干得不长，这个项目做完之后，没上线，反而是被停掉了。本来打算至少待一年的，没办法，后来就准备回深圳了。第三份工作，也就是现在，才一个多月，现在准备开始一个云平台的项目。来到这边，我觉得将会有很大的提高，因为其它人也很年轻，也在学习，我有更多的时间去学习和接触新的东西。就这一个多月的时间里，我已经逐渐地在了解学习Redis，composer，git，Nginx等内容了。而且在未来我也要自己抽一些时间去做一些东西了。</p>\r\n<p>总体上，2016年，从上海到深圳，在工作上我觉得是很充实的，学到的东西还是挺多的，而且碰到的同事也都非常不错。就是年尾老妈突然生病这个有点蛋疼，也幸好是回来广东回来得早。</p>\r\n<p>对于2017，技术上，我希望自己能够掌握laravel，swoole，vue.js，不说熟练至少熟悉Linux，看完mysql那本书(真正掌握mysql)，完成一个属于自己的项目，如果有时间学习一下数据结构和算法。生活上，老妈身体健康调整好心态，女朋友顺利来广东，一家人开开心心。当然，要开始想办法赚钱了，现在压力有点大。</p>\r\n', '', 0, 'publish', 1, 0, '/article/6.html', 'https://www.goozp.com/uploads/2018/01/2016huigu.jpg', 0, 101, '2017-01-01 01:44:00', '2017-01-01 01:44:00', '2018-01-04 18:13:30', NULL);
INSERT INTO `pt_post` VALUES (7, 10, 'article', '2017年回顾总结', '不知不觉已经2018年了，前几天忙于zPhal项目的收尾，现在项目上线测试，就来总结一下2017年吧。\r\n\r\n如果说2016年是折腾的一年，那么2017年应该是知识爆炸的一年，这一年学了很多很多！\r\n\r\n先总结一下工作上的内容，这一年没换工作，一直在这家公司干。项目上，大项目就是一个云平台，其它小项目就比较多，比较杂。在这边工作，学了两个框架，TP5和workerman，workerman其实是我自己学，然后应用到公司项目中的。公司项目线上的服务器交给我管理，那对于Linux服务器开始有了简单的了解，自己也去搞了自己的Linux服务器开始玩。Nginx的配置也熟悉起来了，现在开始WebServer也会优先使用Nginx，毕竟比Apache还熟悉了估计。公司的项目用Git来管理，这样我也会用Git来做版本管理了，然后写自己的东西时也用上了。还有一点是，因为公司项目的原因，我开始了解通讯相关的，比如说workerman做后台用TCP与客户端对接，通讯方面的应用我觉得还是很重要的。\r\n\r\n除了工作上的内容，自己工作外充电时必须的。一开始做了两个WordPress主题，第二个其实是比较满意的。而最重点的是zPhal这个开源项目，也是我下半年一直在忙的东西；整个项目历时五个月，用下班后业余时间来完成；因为设想是类似于Wordpress这种全功能的大博客系统，但追求性能，所以还是比较麻烦的；现在上的也只是初始版本，阉割了很多功能。初衷其实是想通过这个项目，学通Phalcon这个框架，同时从头至尾自己完成一个像样的项目，并且开源。最后做出来，我还是挺开心，基本上Phalcon这个框架已经熟悉了，对zPhal进行压测，感觉效率也可以。\r\n\r\n除此之外，其它乱七八糟的东西也学了很多，什么composer啊，网络抓包调试工具啊之类的；还有一个重要的东西是Docker，现在这个博客已经是基于Docker环境在跑，这也是我之前关注的一个点。\r\n\r\n不过，去年也有一些事情没有达成，MySQL那本书说要看完的，还没看。以及数据结构与算法还没正式过一遍，不过现在准备开始了，准备开始认真撸一遍而且做总结记录。\r\n\r\n现在有一种感觉，就是随着时间的推移，学的东西越来越多，经验积累下来确实会有很大的不同。举个例子，比如一年前，你说负载均衡，百度一下原来负载均衡是巴拉巴拉，哦是这样哦；过去一年了，你再去回想一年前对这个概念的认识，会发现没有错啊，负载均衡确实就是一年前认为的这样，概念上确实是没错的。但是负载均衡就是“负载均衡”了吗？你会有完全不同的一个更深层次的认识来“推翻”你之前的认识，但并不是你之前就是错的，只是你有了更深的认识，这就是经验。\r\n\r\n关于2018年的展望，其实比较简单：\r\n1. PHP方面掌握Swoole\r\n2. 进一步熟悉Linux和学习写脚本\r\n3. 学会Golang并且写一些东西\r\n4. 迭代zPhal形成一个舒服的版本\r\n5. 彻底撸掉数据结构和算法的基础，并且不断学习\r\n\r\n主要就是这么5个任务，第五点是重中之重，因为是我落了很久的东西。2018年过去，就是3年经验这道坎，内功要修炼好，基础很重要，算法很重要。其它的就不列了，因为总有一些东西会穿插在计划之中。', '<p>不知不觉已经2018年了，前几天忙于zPhal项目的收尾，现在项目上线测试，就来总结一下2017年吧。</p>\r\n<p>如果说2016年是折腾的一年，那么2017年应该是知识爆炸的一年，这一年学了很多很多！</p>\r\n<p>先总结一下工作上的内容，这一年没换工作，一直在这家公司干。项目上，大项目就是一个云平台，其它小项目就比较多，比较杂。在这边工作，学了两个框架，TP5和workerman，workerman其实是我自己学，然后应用到公司项目中的。公司项目线上的服务器交给我管理，那对于Linux服务器开始有了简单的了解，自己也去搞了自己的Linux服务器开始玩。Nginx的配置也熟悉起来了，现在开始WebServer也会优先使用Nginx，毕竟比Apache还熟悉了估计。公司的项目用Git来管理，这样我也会用Git来做版本管理了，然后写自己的东西时也用上了。还有一点是，因为公司项目的原因，我开始了解通讯相关的，比如说workerman做后台用TCP与客户端对接，通讯方面的应用我觉得还是很重要的。</p>\r\n<p>除了工作上的内容，自己工作外充电时必须的。一开始做了两个WordPress主题，第二个其实是比较满意的。而最重点的是zPhal这个开源项目，也是我下半年一直在忙的东西；整个项目历时五个月，用下班后业余时间来完成；因为设想是类似于Wordpress这种全功能的大博客系统，但追求性能，所以还是比较麻烦的；现在上的也只是初始版本，阉割了很多功能。初衷其实是想通过这个项目，学通Phalcon这个框架，同时从头至尾自己完成一个像样的项目，并且开源。最后做出来，我还是挺开心，基本上Phalcon这个框架已经熟悉了，对zPhal进行压测，感觉效率也可以。</p>\r\n<p>除此之外，其它乱七八糟的东西也学了很多，什么composer啊，网络抓包调试工具啊之类的；还有一个重要的东西是Docker，现在这个博客已经是基于Docker环境在跑，这也是我之前关注的一个点。</p>\r\n<p>不过，去年也有一些事情没有达成，MySQL那本书说要看完的，还没看。以及数据结构与算法还没正式过一遍，不过现在准备开始了，准备开始认真撸一遍而且做总结记录。</p>\r\n<p>现在有一种感觉，就是随着时间的推移，学的东西越来越多，经验积累下来确实会有很大的不同。举个例子，比如一年前，你说负载均衡，百度一下原来负载均衡是巴拉巴拉，哦是这样哦；过去一年了，你再去回想一年前对这个概念的认识，会发现没有错啊，负载均衡确实就是一年前认为的这样，概念上确实是没错的。但是负载均衡就是“负载均衡”了吗？你会有完全不同的一个更深层次的认识来“推翻”你之前的认识，但并不是你之前就是错的，只是你有了更深的认识，这就是经验。</p>\r\n<p>关于2018年的展望，其实比较简单：</p>\r\n<ol>\r\n<li>PHP方面掌握Swoole</li><li>进一步熟悉Linux和学习写脚本</li><li>学会Golang并且写一些东西</li><li>迭代zPhal形成一个舒服的版本</li><li>彻底撸掉数据结构和算法的基础，并且不断学习</li></ol>\r\n<p>主要就是这么5个任务，第五点是重中之重，因为是我落了很久的东西。2018年过去，就是3年经验这道坎，内功要修炼好，基础很重要，算法很重要。其它的就不列了，因为总有一些东西会穿插在计划之中。</p>\r\n', '', 0, 'publish', 1, 0, '/article/7.html', 'https://www.goozp.com/uploads/2018/01/2018_min.jpg', 0, 137, '2018-01-05 07:03:32', '2018-01-05 07:03:32', '2018-01-07 18:53:33', NULL);
INSERT INTO `pt_post` VALUES (8, 10, 'article', '用Workerman快速实现Socket服务', '本文首先将对Workerman有一个简单的认知介绍，然后通过我遇到过的一个小项目捋一遍用Workerman来快速实现Socket服务。\r\n\r\n# 1. 知识储备\r\n在开始使用workerman之前，可能需要了解这些：\r\n- 网络通讯协议（HTTP、TCP等）\r\n- 进程和线程\r\n- 了解workerman是什么\r\n- Linux与Windows\r\n- ……\r\n\r\nWorkerman官方的解释：[http://doc.workerman.net/315119](http://doc.workerman.net/315119 \"http://doc.workerman.net/315119\")\r\n\r\n# 2. Workerman vs Swoole\r\nSwoole是个好东西，拟补了PHP的很多空白，功能上也会比workerman多，C拓展方式性能也没得说，但是就是相比workerman门槛高一点（官方文档不清晰是一方面）。\r\n\r\nWorkerman纯PHP编写，文档做得很好，上手非常简单，可以快速开发功能，性能也很不错。Workerman还有一个分支项目GatewayWorker，如果项目是长连接并且需要客户端与客户端之间通讯，可以使用GatewayWorker更快速实现功能。\r\n\r\n# 3. 知识概览\r\nWorkerMan中有两个重要的类Worker与Connection。\r\n## 3.1 Worker类\r\nWorkerman中的端口监听通过Worker类实现\r\n\r\nWorker类有这么些个回调函数：\r\n- onWorkerStart Worker启动时\r\n- onWorkerReload Worker收到reload信号后\r\n- onConnect 建立链接时(TCP三次握手完成后)触发\r\n- onMessage 客户端通过链接发来数据时(Workerman收到数据时)\r\n- onClose 客户端连接与Workerman断开时\r\n- onBufferFull 超过缓冲区大小限制时\r\n- onBufferDrain 应用层发送缓冲区数据全部发送完毕后\r\n- onError 当客户端的连接上发生错误时\r\n\r\nWorker类有这么些个接口：\r\n- runAll 运行所有Worker实例\r\n- stopAll 停止当前进程（子进程）的所有Worker实例并退出\r\n- listen 用于实例化Worker后执行监听\r\n\r\n## 3.2 Connection类\r\n每个客户端连接对应一个Connection对象。\r\n\r\nConnection类有这么些个回调函数：\r\n- onMessage 作用与Worker::$onMessage回调相同，区别是只针对当前连接有效\r\n- onClose 此回调与Worker::$onClose回调作用相同，区别是只针对当前连接有效\r\n- onBufferFull 作用与Worker::$onBufferFull回调相同，区别是只针对当前连接起作用\r\n- onBufferDrain 作用与Worker::$onBufferDrain回调相同，区别是只针对当前连接起作用\r\n- onError 作用与Worker::$onError回调相同，区别是只针对当前连接起作用\r\n\r\nConnection类有这么些个接口：\r\n- send 向客户端发送数据\r\n- getRemoteIp 获得该连接的客户端ip\r\n- getRemotePort 获得该连接的客户端端口\r\n- close 全的关闭连接\r\n- destroy 立刻关闭连接\r\n- pauseRecv 使当前连接停止接收数据\r\n- resumeRecv 使当前连接继续接收数据\r\n- pipe 将当前连接的数据流导入到目标连接\r\n\r\n## 3.3 其它\r\n- AsyncTcpConnection类\r\n- Timer定时器类\r\n- WebServer\r\n\r\n# 4. 开始实现\r\n## 4.1 确定需求\r\n首先明确需要做什么，要达到什么目的；以之前做过的一个项目为例，实现一个可以通过APP实时控制的音乐播放系统，大概是以下的模式：\r\n![播放器架构](https://www.goozp.com/uploads/2018/01/%E6%92%AD%E6%94%BE%E5%99%A8%E6%9E%B6%E6%9E%84.png \"播放器架构\")\r\n要做到实时推送操作指令达到控制音乐的播放，首先要接收到移动端发来的指令，然后分析，根据指令操纵H5播放器，返回结果，通知移动端。在这里，我们用了WebSocket在浏览器与Server建立了连接来操纵H5播放器，因为移动端不是我们开发，以及这是一个局域网项目，为了使项目更简单，移动端采用了HTTP接口调用的方式（这种方式，在操纵完播放器返回时，我们需要做点手脚，以及会有一定的性能损失），当然最方便最好的就是移动端跟Server建立长连接。\r\n\r\n## 4.2 安装准备\r\n明确了需求，确定了技术方向后，就可以开始干了。虽然workerman有windows版本，不过在windows上是阉割版，能用Linux还是linux。\r\n\r\n安装流程：[http://doc.workerman.net/315114](http://doc.workerman.net/315114 \"http://doc.workerman.net/315114\")\r\nwindows版本的说明：[http://www.workerman.net/windows](http://www.workerman.net/windows \"http://www.workerman.net/windows\")\r\n\r\n## 4.3 一个简单Server\r\n以WebSocket为例新建一个简单的Server：\r\n\r\n### 1）新建一个项目目录\r\n\r\n### 2）引入workerman（Workerman/Autoloader.php）\r\n\r\nrequire_once ‘/your/path/Workerman/Autoloader.php’;\r\n\r\n### 3）确定协议\r\n目前WorkerMan支持HTTP、Websocket、Text文本协议(WorkerMan中自定义的一个协议，格式为文本+换行)，如果需要使用其它协议，可以参照 [http://doc.workerman.net/315123](http://doc.workerman.net/315123 \"http://doc.workerman.net/315123\") 通讯协议一章开发自己的协议。\r\n这里我们以 Websocket 协议为例。\r\n\r\n### 4）编写程序start_websocket.php\r\n一个简单的示例：\r\n```php\r\n<?php\r\nuse Workerman\\Worker;\r\nrequire_once __DIR__ . \'/path/to/Workerman/Autoloader.php\';\r\n \r\n// 创建一个Worker监听端口，使用websocket协议通讯\r\n$ws_worker = new Worker(\'websocket://0.0.0.0:2345\');\r\n \r\n$ws_worker->count = 1;// 进程数\r\n$ws_worker->name = \'mPlayer\';// worker名称\r\n \r\n//Worker启动后立即执行的回调函数\r\n$ws_worker->onWorkerStart = function($ws_worker)\r\n{\r\n    // ...\r\n};\r\n \r\n// 连接建立时触发\r\n$ws_worker->onConnect = function($connection)use($ws_worker)\r\n{\r\n    // 设置连接的onMessage回调\r\n    $connection->onMessage = function($connection, $data)\r\n    {\r\n        $connection->send(\'receive success\');\r\n    };\r\n    // ...\r\n};\r\n \r\n// 当收到客户端发来的数据时\r\n$ws_worker->onMessage = function($connection, $data)\r\n{\r\n    $connection->send(\'receive success\');\r\n    // ...\r\n};\r\n \r\n// 如果不是在根目录启动，则运行runAll方法\r\nif(!defined(\'GLOBAL_START\'))\r\n{\r\n    Worker::runAll();\r\n}\r\n```\r\n\r\n### 5）运行Server\r\nLinux下：\r\n以debug（调试）方式启动：`php start.php start`\r\n以daemon（守护进程）方式启动：`php start.php start -d`\r\n\r\nWindows下：\r\ncmd命令行启动：`php start_websocket.php`\r\n\r\n### 6）进行测试\r\n进行测试，可以抓包看看请求的状况。', '<p>本文首先将对Workerman有一个简单的认知介绍，然后通过我遇到过的一个小项目捋一遍用Workerman来快速实现Socket服务。</p>\r\n<h1 id=\"h1-1-\"><a name=\"1. 知识储备\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1. 知识储备</h1><p>在开始使用workerman之前，可能需要了解这些：</p>\r\n<ul>\r\n<li>网络通讯协议（HTTP、TCP等）</li><li>进程和线程</li><li>了解workerman是什么</li><li>Linux与Windows</li><li>……</li></ul>\r\n<p>Workerman官方的解释：<a href=\"http://doc.workerman.net/315119\" title=\"http://doc.workerman.net/315119\">http://doc.workerman.net/315119</a></p>\r\n<h1 id=\"h1-2-workerman-vs-swoole\"><a name=\"2. Workerman vs Swoole\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2. Workerman vs Swoole</h1><p>Swoole是个好东西，拟补了PHP的很多空白，功能上也会比workerman多，C拓展方式性能也没得说，但是就是相比workerman门槛高一点（官方文档不清晰是一方面）。</p>\r\n<p>Workerman纯PHP编写，文档做得很好，上手非常简单，可以快速开发功能，性能也很不错。Workerman还有一个分支项目GatewayWorker，如果项目是长连接并且需要客户端与客户端之间通讯，可以使用GatewayWorker更快速实现功能。</p>\r\n<h1 id=\"h1-3-\"><a name=\"3. 知识概览\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3. 知识概览</h1><p>WorkerMan中有两个重要的类Worker与Connection。</p>\r\n<h2 id=\"h2-3-1-worker-\"><a name=\"3.1 Worker类\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.1 Worker类</h2><p>Workerman中的端口监听通过Worker类实现</p>\r\n<p>Worker类有这么些个回调函数：</p>\r\n<ul>\r\n<li>onWorkerStart Worker启动时</li><li>onWorkerReload Worker收到reload信号后</li><li>onConnect 建立链接时(TCP三次握手完成后)触发</li><li>onMessage 客户端通过链接发来数据时(Workerman收到数据时)</li><li>onClose 客户端连接与Workerman断开时</li><li>onBufferFull 超过缓冲区大小限制时</li><li>onBufferDrain 应用层发送缓冲区数据全部发送完毕后</li><li>onError 当客户端的连接上发生错误时</li></ul>\r\n<p>Worker类有这么些个接口：</p>\r\n<ul>\r\n<li>runAll 运行所有Worker实例</li><li>stopAll 停止当前进程（子进程）的所有Worker实例并退出</li><li>listen 用于实例化Worker后执行监听</li></ul>\r\n<h2 id=\"h2-3-2-connection-\"><a name=\"3.2 Connection类\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.2 Connection类</h2><p>每个客户端连接对应一个Connection对象。</p>\r\n<p>Connection类有这么些个回调函数：</p>\r\n<ul>\r\n<li>onMessage 作用与Worker::$onMessage回调相同，区别是只针对当前连接有效</li><li>onClose 此回调与Worker::$onClose回调作用相同，区别是只针对当前连接有效</li><li>onBufferFull 作用与Worker::$onBufferFull回调相同，区别是只针对当前连接起作用</li><li>onBufferDrain 作用与Worker::$onBufferDrain回调相同，区别是只针对当前连接起作用</li><li>onError 作用与Worker::$onError回调相同，区别是只针对当前连接起作用</li></ul>\r\n<p>Connection类有这么些个接口：</p>\r\n<ul>\r\n<li>send 向客户端发送数据</li><li>getRemoteIp 获得该连接的客户端ip</li><li>getRemotePort 获得该连接的客户端端口</li><li>close 全的关闭连接</li><li>destroy 立刻关闭连接</li><li>pauseRecv 使当前连接停止接收数据</li><li>resumeRecv 使当前连接继续接收数据</li><li>pipe 将当前连接的数据流导入到目标连接</li></ul>\r\n<h2 id=\"h2-3-3-\"><a name=\"3.3 其它\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.3 其它</h2><ul>\r\n<li>AsyncTcpConnection类</li><li>Timer定时器类</li><li>WebServer</li></ul>\r\n<h1 id=\"h1-4-\"><a name=\"4. 开始实现\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4. 开始实现</h1><h2 id=\"h2-4-1-\"><a name=\"4.1 确定需求\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.1 确定需求</h2><p>首先明确需要做什么，要达到什么目的；以之前做过的一个项目为例，实现一个可以通过APP实时控制的音乐播放系统，大概是以下的模式：<br><img src=\"https://www.goozp.com/uploads/2018/01/%E6%92%AD%E6%94%BE%E5%99%A8%E6%9E%B6%E6%9E%84.png\" alt=\"播放器架构\" title=\"播放器架构\"><br>要做到实时推送操作指令达到控制音乐的播放，首先要接收到移动端发来的指令，然后分析，根据指令操纵H5播放器，返回结果，通知移动端。在这里，我们用了WebSocket在浏览器与Server建立了连接来操纵H5播放器，因为移动端不是我们开发，以及这是一个局域网项目，为了使项目更简单，移动端采用了HTTP接口调用的方式（这种方式，在操纵完播放器返回时，我们需要做点手脚，以及会有一定的性能损失），当然最方便最好的就是移动端跟Server建立长连接。</p>\r\n<h2 id=\"h2-4-2-\"><a name=\"4.2 安装准备\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.2 安装准备</h2><p>明确了需求，确定了技术方向后，就可以开始干了。虽然workerman有windows版本，不过在windows上是阉割版，能用Linux还是linux。</p>\r\n<p>安装流程：<a href=\"http://doc.workerman.net/315114\" title=\"http://doc.workerman.net/315114\">http://doc.workerman.net/315114</a><br>windows版本的说明：<a href=\"http://www.workerman.net/windows\" title=\"http://www.workerman.net/windows\">http://www.workerman.net/windows</a></p>\r\n<h2 id=\"h2-4-3-server\"><a name=\"4.3 一个简单Server\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.3 一个简单Server</h2><p>以WebSocket为例新建一个简单的Server：</p>\r\n<h3 id=\"h3-1-\"><a name=\"1）新建一个项目目录\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1）新建一个项目目录</h3><h3 id=\"h3-2-workerman-workerman-autoloader-php-\"><a name=\"2）引入workerman（Workerman/Autoloader.php）\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2）引入workerman（Workerman/Autoloader.php）</h3><p>require_once ‘/your/path/Workerman/Autoloader.php’;</p>\r\n<h3 id=\"h3-3-\"><a name=\"3）确定协议\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3）确定协议</h3><p>目前WorkerMan支持HTTP、Websocket、Text文本协议(WorkerMan中自定义的一个协议，格式为文本+换行)，如果需要使用其它协议，可以参照 <a href=\"http://doc.workerman.net/315123\" title=\"http://doc.workerman.net/315123\">http://doc.workerman.net/315123</a> 通讯协议一章开发自己的协议。<br>这里我们以 Websocket 协议为例。</p>\r\n<h3 id=\"h3-4-start_websocket-php\"><a name=\"4）编写程序start_websocket.php\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4）编写程序start_websocket.php</h3><p>一个简单的示例：</p>\r\n<pre><code class=\"lang-php\">&lt;?php\r\nuse Workerman\\Worker;\r\nrequire_once __DIR__ . &#39;/path/to/Workerman/Autoloader.php&#39;;\r\n\r\n// 创建一个Worker监听端口，使用websocket协议通讯\r\n$ws_worker = new Worker(&#39;websocket://0.0.0.0:2345&#39;);\r\n\r\n$ws_worker-&gt;count = 1;// 进程数\r\n$ws_worker-&gt;name = &#39;mPlayer&#39;;// worker名称\r\n\r\n//Worker启动后立即执行的回调函数\r\n$ws_worker-&gt;onWorkerStart = function($ws_worker)\r\n{\r\n    // ...\r\n};\r\n\r\n// 连接建立时触发\r\n$ws_worker-&gt;onConnect = function($connection)use($ws_worker)\r\n{\r\n    // 设置连接的onMessage回调\r\n    $connection-&gt;onMessage = function($connection, $data)\r\n    {\r\n        $connection-&gt;send(&#39;receive success&#39;);\r\n    };\r\n    // ...\r\n};\r\n\r\n// 当收到客户端发来的数据时\r\n$ws_worker-&gt;onMessage = function($connection, $data)\r\n{\r\n    $connection-&gt;send(&#39;receive success&#39;);\r\n    // ...\r\n};\r\n\r\n// 如果不是在根目录启动，则运行runAll方法\r\nif(!defined(&#39;GLOBAL_START&#39;))\r\n{\r\n    Worker::runAll();\r\n}\r\n</code></pre>\r\n<h3 id=\"h3-5-server\"><a name=\"5）运行Server\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5）运行Server</h3><p>Linux下：<br>以debug（调试）方式启动：<code>php start.php start</code><br>以daemon（守护进程）方式启动：<code>php start.php start -d</code></p>\r\n<p>Windows下：<br>cmd命令行启动：<code>php start_websocket.php</code></p>\r\n<h3 id=\"h3-6-\"><a name=\"6）进行测试\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>6）进行测试</h3><p>进行测试，可以抓包看看请求的状况。</p>\r\n', '', 0, 'publish', 1, 0, '/article/8.html', '', 0, 135, '2017-07-20 08:35:59', '2017-07-20 08:35:59', '2018-01-16 07:16:18', NULL);
INSERT INTO `pt_post` VALUES (9, 10, 'article', '消息队列及PHP中的简单实现与应用', '> 本文总结自慕课网的一个教程：[PHP消息队列实现及应用](http://www.imooc.com/learn/852 \"PHP消息队列实现及应用\")；这个教程非常适合新手刚接触消息队列，我觉得蛮不错。\r\n\r\n# 1. 关于消息队列\r\n## 1.1 基础模式\r\n一个基础的消息队列应该是这样的：\r\n![消息队列](https://www.goozp.com/uploads/2018/01/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.png \"消息队列\")\r\n\r\n## 1.2 应用场景\r\n消息队列的应用场景大概可以是以下几种：\r\n- 冗余；\r\n- 解耦（比如业务系统和队列处理系统一方奔溃不会影响另一方）；\r\n- 流量削峰（抢购，秒杀等场景）；\r\n- 异步通信；\r\n- 拓展性；\r\n- 排序保证（比如做成单进程单线程单进单出）；\r\n\r\n## 1.3 队列介质\r\n实现消息队列的方式有很多，这里介绍三种模式的实现：\r\n\r\nMysql：可靠性高、易实现，速度慢\r\n\r\nRedis：速度快，单条大消息包时效率低\r\n\r\n消息系统：专业性强，可靠，学习成本高（RabbitMQ）\r\n\r\n## 1.4 消息处理触发机制\r\n**死循环方式读取**：易实现，故障时无法及时恢复（适合比如秒杀系统）\r\n\r\n**定时任务**：压分均分，有处理上限（要控制好进程，防止上一个任务还没完成就开始了下一个）\r\n\r\n**守护进程**：类似于PHP-FPM和PHP-CG，需要shell基础\r\n\r\n# 2. 案例\r\n## 2.1 解耦案例：处理订单系统和配送系统（Mysql实现）\r\n### 2.1.1 案例架构\r\n订单系统和配送系统是解耦的，通过MySQL队列表做队列：\r\n![消息队列解耦案例](https://www.goozp.com/uploads/2018/01/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E8%A7%A3%E8%80%A6%E6%A1%88%E4%BE%8B.png \"消息队列解耦案例\")\r\n\r\n### 2.1.2 案例流程\r\n程序的大概流程：\r\n![ 消息队列解耦案例程序流程](https://www.goozp.com/uploads/2018/01/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E8%A7%A3%E8%80%A6%E6%A1%88%E4%BE%8B%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B.png \" 消息队列解耦案例程序流程\")\r\n\r\n### 2.1.3 开发流程\r\n1）创建一个示例MySQL队列表：\r\n```sql\r\nCREATE TABLE `order_queue`(\r\n    `id` int(11) unsigned NOT NULL AUTO_INCREMENT COMMENT `id号`,\r\n    `order_id` int(11) NOT NULL,\r\n    `mobile` varchar(20) NOT NULL COMMENT `用户的手机号`,\r\n    `address` varchar(100) NOT NULL COMMENT `用户的地址`,\r\n    `created_at` datetime NOT NULL DEFAULT `0000-00-00 00:00:00` COMMENT `订单创建时间`,\r\n    `updated_at` datetime NOT NULL DEFAULT `0000-00-00 00:00:00` COMMENT `处理完成时间`,\r\n    `status` tinyint(2) NOT NULL COMMENT `当前状态, 0未处理, 1已处理, 2处理中`,\r\n    PRIMARY KEY(`id`)\r\n)ENGINE=InnoDB DEFAULT CHARSET=utf8;\r\n```\r\n\r\n2）接受用户订单order.php:\r\n```php\r\n<?php\r\ninclude \'../include/db.php\'; //引入一个DB类用来操作数据库\r\n \r\nif (!empty($_GET[\'mobile\'])) {\r\n    // 订单处理流程\r\n    // ......\r\n    // 过滤从用户获取的数据\r\n \r\n    $order_id = rand (10000, 99999); // 示例生成订单\r\n    // 要插入的数据\r\n    $insert_data = array(\r\n        \'order_id\' => $order_id,\r\n        \'mobile\'   => $_GET[\'mobile\'],\r\n        \'created_time\' => date(\'Y-m-d H:i:s\', time()),\r\n        \'status\' => 0\r\n    );\r\n \r\n    // 插入数据\r\n    $db = DB::getIntance();\r\n    $res = $db -> insert(\'order_queue\', $insert_data);\r\n    if ($res) {\r\n        echo $insert_data[\'order_id\'].\"保存成功\";\r\n    } else {\r\n        echo \'保存失败\';\r\n    }\r\n}\r\n```\r\n\r\n3）配送处理goods.php\r\n```php\r\n<?php\r\n// 配送系统处理队列中的订单并进行标记的一个文件\r\ninclude \'../include/db.php\'; //引入一个DB类用来操作数据库\r\n \r\n$db = DB::getIntance();\r\n// 1. 先把要处理的记录更新为等待处理; 这一步是为了实现一个锁的机制,防止其它程序操作数据冲突\r\n$waiting = array(\'status\' => 0);\r\n$lock = array(\'status\' => 2);\r\n$res_lock = $db->update(\'order_queue\', $lock, $waiting, 2);\r\n \r\n// 2. 选择出刚刚更新的这些数据, 然后进行配送系统的处理\r\nif ($res_lock) {\r\n    $res = $db->selectAll(\'order_queue\', $lock);\r\n \r\n    // 然后由配送系统进行处理\r\n    // ......\r\n \r\n    // 3. 把这些处理过的程序更新为已完成\r\n    $success = array(\r\n        \'status\' => 1,\r\n        \'update_time\' => date(\'Y-m-d H:i:s\'),\r\n    );\r\n    $res_last = $db->update(\'order_queue\', $success, $lock);\r\n    if ($res_last) {\r\n        echo \'success:\'.$res_last;\r\n    } else {\r\n        echo \'Fail:\'.$res_last;\r\n    }\r\n} else {\r\n    echo \'All Finished!\';\r\n}\r\n```\r\n\r\n4）定时脚本good.sh\r\n```shell\r\n#!/bin/bash\r\n \r\ndate \"+%G-%m-%d %H:$M:S\"\r\ncd /home/path/to/queue_demo/\r\nphp goods.php\r\n```\r\n\r\n5）设置corntab定时任务\r\n设定为每一分钟执行goods.sh一次并记录到log.log中：\r\n`*/1 * * * * /home/path/to/queue_demo/goods.sh >> /home/path/to/queue_demo/log.log 2>&1`\r\n\r\n创建log文件：\r\n`touch /home/path/to/queue_demo/log.log`\r\n\r\n6）运行，测试\r\n调用order.php接收用户的订单信息；查看mysql表中是否插入数据；\r\n\r\n定时任务已执行，查看数据status是否改变；\r\n\r\n进行测试时，实时查看log文件：`tail -f log.log`\r\n\r\n## 2.2 流量削峰案例：通过 Redis 的 List 类型实现秒杀\r\n### 2.2.1 了解 Redis 的 list 类型数据\r\nRedis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。一个列表最多可以包含 4294967295 个元素 (每个列表超过40亿个元素)。\r\n\r\n常用命令：\r\n- LPUSH/LPUSHX：将值插入到（/存在的）列表头部\r\n- RPUSH/RPUSHX：将值插入到（/存在的）列表尾部\r\n- LPOP：移出并获取列表的第一个元素\r\n- RPOP：移出并获取列表的最后一个元素\r\n- LTRIM：保留指定区间内的元素\r\n- LLEN：获取列表长度\r\n- LSET：通过索引设置列表元素的值\r\n- LINDEX：通过索引获取列表中的元素\r\n- LRANGE：获取列表指定范围的元素\r\n\r\n### 2.2.2 案例架构\r\n![秒杀案例架构设计](https://www.goozp.com/uploads/2018/01/%E7%A7%92%E6%9D%80%E6%A1%88%E4%BE%8B%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1.png \"秒杀案例架构设计\")\r\n\r\n### 2.2.3 代码设计\r\n- 秒杀程序把请求写入Redis。（Uid，time_stamp）\r\n- 检查Redis已存放数据的长度，超出上限直接丢弃。（比如秒杀限制为100个，超过100个的数据直接丢弃返回秒杀已结束）\r\n- 死循环处理存入Redis的数据库并入库。\r\n\r\n### 2.2.4 开发流程\r\n1）创建一个示例MySQL秒杀表：\r\n```sql\r\nCREATE TABLE `redis_queue`(\r\n    `id` int(10) unsigned NOT NULL AUTO_INCREMENT,\r\n    `uid` int(11) NOT NULL DEFAULT `0`,\r\n    `time_stamp` varchar(24) NOT NULL,\r\n    PRIMARY KEY(`id`)\r\n)ENGINE=InnoDB DEFAULT CHARSET=utf8;\r\n```\r\n\r\n2）接收用户请求的user.php\r\n```php\r\n<?php\r\n// 加载redis组件\r\n$redis = new Redis();\r\n$redis -> connect(\'127.0.0.1\', 6379);\r\n$redis_name = \'miaosha\';\r\n \r\n// 接收用户的id\r\n$uid = $_GET[\'uid\'];\r\n// 获取一下redis里面已有的数量\r\n$num = $redis->lLen($redis_name);\r\n// 如果当天人数少于10的时候,则加入这个队列\r\nif ($num < 10) {\r\n    $redis->rPush($redis_name, $uid.\'%\'.microtime());\r\n    echo $uid.\'秒杀成功\';\r\n} else{\r\n    // 如果当天人数已经达到了10个人,则返回秒杀已完成\r\n    echo \'秒杀已结束\';\r\n}\r\n \r\n$redis->close();\r\n```\r\n\r\n3）处理队列的入库程序\r\n```php\r\n<?php\r\ninclude \'../include/db.php\';\r\n \r\n// 加载redis组件\r\n$redis = new Redis();\r\n$redis -> connect(\'127.0.0.1\', 6379);\r\n$redis_name = \'miaosha\';\r\n$db= DB::getIntance();\r\n \r\n// 死循环\r\nwhile (1) {\r\n    // 从队列最左取出一个值来\r\n    $user = $redis->lPop($redis_name);\r\n    // 然后判断这个值是否存在\r\n    if (!$user || $user==\'nil\') {\r\n        sleep(2);\r\n        continue;\r\n    }\r\n    // 切割出时间\r\n    $user_arr = explode(\'%\', $user);\r\n    $insert_data = array(\r\n        \'uid\' => $user_arr[0],\r\n        \'time_stamp\' => $user_arr[1], \r\n        );\r\n    // 保存到数据库中\r\n    $res = $db->insert(\'redis_queue\', $insert_data);\r\n    // 数据库插入失败的时候的回滚机制\r\n    if (!$res) {\r\n        $redis->rPush($redis_name, $user);\r\n    }\r\n    sleep(2);\r\n}\r\n//释放redis\r\n$redis -> close();\r\n```\r\n\r\n# 3. 其它消息系统\r\n## 3.1 RabbitMQ\r\n### 3.1.1 关于RabbitMQ\r\n官网：[RabbitMQ](http://www.rabbitmq.com/ \"RabbitMQ\")\r\n文档：[RabbitMQ Documentation](http://www.rabbitmq.com/documentation.html \"RabbitMQ Documentation\")\r\n\r\n### 3.1.2 RabbitMQ架构和原理\r\nRabbitMQ完整的实现了AMQP、集群简化、持久化、跨平台。\r\n![RabbitMQ架构和原理](https://www.goozp.com/uploads/2018/01/RabbitMQ%E6%9E%B6%E6%9E%84%E5%92%8C%E5%8E%9F%E7%90%86.png \"RabbitMQ架构和原理\")\r\n\r\n### 3.1.3 RabbitMQ使用\r\n1. 安装RabbitMQ（rabbitmq-server、php-amqplib）\r\n2. 生产者向消息通道发送消息\r\n3. 消费者处理消息\r\n\r\n### 3.1.4 工作队列模式\r\n![RabbitMQ_work_queues](https://www.goozp.com/uploads/2018/01/RabbitMQ_work_queues.png \"RabbitMQ_work_queues\")\r\n更多模式参考：[http://previous.rabbitmq.com/v3_5_7/getstarted.html](http://previous.rabbitmq.com/v3_5_7/getstarted.html \"http://previous.rabbitmq.com/v3_5_7/getstarted.html\")', '<blockquote>\r\n<p>本文总结自慕课网的一个教程：<a href=\"http://www.imooc.com/learn/852\" title=\"PHP消息队列实现及应用\">PHP消息队列实现及应用</a>；这个教程非常适合新手刚接触消息队列，我觉得蛮不错。</p>\r\n</blockquote>\r\n<h1 id=\"h1-1-\"><a name=\"1. 关于消息队列\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1. 关于消息队列</h1><h2 id=\"h2-1-1-\"><a name=\"1.1 基础模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.1 基础模式</h2><p>一个基础的消息队列应该是这样的：<br><img src=\"https://www.goozp.com/uploads/2018/01/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.png\" alt=\"消息队列\" title=\"消息队列\"></p>\r\n<h2 id=\"h2-1-2-\"><a name=\"1.2 应用场景\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.2 应用场景</h2><p>消息队列的应用场景大概可以是以下几种：</p>\r\n<ul>\r\n<li>冗余；</li><li>解耦（比如业务系统和队列处理系统一方奔溃不会影响另一方）；</li><li>流量削峰（抢购，秒杀等场景）；</li><li>异步通信；</li><li>拓展性；</li><li>排序保证（比如做成单进程单线程单进单出）；</li></ul>\r\n<h2 id=\"h2-1-3-\"><a name=\"1.3 队列介质\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.3 队列介质</h2><p>实现消息队列的方式有很多，这里介绍三种模式的实现：</p>\r\n<p>Mysql：可靠性高、易实现，速度慢</p>\r\n<p>Redis：速度快，单条大消息包时效率低</p>\r\n<p>消息系统：专业性强，可靠，学习成本高（RabbitMQ）</p>\r\n<h2 id=\"h2-1-4-\"><a name=\"1.4 消息处理触发机制\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.4 消息处理触发机制</h2><p><strong>死循环方式读取</strong>：易实现，故障时无法及时恢复（适合比如秒杀系统）</p>\r\n<p><strong>定时任务</strong>：压分均分，有处理上限（要控制好进程，防止上一个任务还没完成就开始了下一个）</p>\r\n<p><strong>守护进程</strong>：类似于PHP-FPM和PHP-CG，需要shell基础</p>\r\n<h1 id=\"h1-2-\"><a name=\"2. 案例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2. 案例</h1><h2 id=\"h2-2-1-mysql-\"><a name=\"2.1 解耦案例：处理订单系统和配送系统（Mysql实现）\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.1 解耦案例：处理订单系统和配送系统（Mysql实现）</h2><h3 id=\"h3-2-1-1-\"><a name=\"2.1.1 案例架构\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.1.1 案例架构</h3><p>订单系统和配送系统是解耦的，通过MySQL队列表做队列：<br><img src=\"https://www.goozp.com/uploads/2018/01/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E8%A7%A3%E8%80%A6%E6%A1%88%E4%BE%8B.png\" alt=\"消息队列解耦案例\" title=\"消息队列解耦案例\"></p>\r\n<h3 id=\"h3-2-1-2-\"><a name=\"2.1.2 案例流程\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.1.2 案例流程</h3><p>程序的大概流程：<br><img src=\"https://www.goozp.com/uploads/2018/01/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E8%A7%A3%E8%80%A6%E6%A1%88%E4%BE%8B%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B.png\" alt=\" 消息队列解耦案例程序流程\" title=\" 消息队列解耦案例程序流程\"></p>\r\n<h3 id=\"h3-2-1-3-\"><a name=\"2.1.3 开发流程\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.1.3 开发流程</h3><p>1）创建一个示例MySQL队列表：</p>\r\n<pre><code class=\"lang-sql\">CREATE TABLE `order_queue`(\r\n    `id` int(11) unsigned NOT NULL AUTO_INCREMENT COMMENT `id号`,\r\n    `order_id` int(11) NOT NULL,\r\n    `mobile` varchar(20) NOT NULL COMMENT `用户的手机号`,\r\n    `address` varchar(100) NOT NULL COMMENT `用户的地址`,\r\n    `created_at` datetime NOT NULL DEFAULT `0000-00-00 00:00:00` COMMENT `订单创建时间`,\r\n    `updated_at` datetime NOT NULL DEFAULT `0000-00-00 00:00:00` COMMENT `处理完成时间`,\r\n    `status` tinyint(2) NOT NULL COMMENT `当前状态, 0未处理, 1已处理, 2处理中`,\r\n    PRIMARY KEY(`id`)\r\n)ENGINE=InnoDB DEFAULT CHARSET=utf8;\r\n</code></pre>\r\n<p>2）接受用户订单order.php:</p>\r\n<pre><code class=\"lang-php\">&lt;?php\r\ninclude &#39;../include/db.php&#39;; //引入一个DB类用来操作数据库\r\n\r\nif (!empty($_GET[&#39;mobile&#39;])) {\r\n    // 订单处理流程\r\n    // ......\r\n    // 过滤从用户获取的数据\r\n\r\n    $order_id = rand (10000, 99999); // 示例生成订单\r\n    // 要插入的数据\r\n    $insert_data = array(\r\n        &#39;order_id&#39; =&gt; $order_id,\r\n        &#39;mobile&#39;   =&gt; $_GET[&#39;mobile&#39;],\r\n        &#39;created_time&#39; =&gt; date(&#39;Y-m-d H:i:s&#39;, time()),\r\n        &#39;status&#39; =&gt; 0\r\n    );\r\n\r\n    // 插入数据\r\n    $db = DB::getIntance();\r\n    $res = $db -&gt; insert(&#39;order_queue&#39;, $insert_data);\r\n    if ($res) {\r\n        echo $insert_data[&#39;order_id&#39;].&quot;保存成功&quot;;\r\n    } else {\r\n        echo &#39;保存失败&#39;;\r\n    }\r\n}\r\n</code></pre>\r\n<p>3）配送处理goods.php</p>\r\n<pre><code class=\"lang-php\">&lt;?php\r\n// 配送系统处理队列中的订单并进行标记的一个文件\r\ninclude &#39;../include/db.php&#39;; //引入一个DB类用来操作数据库\r\n\r\n$db = DB::getIntance();\r\n// 1. 先把要处理的记录更新为等待处理; 这一步是为了实现一个锁的机制,防止其它程序操作数据冲突\r\n$waiting = array(&#39;status&#39; =&gt; 0);\r\n$lock = array(&#39;status&#39; =&gt; 2);\r\n$res_lock = $db-&gt;update(&#39;order_queue&#39;, $lock, $waiting, 2);\r\n\r\n// 2. 选择出刚刚更新的这些数据, 然后进行配送系统的处理\r\nif ($res_lock) {\r\n    $res = $db-&gt;selectAll(&#39;order_queue&#39;, $lock);\r\n\r\n    // 然后由配送系统进行处理\r\n    // ......\r\n\r\n    // 3. 把这些处理过的程序更新为已完成\r\n    $success = array(\r\n        &#39;status&#39; =&gt; 1,\r\n        &#39;update_time&#39; =&gt; date(&#39;Y-m-d H:i:s&#39;),\r\n    );\r\n    $res_last = $db-&gt;update(&#39;order_queue&#39;, $success, $lock);\r\n    if ($res_last) {\r\n        echo &#39;success:&#39;.$res_last;\r\n    } else {\r\n        echo &#39;Fail:&#39;.$res_last;\r\n    }\r\n} else {\r\n    echo &#39;All Finished!&#39;;\r\n}\r\n</code></pre>\r\n<p>4）定时脚本good.sh</p>\r\n<pre><code class=\"lang-shell\">#!/bin/bash\r\n\r\ndate &quot;+%G-%m-%d %H:$M:S&quot;\r\ncd /home/path/to/queue_demo/\r\nphp goods.php\r\n</code></pre>\r\n<p>5）设置corntab定时任务<br>设定为每一分钟执行goods.sh一次并记录到log.log中：<br><code>*/1 * * * * /home/path/to/queue_demo/goods.sh &gt;&gt; /home/path/to/queue_demo/log.log 2&gt;&amp;1</code></p>\r\n<p>创建log文件：<br><code>touch /home/path/to/queue_demo/log.log</code></p>\r\n<p>6）运行，测试<br>调用order.php接收用户的订单信息；查看mysql表中是否插入数据；</p>\r\n<p>定时任务已执行，查看数据status是否改变；</p>\r\n<p>进行测试时，实时查看log文件：<code>tail -f log.log</code></p>\r\n<h2 id=\"h2-2-2-redis-list-\"><a name=\"2.2 流量削峰案例：通过 Redis 的 List 类型实现秒杀\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.2 流量削峰案例：通过 Redis 的 List 类型实现秒杀</h2><h3 id=\"h3-2-2-1-redis-list-\"><a name=\"2.2.1 了解 Redis 的 list 类型数据\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.2.1 了解 Redis 的 list 类型数据</h3><p>Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。一个列表最多可以包含 4294967295 个元素 (每个列表超过40亿个元素)。</p>\r\n<p>常用命令：</p>\r\n<ul>\r\n<li>LPUSH/LPUSHX：将值插入到（/存在的）列表头部</li><li>RPUSH/RPUSHX：将值插入到（/存在的）列表尾部</li><li>LPOP：移出并获取列表的第一个元素</li><li>RPOP：移出并获取列表的最后一个元素</li><li>LTRIM：保留指定区间内的元素</li><li>LLEN：获取列表长度</li><li>LSET：通过索引设置列表元素的值</li><li>LINDEX：通过索引获取列表中的元素</li><li>LRANGE：获取列表指定范围的元素</li></ul>\r\n<h3 id=\"h3-2-2-2-\"><a name=\"2.2.2 案例架构\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.2.2 案例架构</h3><p><img src=\"https://www.goozp.com/uploads/2018/01/%E7%A7%92%E6%9D%80%E6%A1%88%E4%BE%8B%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1.png\" alt=\"秒杀案例架构设计\" title=\"秒杀案例架构设计\"></p>\r\n<h3 id=\"h3-2-2-3-\"><a name=\"2.2.3 代码设计\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.2.3 代码设计</h3><ul>\r\n<li>秒杀程序把请求写入Redis。（Uid，time_stamp）</li><li>检查Redis已存放数据的长度，超出上限直接丢弃。（比如秒杀限制为100个，超过100个的数据直接丢弃返回秒杀已结束）</li><li>死循环处理存入Redis的数据库并入库。</li></ul>\r\n<h3 id=\"h3-2-2-4-\"><a name=\"2.2.4 开发流程\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.2.4 开发流程</h3><p>1）创建一个示例MySQL秒杀表：</p>\r\n<pre><code class=\"lang-sql\">CREATE TABLE `redis_queue`(\r\n    `id` int(10) unsigned NOT NULL AUTO_INCREMENT,\r\n    `uid` int(11) NOT NULL DEFAULT `0`,\r\n    `time_stamp` varchar(24) NOT NULL,\r\n    PRIMARY KEY(`id`)\r\n)ENGINE=InnoDB DEFAULT CHARSET=utf8;\r\n</code></pre>\r\n<p>2）接收用户请求的user.php</p>\r\n<pre><code class=\"lang-php\">&lt;?php\r\n// 加载redis组件\r\n$redis = new Redis();\r\n$redis -&gt; connect(&#39;127.0.0.1&#39;, 6379);\r\n$redis_name = &#39;miaosha&#39;;\r\n\r\n// 接收用户的id\r\n$uid = $_GET[&#39;uid&#39;];\r\n// 获取一下redis里面已有的数量\r\n$num = $redis-&gt;lLen($redis_name);\r\n// 如果当天人数少于10的时候,则加入这个队列\r\nif ($num &lt; 10) {\r\n    $redis-&gt;rPush($redis_name, $uid.&#39;%&#39;.microtime());\r\n    echo $uid.&#39;秒杀成功&#39;;\r\n} else{\r\n    // 如果当天人数已经达到了10个人,则返回秒杀已完成\r\n    echo &#39;秒杀已结束&#39;;\r\n}\r\n\r\n$redis-&gt;close();\r\n</code></pre>\r\n<p>3）处理队列的入库程序</p>\r\n<pre><code class=\"lang-php\">&lt;?php\r\ninclude &#39;../include/db.php&#39;;\r\n\r\n// 加载redis组件\r\n$redis = new Redis();\r\n$redis -&gt; connect(&#39;127.0.0.1&#39;, 6379);\r\n$redis_name = &#39;miaosha&#39;;\r\n$db= DB::getIntance();\r\n\r\n// 死循环\r\nwhile (1) {\r\n    // 从队列最左取出一个值来\r\n    $user = $redis-&gt;lPop($redis_name);\r\n    // 然后判断这个值是否存在\r\n    if (!$user || $user==&#39;nil&#39;) {\r\n        sleep(2);\r\n        continue;\r\n    }\r\n    // 切割出时间\r\n    $user_arr = explode(&#39;%&#39;, $user);\r\n    $insert_data = array(\r\n        &#39;uid&#39; =&gt; $user_arr[0],\r\n        &#39;time_stamp&#39; =&gt; $user_arr[1], \r\n        );\r\n    // 保存到数据库中\r\n    $res = $db-&gt;insert(&#39;redis_queue&#39;, $insert_data);\r\n    // 数据库插入失败的时候的回滚机制\r\n    if (!$res) {\r\n        $redis-&gt;rPush($redis_name, $user);\r\n    }\r\n    sleep(2);\r\n}\r\n//释放redis\r\n$redis -&gt; close();\r\n</code></pre>\r\n<h1 id=\"h1-3-\"><a name=\"3. 其它消息系统\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3. 其它消息系统</h1><h2 id=\"h2-3-1-rabbitmq\"><a name=\"3.1 RabbitMQ\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.1 RabbitMQ</h2><h3 id=\"h3-3-1-1-rabbitmq\"><a name=\"3.1.1 关于RabbitMQ\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.1.1 关于RabbitMQ</h3><p>官网：<a href=\"http://www.rabbitmq.com/\" title=\"RabbitMQ\">RabbitMQ</a><br>文档：<a href=\"http://www.rabbitmq.com/documentation.html\" title=\"RabbitMQ Documentation\">RabbitMQ Documentation</a></p>\r\n<h3 id=\"h3-3-1-2-rabbitmq-\"><a name=\"3.1.2 RabbitMQ架构和原理\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.1.2 RabbitMQ架构和原理</h3><p>RabbitMQ完整的实现了AMQP、集群简化、持久化、跨平台。<br><img src=\"https://www.goozp.com/uploads/2018/01/RabbitMQ%E6%9E%B6%E6%9E%84%E5%92%8C%E5%8E%9F%E7%90%86.png\" alt=\"RabbitMQ架构和原理\" title=\"RabbitMQ架构和原理\"></p>\r\n<h3 id=\"h3-3-1-3-rabbitmq-\"><a name=\"3.1.3 RabbitMQ使用\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.1.3 RabbitMQ使用</h3><ol>\r\n<li>安装RabbitMQ（rabbitmq-server、php-amqplib）</li><li>生产者向消息通道发送消息</li><li>消费者处理消息</li></ol>\r\n<h3 id=\"h3-3-1-4-\"><a name=\"3.1.4 工作队列模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.1.4 工作队列模式</h3><p><img src=\"https://www.goozp.com/uploads/2018/01/RabbitMQ_work_queues.png\" alt=\"RabbitMQ_work_queues\" title=\"RabbitMQ_work_queues\"><br>更多模式参考：<a href=\"http://previous.rabbitmq.com/v3_5_7/getstarted.html\" title=\"http://previous.rabbitmq.com/v3_5_7/getstarted.html\">http://previous.rabbitmq.com/v3_5_7/getstarted.html</a></p>\r\n', '', 0, 'publish', 1, 0, '/article/9.html', '', 0, 141, '2017-07-18 03:48:13', '2017-07-18 03:48:13', '2018-01-05 09:52:56', NULL);
INSERT INTO `pt_post` VALUES (10, 10, 'article', '建中路剿鼠记（一）', '终于！终于！换宿舍啦！终于不用挤在一间8人间里只有一个床位啦！高兴得一塌糊涂，虽然经济瞬间紧张了，但是可以自己一个人住一个小房子，感觉还是非常不错，更何况家具该有的都有。\r\n\r\n然而事情远远没有如此简单！\r\n\r\n刚搬进来就发现，地上好多一粒粒的黑颗粒！蟑螂屎？还是老鼠屎？感觉应该是老鼠屎，嗯，一开始，就是这么觉得的。也就没当回事，毕竟，大扫除之后，感觉还是蛮舒服的。而且重点是，楼下，很多！吃的！\r\n\r\n当晚就吃了个鸡腿排，啧啧，然后吃完鸡腿骨完事扔垃圾桶。\r\n\r\n第二天，wtf？这什么鬼？\r\n![](https://www.goozp.com/uploads/2018/01/1763035875.jpg)\r\n\r\n这掉到外面是什么鬼?不以为意,扔回垃圾桶！\r\n\r\n然而，神奇的是,下一次又出现在了那个位置！那个位置！突然心里一阵凉意，只能安慰自己那是老鼠搞的！\r\n\r\n因为房子没有窗户，只有厕所有一个小窗，所有平时白天灯一关，也是乌漆吗黑。\r\n\r\n好的，周末留了几包薯片在桌子上，周一上班啦！然而，当我回到家里时，我的内心是奔溃的。\r\n![](https://www.goozp.com/uploads/2018/01/3115824438.jpg)\r\n\r\n![](https://www.goozp.com/uploads/2018/01/2595756476.jpg)\r\n\r\n这。。。。。简直，感觉和一窝老鼠住在一块啊。\r\n\r\n咦，这是什么？\r\n![](https://www.goozp.com/uploads/2018/01/2760593199.jpg)\r\n看起来是试图进攻可比克未遂？可比克这包装，够硬。\r\n![](https://www.goozp.com/uploads/2018/01/2152528169.jpg)\r\n\r\n然而我瞅了一眼整个房间，感觉可能有老鼠出来的地方就是这里了。\r\n![](https://www.goozp.com/uploads/2018/01/2593195352.jpg)\r\n\r\n\r\n啥也别说了，来来来！准备大战300回合！\r\n![](https://www.goozp.com/uploads/2018/01/1474477264.png)\r\n![](https://www.goozp.com/uploads/2018/01/1269685963_576x1024.png)', '<p>终于！终于！换宿舍啦！终于不用挤在一间8人间里只有一个床位啦！高兴得一塌糊涂，虽然经济瞬间紧张了，但是可以自己一个人住一个小房子，感觉还是非常不错，更何况家具该有的都有。</p>\r\n<p>然而事情远远没有如此简单！</p>\r\n<p>刚搬进来就发现，地上好多一粒粒的黑颗粒！蟑螂屎？还是老鼠屎？感觉应该是老鼠屎，嗯，一开始，就是这么觉得的。也就没当回事，毕竟，大扫除之后，感觉还是蛮舒服的。而且重点是，楼下，很多！吃的！</p>\r\n<p>当晚就吃了个鸡腿排，啧啧，然后吃完鸡腿骨完事扔垃圾桶。</p>\r\n<p>第二天，wtf？这什么鬼？<br><img src=\"https://www.goozp.com/uploads/2018/01/1763035875.jpg\" alt=\"\"></p>\r\n<p>这掉到外面是什么鬼?不以为意,扔回垃圾桶！</p>\r\n<p>然而，神奇的是,下一次又出现在了那个位置！那个位置！突然心里一阵凉意，只能安慰自己那是老鼠搞的！</p>\r\n<p>因为房子没有窗户，只有厕所有一个小窗，所有平时白天灯一关，也是乌漆吗黑。</p>\r\n<p>好的，周末留了几包薯片在桌子上，周一上班啦！然而，当我回到家里时，我的内心是奔溃的。<br><img src=\"https://www.goozp.com/uploads/2018/01/3115824438.jpg\" alt=\"\"></p>\r\n<p><img src=\"https://www.goozp.com/uploads/2018/01/2595756476.jpg\" alt=\"\"></p>\r\n<p>这。。。。。简直，感觉和一窝老鼠住在一块啊。</p>\r\n<p>咦，这是什么？<br><img src=\"https://www.goozp.com/uploads/2018/01/2760593199.jpg\" alt=\"\"><br>看起来是试图进攻可比克未遂？可比克这包装，够硬。<br><img src=\"https://www.goozp.com/uploads/2018/01/2152528169.jpg\" alt=\"\"></p>\r\n<p>然而我瞅了一眼整个房间，感觉可能有老鼠出来的地方就是这里了。<br><img src=\"https://www.goozp.com/uploads/2018/01/2593195352.jpg\" alt=\"\"></p>\r\n<p>啥也别说了，来来来！准备大战300回合！<br><img src=\"https://www.goozp.com/uploads/2018/01/1474477264.png\" alt=\"\"><br><img src=\"https://www.goozp.com/uploads/2018/01/1269685963_576x1024.png\" alt=\"\"></p>\r\n', '', 0, 'publish', 1, 0, '/article/10.html', '', 0, 123, '2016-03-29 15:48:02', '2016-03-29 15:48:02', '2018-01-07 18:41:25', NULL);
INSERT INTO `pt_post` VALUES (11, 10, 'article', '微信公众平台开发——准备开发和接口接入', '最近开始搞一下微信公众平台开发，感觉应该蛮有意思的，看起来也不难。\r\n# 1.注册微信公众平台账号\r\n官网：[https://mp.weixin.qq.com/](https://mp.weixin.qq.com/ \"https://mp.weixin.qq.com/\")\r\n注册什么的就不用说了，按步骤来就行了。\r\n\r\n# 2. 准备服务器\r\n准备服务器资源，百度BAE新浪ACE什么的也都可以的,作为例子这里使用PHP环境+MySQL数据库作为程序运行环境.\r\n\r\n# 3. 上传接口文件\r\n微信开发者文档里就有php代码例子下载，如下：\r\n```php\r\n<?php\r\n/* 微信接口文件 */\r\n//define your token\r\ndefine(\"TOKEN\", \"weixin\");\r\n$wechatObj = new wechatCallbackapiTest();\r\n$wechatObj->valid();\r\n\r\nclass wechatCallbackapiTest\r\n{\r\n    public function valid()\r\n    {\r\n        $echoStr = $_GET[\"echostr\"];\r\n        //valid signature , option\r\n        if($this->checkSignature())\r\n        {\r\n            echo $echoStr;\r\n            exit;\r\n        }\r\n    }\r\n\r\n    public function responseMsg()\r\n    {\r\n        //get post data, May be due to the different environments\r\n        $postStr = $GLOBALS[\"HTTP_RAW_POST_DATA\"];\r\n\r\n        //extract post data\r\n        if (!empty($postStr)){\r\n            /* libxml_disable_entity_loader is to prevent XML eXternal Entity Injection,\r\n               the best way is to check the validity of xml by yourself */\r\n            libxml_disable_entity_loader(true);\r\n            $postObj = simplexml_load_string($postStr, \'SimpleXMLElement\', LIBXML_NOCDATA);\r\n            $fromUsername = $postObj->FromUserName;\r\n            $toUsername = $postObj->ToUserName;\r\n            $keyword = trim($postObj->Content);\r\n            $time = time();\r\n            $textTpl = \"<xml>\r\n <ToUserName><![CDATA[%s]]></ToUserName>\r\n <FromUserName><![CDATA[%s]]></FromUserName>\r\n <CreateTime>%s</CreateTime>\r\n <MsgType><![CDATA[%s]]></MsgType>\r\n <Content><![CDATA[%s]]></Content>\r\n <FuncFlag>0</FuncFlag>\r\n </xml>\";\r\n            if(!empty( $keyword ))\r\n            {\r\n                $msgType = \"text\";\r\n                $contentStr = \"Welcome to wechat world!\";\r\n                $resultStr = sprintf($textTpl, $fromUsername, $toUsername, $time, $msgType, $contentStr);\r\n                echo $resultStr;\r\n            }else{\r\n                echo \"Input something...\";\r\n            }\r\n\r\n        }else {\r\n            echo \"\";\r\n            exit;\r\n        }\r\n    }\r\n\r\n    private function checkSignature()\r\n    {\r\n        // you must define TOKEN by yourself\r\n        if (!defined(\"TOKEN\")) {\r\n            throw new Exception(\'TOKEN is not defined!\');\r\n        }\r\n\r\n        $signature = $_GET[\"signature\"];\r\n        $timestamp = $_GET[\"timestamp\"];\r\n        $nonce = $_GET[\"nonce\"];\r\n\r\n        $token = TOKEN;\r\n        $tmpArr = array($token, $timestamp, $nonce);\r\n        // use SORT_STRING rule\r\n        sort($tmpArr, SORT_STRING);\r\n        $tmpStr = implode( $tmpArr );\r\n        $tmpStr = sha1( $tmpStr );\r\n\r\n        if( $tmpStr == $signature ){\r\n            return true;\r\n        }else{\r\n            return false;\r\n        }\r\n    }\r\n}\r\n```\r\n创建一个php文件，命名为wechat_gz.php，将以上代码内容写入，上传到根目录下，需要注意的是define(“TOKEN”, “weixin”)；这里的token要记住。\r\n\r\n# 4. 设置服务器配置\r\n![](https://www.goozp.com/uploads/2018/01/1946475855.png)\r\n\r\n在公众平台后台开发选项的基本配置中有一些服务器配置选项如图所示：\r\n![](https://www.goozp.com/uploads/2018/01/31446533.png)\r\n\r\nURL处填写刚才上传的文件的url地址；token写文件中定义的TOKEN值，这里是weixin；EncodingAESKey是随机生成的密匙，点生成就好，确定后提交！\r\n\r\n在服务器配置页面启用，弹出启用成功，开发模式就已经启用成功了。\r\n', '<p>最近开始搞一下微信公众平台开发，感觉应该蛮有意思的，看起来也不难。</p>\r\n<h1 id=\"h1-1-\"><a name=\"1.注册微信公众平台账号\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.注册微信公众平台账号</h1><p>官网：<a href=\"https://mp.weixin.qq.com/\" title=\"https://mp.weixin.qq.com/\">https://mp.weixin.qq.com/</a><br>注册什么的就不用说了，按步骤来就行了。</p>\r\n<h1 id=\"h1-2-\"><a name=\"2. 准备服务器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2. 准备服务器</h1><p>准备服务器资源，百度BAE新浪ACE什么的也都可以的,作为例子这里使用PHP环境+MySQL数据库作为程序运行环境.</p>\r\n<h1 id=\"h1-3-\"><a name=\"3. 上传接口文件\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3. 上传接口文件</h1><p>微信开发者文档里就有php代码例子下载，如下：</p>\r\n<pre><code class=\"lang-php\">&lt;?php\r\n/* 微信接口文件 */\r\n//define your token\r\ndefine(&quot;TOKEN&quot;, &quot;weixin&quot;);\r\n$wechatObj = new wechatCallbackapiTest();\r\n$wechatObj-&gt;valid();\r\n\r\nclass wechatCallbackapiTest\r\n{\r\n    public function valid()\r\n    {\r\n        $echoStr = $_GET[&quot;echostr&quot;];\r\n        //valid signature , option\r\n        if($this-&gt;checkSignature())\r\n        {\r\n            echo $echoStr;\r\n            exit;\r\n        }\r\n    }\r\n\r\n    public function responseMsg()\r\n    {\r\n        //get post data, May be due to the different environments\r\n        $postStr = $GLOBALS[&quot;HTTP_RAW_POST_DATA&quot;];\r\n\r\n        //extract post data\r\n        if (!empty($postStr)){\r\n            /* libxml_disable_entity_loader is to prevent XML eXternal Entity Injection,\r\n               the best way is to check the validity of xml by yourself */\r\n            libxml_disable_entity_loader(true);\r\n            $postObj = simplexml_load_string($postStr, &#39;SimpleXMLElement&#39;, LIBXML_NOCDATA);\r\n            $fromUsername = $postObj-&gt;FromUserName;\r\n            $toUsername = $postObj-&gt;ToUserName;\r\n            $keyword = trim($postObj-&gt;Content);\r\n            $time = time();\r\n            $textTpl = &quot;&lt;xml&gt;\r\n &lt;ToUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/ToUserName&gt;\r\n &lt;FromUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/FromUserName&gt;\r\n &lt;CreateTime&gt;%s&lt;/CreateTime&gt;\r\n &lt;MsgType&gt;&lt;![CDATA[%s]]&gt;&lt;/MsgType&gt;\r\n &lt;Content&gt;&lt;![CDATA[%s]]&gt;&lt;/Content&gt;\r\n &lt;FuncFlag&gt;0&lt;/FuncFlag&gt;\r\n &lt;/xml&gt;&quot;;\r\n            if(!empty( $keyword ))\r\n            {\r\n                $msgType = &quot;text&quot;;\r\n                $contentStr = &quot;Welcome to wechat world!&quot;;\r\n                $resultStr = sprintf($textTpl, $fromUsername, $toUsername, $time, $msgType, $contentStr);\r\n                echo $resultStr;\r\n            }else{\r\n                echo &quot;Input something...&quot;;\r\n            }\r\n\r\n        }else {\r\n            echo &quot;&quot;;\r\n            exit;\r\n        }\r\n    }\r\n\r\n    private function checkSignature()\r\n    {\r\n        // you must define TOKEN by yourself\r\n        if (!defined(&quot;TOKEN&quot;)) {\r\n            throw new Exception(&#39;TOKEN is not defined!&#39;);\r\n        }\r\n\r\n        $signature = $_GET[&quot;signature&quot;];\r\n        $timestamp = $_GET[&quot;timestamp&quot;];\r\n        $nonce = $_GET[&quot;nonce&quot;];\r\n\r\n        $token = TOKEN;\r\n        $tmpArr = array($token, $timestamp, $nonce);\r\n        // use SORT_STRING rule\r\n        sort($tmpArr, SORT_STRING);\r\n        $tmpStr = implode( $tmpArr );\r\n        $tmpStr = sha1( $tmpStr );\r\n\r\n        if( $tmpStr == $signature ){\r\n            return true;\r\n        }else{\r\n            return false;\r\n        }\r\n    }\r\n}\r\n</code></pre>\r\n<p>创建一个php文件，命名为wechat_gz.php，将以上代码内容写入，上传到根目录下，需要注意的是define(“TOKEN”, “weixin”)；这里的token要记住。</p>\r\n<h1 id=\"h1-4-\"><a name=\"4. 设置服务器配置\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4. 设置服务器配置</h1><p><img src=\"https://www.goozp.com/uploads/2018/01/1946475855.png\" alt=\"\"></p>\r\n<p>在公众平台后台开发选项的基本配置中有一些服务器配置选项如图所示：<br><img src=\"https://www.goozp.com/uploads/2018/01/31446533.png\" alt=\"\"></p>\r\n<p>URL处填写刚才上传的文件的url地址；token写文件中定义的TOKEN值，这里是weixin；EncodingAESKey是随机生成的密匙，点生成就好，确定后提交！</p>\r\n<p>在服务器配置页面启用，弹出启用成功，开发模式就已经启用成功了。</p>\r\n', '', 0, 'publish', 1, 0, '/article/11.html', '', 0, 104, '2016-03-16 13:23:59', '2016-03-16 13:23:59', '2018-01-07 18:54:36', NULL);
INSERT INTO `pt_post` VALUES (12, 10, 'article', '微信公众平台开发——消息回复', '# 1. 前提\r\n微信接口接上之后我们就可以开始开发功能了，微信接口接入可参考：[微信公众平台开发——准备开发和接口接入](https://www.goozp.com/article/11.html \"微信公众平台开发——准备开发和接口接入\")\r\n\r\n# 2. 注意\r\n需要注意的是$wechatObj->valid()和$wechatObj->responseMsg(),valid是用来调试时验证接口用的,在接入后我们就不需要用到了,可以注释掉,然后调用$wechatObj->responseMsg()来实现功能.\r\n\r\n# 3. 实现\r\n这里实现公众号关注自动回复和普通消息回复作为例子.\r\n```php\r\n<?php\r\n/* 微信接口文件*/\r\n//define your token\r\ndefine(\"TOKEN\", \"wechatgzp\");\r\n$wechatObj = new wechatCallbackapiTest(); //实例化封装类\r\n//$wechatObj->valid(); //注释掉这里\r\n$wechatObj->responseMsg(); //这里调用回复功能封装的函数\r\n\r\nclass wechatCallbackapiTest\r\n{\r\n    public function valid()\r\n    {\r\n        $echoStr = $_GET[\"echostr\"];\r\n\r\n        //valid signature , option\r\n        if($this->checkSignature()){\r\n            echo $echoStr;\r\n            exit;\r\n        }\r\n    }\r\n\r\n    public function responseMsg()\r\n    {\r\n        //get post data, May be due to the different environments\r\n        $postStr = $GLOBALS[\"HTTP_RAW_POST_DATA\"];\r\n\r\n        //extract post data\r\n        if (!empty($postStr)){\r\n            /* libxml_disable_entity_loader is to prevent XML eXternal Entity Injection,\r\n               the best way is to check the validity of xml by yourself */\r\n            libxml_disable_entity_loader(true);\r\n            $postObj = simplexml_load_string($postStr, \'SimpleXMLElement\', LIBXML_NOCDATA);\r\n            $fromUsername = $postObj->FromUserName;\r\n            $toUsername = $postObj->ToUserName;\r\n            $keyword = trim($postObj->Content);\r\n            $time = time();\r\n            $textTpl = \"<xml>\r\n <ToUserName><![CDATA[%s]]></ToUserName>\r\n <FromUserName><![CDATA[%s]]></FromUserName>\r\n <CreateTime>%s</CreateTime>\r\n <MsgType><![CDATA[%s]]></MsgType>\r\n <Content><![CDATA[%s]]></Content>\r\n <FuncFlag>0</FuncFlag>\r\n </xml>\";\r\n\r\n            //加载图文模版\r\n            $picTpl = \"<xml>\r\n <ToUserName><![CDATA[%s]]></ToUserName>\r\n <FromUserName><![CDATA[%s]]></FromUserName>\r\n <CreateTime>%s</CreateTime>\r\n <MsgType><![CDATA[%s]]></MsgType>\r\n <ArticleCount>1</ArticleCount>\r\n <Articles>\r\n <item>\r\n <Title><![CDATA[%s]]></Title>\r\n <Description><![CDATA[%s]]></Description>\r\n <PicUrl><![CDATA[%s]]></PicUrl>\r\n <Url><![CDATA[%s]]></Url>\r\n </item>\r\n </Articles>\r\n <FuncFlag>1</FuncFlag>\r\n </xml> \";\r\n\r\n            //用户输入内容了\r\n            if(!empty( $keyword ))\r\n            {\r\n                $msgType = \"text\";\r\n                $contentStr = \"欢迎关注!更多内容,敬请期待!\";\r\n                $resultStr = sprintf($textTpl, $fromUsername, $toUsername, $time, $msgType, $contentStr);\r\n                echo $resultStr;\r\n            }\r\n\r\n            //判断是否是新关注\r\n            elseif(trim($postObj->MsgType) == \"event\" and trim($postObj->Event) == \"subscribe\")\r\n            {\r\n                $msgType = \"news\";\r\n                $title = \"大兄弟别跑听锅锅说话\"; //标题\r\n                $data  = date(\'Y-m-d\'); //时间\r\n                $desription = \"感谢您关注【大兄弟别跑听锅锅说话】\".\"\\n\".\"微信号：gzpblog\".\"\\n\".\"博客网址:http://www.gzpblog.com\".\"\\n\".\"更多内容,敬请期待!\"; //简介\r\n                $image = \"http://www.gzpblog.com/usr/uploads/shuta.jpg\"; //图片地址\r\n                $turl = \"http://www.gzpblog.com\"; //链接地址\r\n                $resultStr = sprintf($picTpl, $fromUsername, $toUsername, $time, $msgType, $title,$desription,$image,$turl);\r\n                echo $resultStr;\r\n            }\r\n        }\r\n        else\r\n        {\r\n            echo \"\";\r\n            exit;\r\n        }\r\n    }\r\n}\r\n```\r\n在这里我们用了两种回复格式，关注时自动回复用的是带图片的新闻模式，而普通消息回复则是纯文字。判断关注使用事件来判断，而普通消息回复判断其keyword，各消息类型的推送XML数据包结构在开发者文档中列出来，这里就不列了，给个地址:http://mp.weixin.qq.com/wiki/17/f298879f8fb29ab98b2f2971d42552fd.html\r\n\r\n以我自己的公众号为例,实现的效果如下：\r\n![](https://www.goozp.com/uploads/2018/01/2705660894.png)\r\n实际上，这只是其中的一个简单小功能，然后我们会发现，个人公众号，不能通过认证，能调用的接口权限很少，只能实现一些简单功能，具体权限也可以在官方文档中找到。而且，连自定义菜单这种功能，个人公众号都无法调用接口，实在蛋疼得很。（后续补充：个人公众号可以自定义菜单了）\r\n\r\n当然，还是有一些功能挺有意思的等待去发掘，将微信服务器和博客的共用可能可以打造出一些有意思的效果，不过不知道能不能实现，现在只是想想，以后有时间研究研究。\r\n\r\n# 4. 后续更新（2017年~）\r\n微信公众号已经可以在后台直接设置自动回复了，个人公众号也可以自定义菜单了，逐渐放开了。所以本文仅供参考了。\r\n', '<h1 id=\"h1-1-\"><a name=\"1. 前提\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1. 前提</h1><p>微信接口接上之后我们就可以开始开发功能了，微信接口接入可参考：<a href=\"https://www.goozp.com/article/11.html\" title=\"微信公众平台开发——准备开发和接口接入\">微信公众平台开发——准备开发和接口接入</a></p>\r\n<h1 id=\"h1-2-\"><a name=\"2. 注意\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2. 注意</h1><p>需要注意的是$wechatObj-&gt;valid()和$wechatObj-&gt;responseMsg(),valid是用来调试时验证接口用的,在接入后我们就不需要用到了,可以注释掉,然后调用$wechatObj-&gt;responseMsg()来实现功能.</p>\r\n<h1 id=\"h1-3-\"><a name=\"3. 实现\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3. 实现</h1><p>这里实现公众号关注自动回复和普通消息回复作为例子.</p>\r\n<pre><code class=\"lang-php\">&lt;?php\r\n/* 微信接口文件*/\r\n//define your token\r\ndefine(&quot;TOKEN&quot;, &quot;wechatgzp&quot;);\r\n$wechatObj = new wechatCallbackapiTest(); //实例化封装类\r\n//$wechatObj-&gt;valid(); //注释掉这里\r\n$wechatObj-&gt;responseMsg(); //这里调用回复功能封装的函数\r\n\r\nclass wechatCallbackapiTest\r\n{\r\n    public function valid()\r\n    {\r\n        $echoStr = $_GET[&quot;echostr&quot;];\r\n\r\n        //valid signature , option\r\n        if($this-&gt;checkSignature()){\r\n            echo $echoStr;\r\n            exit;\r\n        }\r\n    }\r\n\r\n    public function responseMsg()\r\n    {\r\n        //get post data, May be due to the different environments\r\n        $postStr = $GLOBALS[&quot;HTTP_RAW_POST_DATA&quot;];\r\n\r\n        //extract post data\r\n        if (!empty($postStr)){\r\n            /* libxml_disable_entity_loader is to prevent XML eXternal Entity Injection,\r\n               the best way is to check the validity of xml by yourself */\r\n            libxml_disable_entity_loader(true);\r\n            $postObj = simplexml_load_string($postStr, &#39;SimpleXMLElement&#39;, LIBXML_NOCDATA);\r\n            $fromUsername = $postObj-&gt;FromUserName;\r\n            $toUsername = $postObj-&gt;ToUserName;\r\n            $keyword = trim($postObj-&gt;Content);\r\n            $time = time();\r\n            $textTpl = &quot;&lt;xml&gt;\r\n &lt;ToUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/ToUserName&gt;\r\n &lt;FromUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/FromUserName&gt;\r\n &lt;CreateTime&gt;%s&lt;/CreateTime&gt;\r\n &lt;MsgType&gt;&lt;![CDATA[%s]]&gt;&lt;/MsgType&gt;\r\n &lt;Content&gt;&lt;![CDATA[%s]]&gt;&lt;/Content&gt;\r\n &lt;FuncFlag&gt;0&lt;/FuncFlag&gt;\r\n &lt;/xml&gt;&quot;;\r\n\r\n            //加载图文模版\r\n            $picTpl = &quot;&lt;xml&gt;\r\n &lt;ToUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/ToUserName&gt;\r\n &lt;FromUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/FromUserName&gt;\r\n &lt;CreateTime&gt;%s&lt;/CreateTime&gt;\r\n &lt;MsgType&gt;&lt;![CDATA[%s]]&gt;&lt;/MsgType&gt;\r\n &lt;ArticleCount&gt;1&lt;/ArticleCount&gt;\r\n &lt;Articles&gt;\r\n &lt;item&gt;\r\n &lt;Title&gt;&lt;![CDATA[%s]]&gt;&lt;/Title&gt;\r\n &lt;Description&gt;&lt;![CDATA[%s]]&gt;&lt;/Description&gt;\r\n &lt;PicUrl&gt;&lt;![CDATA[%s]]&gt;&lt;/PicUrl&gt;\r\n &lt;Url&gt;&lt;![CDATA[%s]]&gt;&lt;/Url&gt;\r\n &lt;/item&gt;\r\n &lt;/Articles&gt;\r\n &lt;FuncFlag&gt;1&lt;/FuncFlag&gt;\r\n &lt;/xml&gt; &quot;;\r\n\r\n            //用户输入内容了\r\n            if(!empty( $keyword ))\r\n            {\r\n                $msgType = &quot;text&quot;;\r\n                $contentStr = &quot;欢迎关注!更多内容,敬请期待!&quot;;\r\n                $resultStr = sprintf($textTpl, $fromUsername, $toUsername, $time, $msgType, $contentStr);\r\n                echo $resultStr;\r\n            }\r\n\r\n            //判断是否是新关注\r\n            elseif(trim($postObj-&gt;MsgType) == &quot;event&quot; and trim($postObj-&gt;Event) == &quot;subscribe&quot;)\r\n            {\r\n                $msgType = &quot;news&quot;;\r\n                $title = &quot;大兄弟别跑听锅锅说话&quot;; //标题\r\n                $data  = date(&#39;Y-m-d&#39;); //时间\r\n                $desription = &quot;感谢您关注【大兄弟别跑听锅锅说话】&quot;.&quot;\\n&quot;.&quot;微信号：gzpblog&quot;.&quot;\\n&quot;.&quot;博客网址:http://www.gzpblog.com&quot;.&quot;\\n&quot;.&quot;更多内容,敬请期待!&quot;; //简介\r\n                $image = &quot;http://www.gzpblog.com/usr/uploads/shuta.jpg&quot;; //图片地址\r\n                $turl = &quot;http://www.gzpblog.com&quot;; //链接地址\r\n                $resultStr = sprintf($picTpl, $fromUsername, $toUsername, $time, $msgType, $title,$desription,$image,$turl);\r\n                echo $resultStr;\r\n            }\r\n        }\r\n        else\r\n        {\r\n            echo &quot;&quot;;\r\n            exit;\r\n        }\r\n    }\r\n}\r\n</code></pre>\r\n<p>在这里我们用了两种回复格式，关注时自动回复用的是带图片的新闻模式，而普通消息回复则是纯文字。判断关注使用事件来判断，而普通消息回复判断其keyword，各消息类型的推送XML数据包结构在开发者文档中列出来，这里就不列了，给个地址:<a href=\"http://mp.weixin.qq.com/wiki/17/f298879f8fb29ab98b2f2971d42552fd.html\">http://mp.weixin.qq.com/wiki/17/f298879f8fb29ab98b2f2971d42552fd.html</a></p>\r\n<p>以我自己的公众号为例,实现的效果如下：<br><img src=\"https://www.goozp.com/uploads/2018/01/2705660894.png\" alt=\"\"><br>实际上，这只是其中的一个简单小功能，然后我们会发现，个人公众号，不能通过认证，能调用的接口权限很少，只能实现一些简单功能，具体权限也可以在官方文档中找到。而且，连自定义菜单这种功能，个人公众号都无法调用接口，实在蛋疼得很。（后续补充：个人公众号可以自定义菜单了）</p>\r\n<p>当然，还是有一些功能挺有意思的等待去发掘，将微信服务器和博客的共用可能可以打造出一些有意思的效果，不过不知道能不能实现，现在只是想想，以后有时间研究研究。</p>\r\n<h1 id=\"h1-4-2017-\"><a name=\"4. 后续更新（2017年~）\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4. 后续更新（2017年~）</h1><p>微信公众号已经可以在后台直接设置自动回复了，个人公众号也可以自定义菜单了，逐渐放开了。所以本文仅供参考了。</p>\r\n', '', 0, 'publish', 1, 0, '/article/12.html', '', 0, 80, '2016-03-16 14:52:24', '2016-03-16 14:52:24', '2018-01-07 19:02:52', NULL);
INSERT INTO `pt_post` VALUES (13, 10, 'article', 'JS代码实例——弹出多选选择框', '# 1. 效果\r\n最近在搞一个多选的功能，发现实现下拉框多选比较麻烦，网上搜是有一些js插件什么的可以实现，但是比较麻烦。于是搞了这么一个JS的弹出框，进行多选提交后显示在页面上。\r\n\r\n效果是这样的，初始的样式如下，可点击选择：\r\n![](https://www.goozp.com/uploads/2018/01/926381641.png)\r\n\r\n点击选择后弹出一个选择框，多选的：\r\n![](https://www.goozp.com/uploads/2018/01/2505066357.png)\r\n\r\n点击选择将同步更新到页面上，然后进行后续操作：\r\n![](https://www.goozp.com/uploads/2018/01/2323188462.png)\r\n\r\n# 2. 实现\r\n## 2.1 HTML代码\r\n```\r\n<input type=\"hidden\" id=\"select\" />\r\n<div class=\"servicelist\" id=\"servicelist\">\r\n    <div class=\"title\">选择地区<label onclick=\"this.parentNode.parentNode.style.display=\'none\'\">X</label></div>\r\n    <div class=\"content\">\r\n        <ul>\r\n            <li><input type=\"checkbox\" value=\"广东\" onclick=\"chk_choose()\" id=\"chk_service_1\" />\r\n            <span id=\"label_service_1\" onclick=\"document.getElementById(\'chk_service_1\').click()\">广东</span></li>\r\n            <li><input type=\"checkbox\" value=\"北京\" onclick=\"chk_choose()\" id=\"chk_service_2\" />\r\n            <span id=\"label_service_2\" onclick=\"document.getElementById(\'chk_service_2\').click()\">北京</span></li>\r\n            <li><input type=\"checkbox\" value=\"上海\" onclick=\"chk_choose()\" id=\"chk_service_3\" />\r\n            <span id=\"label_service_3\" onclick=\"document.getElementById(\'chk_service_3\').click()\">上海</span></li>\r\n            <li><input type=\"checkbox\" value=\"天津\" onclick=\"chk_choose()\" id=\"chk_service_4\" />\r\n            <span id=\"label_service_4\" onclick=\"document.getElementById(\'chk_service_4\').click()\">天津</span></li> \r\n        </ul>\r\n    </div>\r\n</div>\r\n<input type=\"submit\" value=\"确定\" class=\"button\" />\r\n```\r\n\r\n## 2.2 JS代码\r\n```\r\n<script>\r\nfunction choose_service()\r\n{\r\n	var servicelist = document.getElementById(\"servicelist\");\r\n	servicelist.style.left = (document.body.clientWidth-450)/2+\"px\";\r\n	servicelist.style.display = \"block\";\r\n}\r\nfunction chk_choose()\r\n{\r\n	document.getElementById(\"select\").value = \"\";\r\n	document.getElementById(\"choose_service\").innerHTML = \"\";\r\n	var servicelist = document.getElementById(\"servicelist\");\r\n	var chks = document.getElementsByTagName(\"input\");\r\n	var vals = \"\";\r\n	var names = \"\";\r\n	for(var i = 0;i<chks.length;i++)\r\n	{\r\n		var chk = chks[i];\r\n		if(chk.type!=\"checkbox\"&&chk.type!=\"CHECKBOX\")\r\n		continue;\r\n		if(chk.id.indexOf(\"chk_service_\")==-1)\r\n		continue;\r\n		var user_id = chk.id.replace(\"chk_service_\",\"\");\r\n		if(chk.checked){\r\n			vals+=chk.value+\",\";\r\n			names+=document.getElementById(\"label_service_\"+user_id).innerHTML+\",\";\r\n		}\r\n	}\r\n	names = names.substring(0,names.length-1);\r\n	vals = vals.substring(0,vals.length-1);\r\n\r\n	document.getElementById(\"select\").value = vals?vals:\"\";\r\n	document.getElementById(\"choose_service\").innerHTML = names?names:\"请选择\";\r\n}\r\n</script>\r\n```\r\n\r\n## 2.3 CSS样式\r\n```\r\n<style>\r\n.servicelist{ position:fixed; top:20px; border-radius:5px; width:450px; height:300px; border:1px solid #92B4CB; left:20px; top:100px; display:none;}\r\n\r\n.servicelist .title{ width:440px; border-radius:5px; border:1px solid #92B4CB; height:30px; line-height:30px; color:#fff; background:#007AB3; font-size:15px; padding-left:10px; font-weight:bold;}\r\n\r\n.servicelist .title label{ float:right; margin-right:20px; cursor:pointer;}\r\n\r\n.servicelist .content{ background:#fff; width:430px; padding:10px; height:245px;}\r\n\r\n.servicelist .content ul{list-style:none;}\r\n\r\n.servicelist .content ul li{ float:left; display:inline-block; width:80px; margin-bottom:10px;}\r\n\r\n.servicelist .content ul li span{ cursor:pointer;}\r\n\r\n#choose_service{ cursor:pointer;}\r\n</style>\r\n```', '<h1 id=\"h1-1-\"><a name=\"1. 效果\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1. 效果</h1><p>最近在搞一个多选的功能，发现实现下拉框多选比较麻烦，网上搜是有一些js插件什么的可以实现，但是比较麻烦。于是搞了这么一个JS的弹出框，进行多选提交后显示在页面上。</p>\r\n<p>效果是这样的，初始的样式如下，可点击选择：<br><img src=\"https://www.goozp.com/uploads/2018/01/926381641.png\" alt=\"\"></p>\r\n<p>点击选择后弹出一个选择框，多选的：<br><img src=\"https://www.goozp.com/uploads/2018/01/2505066357.png\" alt=\"\"></p>\r\n<p>点击选择将同步更新到页面上，然后进行后续操作：<br><img src=\"https://www.goozp.com/uploads/2018/01/2323188462.png\" alt=\"\"></p>\r\n<h1 id=\"h1-2-\"><a name=\"2. 实现\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2. 实现</h1><h2 id=\"h2-2-1-html-\"><a name=\"2.1 HTML代码\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.1 HTML代码</h2><pre><code>&lt;input type=&quot;hidden&quot; id=&quot;select&quot; /&gt;\r\n&lt;div class=&quot;servicelist&quot; id=&quot;servicelist&quot;&gt;\r\n    &lt;div class=&quot;title&quot;&gt;选择地区&lt;label onclick=&quot;this.parentNode.parentNode.style.display=&#39;none&#39;&quot;&gt;X&lt;/label&gt;&lt;/div&gt;\r\n    &lt;div class=&quot;content&quot;&gt;\r\n        &lt;ul&gt;\r\n            &lt;li&gt;&lt;input type=&quot;checkbox&quot; value=&quot;广东&quot; onclick=&quot;chk_choose()&quot; id=&quot;chk_service_1&quot; /&gt;\r\n            &lt;span id=&quot;label_service_1&quot; onclick=&quot;document.getElementById(&#39;chk_service_1&#39;).click()&quot;&gt;广东&lt;/span&gt;&lt;/li&gt;\r\n            &lt;li&gt;&lt;input type=&quot;checkbox&quot; value=&quot;北京&quot; onclick=&quot;chk_choose()&quot; id=&quot;chk_service_2&quot; /&gt;\r\n            &lt;span id=&quot;label_service_2&quot; onclick=&quot;document.getElementById(&#39;chk_service_2&#39;).click()&quot;&gt;北京&lt;/span&gt;&lt;/li&gt;\r\n            &lt;li&gt;&lt;input type=&quot;checkbox&quot; value=&quot;上海&quot; onclick=&quot;chk_choose()&quot; id=&quot;chk_service_3&quot; /&gt;\r\n            &lt;span id=&quot;label_service_3&quot; onclick=&quot;document.getElementById(&#39;chk_service_3&#39;).click()&quot;&gt;上海&lt;/span&gt;&lt;/li&gt;\r\n            &lt;li&gt;&lt;input type=&quot;checkbox&quot; value=&quot;天津&quot; onclick=&quot;chk_choose()&quot; id=&quot;chk_service_4&quot; /&gt;\r\n            &lt;span id=&quot;label_service_4&quot; onclick=&quot;document.getElementById(&#39;chk_service_4&#39;).click()&quot;&gt;天津&lt;/span&gt;&lt;/li&gt; \r\n        &lt;/ul&gt;\r\n    &lt;/div&gt;\r\n&lt;/div&gt;\r\n&lt;input type=&quot;submit&quot; value=&quot;确定&quot; class=&quot;button&quot; /&gt;\r\n</code></pre><h2 id=\"h2-2-2-js-\"><a name=\"2.2 JS代码\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.2 JS代码</h2><pre><code>&lt;script&gt;\r\nfunction choose_service()\r\n{\r\n    var servicelist = document.getElementById(&quot;servicelist&quot;);\r\n    servicelist.style.left = (document.body.clientWidth-450)/2+&quot;px&quot;;\r\n    servicelist.style.display = &quot;block&quot;;\r\n}\r\nfunction chk_choose()\r\n{\r\n    document.getElementById(&quot;select&quot;).value = &quot;&quot;;\r\n    document.getElementById(&quot;choose_service&quot;).innerHTML = &quot;&quot;;\r\n    var servicelist = document.getElementById(&quot;servicelist&quot;);\r\n    var chks = document.getElementsByTagName(&quot;input&quot;);\r\n    var vals = &quot;&quot;;\r\n    var names = &quot;&quot;;\r\n    for(var i = 0;i&lt;chks.length;i++)\r\n    {\r\n        var chk = chks[i];\r\n        if(chk.type!=&quot;checkbox&quot;&amp;&amp;chk.type!=&quot;CHECKBOX&quot;)\r\n        continue;\r\n        if(chk.id.indexOf(&quot;chk_service_&quot;)==-1)\r\n        continue;\r\n        var user_id = chk.id.replace(&quot;chk_service_&quot;,&quot;&quot;);\r\n        if(chk.checked){\r\n            vals+=chk.value+&quot;,&quot;;\r\n            names+=document.getElementById(&quot;label_service_&quot;+user_id).innerHTML+&quot;,&quot;;\r\n        }\r\n    }\r\n    names = names.substring(0,names.length-1);\r\n    vals = vals.substring(0,vals.length-1);\r\n\r\n    document.getElementById(&quot;select&quot;).value = vals?vals:&quot;&quot;;\r\n    document.getElementById(&quot;choose_service&quot;).innerHTML = names?names:&quot;请选择&quot;;\r\n}\r\n&lt;/script&gt;\r\n</code></pre><h2 id=\"h2-2-3-css-\"><a name=\"2.3 CSS样式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.3 CSS样式</h2><pre><code>&lt;style&gt;\r\n.servicelist{ position:fixed; top:20px; border-radius:5px; width:450px; height:300px; border:1px solid #92B4CB; left:20px; top:100px; display:none;}\r\n\r\n.servicelist .title{ width:440px; border-radius:5px; border:1px solid #92B4CB; height:30px; line-height:30px; color:#fff; background:#007AB3; font-size:15px; padding-left:10px; font-weight:bold;}\r\n\r\n.servicelist .title label{ float:right; margin-right:20px; cursor:pointer;}\r\n\r\n.servicelist .content{ background:#fff; width:430px; padding:10px; height:245px;}\r\n\r\n.servicelist .content ul{list-style:none;}\r\n\r\n.servicelist .content ul li{ float:left; display:inline-block; width:80px; margin-bottom:10px;}\r\n\r\n.servicelist .content ul li span{ cursor:pointer;}\r\n\r\n#choose_service{ cursor:pointer;}\r\n&lt;/style&gt;\r\n</code></pre>', '', 0, 'publish', 1, 0, '/article/13.html', '', 0, 93, '2016-04-01 05:16:47', '2016-04-01 05:16:47', '2018-01-07 19:38:28', NULL);
INSERT INTO `pt_post` VALUES (14, 10, 'article', '建中路剿鼠记（二）', '就在我写完 [建中路剿鼠记(一)](https://www.goozp.com/article/10.html \"建中路剿鼠记(一)\")，然后去睡觉的时候，发生了一件事，我发现，如图：\r\n![](https://www.goozp.com/uploads/2018/01/3523161483.jpg) ![](https://www.goozp.com/uploads/2018/01/1482183358.jpg)\r\n我的内心是奔溃的。我的床沦陷了。。。。。\r\n\r\n还好快递给力，老鼠贴已到！\r\n![](https://www.goozp.com/uploads/2018/01/331199711.jpg)\r\n\r\n为了预防这玩意不管用，我还买了发泡胶！用来封老鼠洞！准备抓老鼠与封老鼠洞双管齐下！！不然这日子没法过了！\r\n![](https://www.goozp.com/uploads/2018/01/4106656255.jpg)\r\n\r\n但是，我竟然发现，老鼠洞口不是空调上的那个洞！因为那个洞是封死的！死的！\r\n查了一下资料，说，只要一根手指能穿过的地方，成年老鼠就能穿过去，细思级恐，缩骨功啊。那就只能是从厕所那边通过门缝穿进来了！于是乎，我铸了一道防御工事！\r\n![](https://www.goozp.com/uploads/2018/01/915657141.jpg)\r\n\r\n![](https://www.goozp.com/uploads/2018/01/4030579334.jpg)\r\n肯定是从那上面下来的，因为油烟机顶上，巨量老鼠屎！\r\n\r\n经过这几天的老鼠贴测试，竟然抓不到老鼠！防御工事竟然起了作用。瞬间感觉自己屌屌的！', '<p>就在我写完 <a href=\"https://www.goozp.com/article/10.html\" title=\"建中路剿鼠记(一)\">建中路剿鼠记(一)</a>，然后去睡觉的时候，发生了一件事，我发现，如图：<br><img src=\"https://www.goozp.com/uploads/2018/01/3523161483.jpg\" alt=\"\"> <img src=\"https://www.goozp.com/uploads/2018/01/1482183358.jpg\" alt=\"\"><br>我的内心是奔溃的。我的床沦陷了。。。。。</p>\r\n<p>还好快递给力，老鼠贴已到！<br><img src=\"https://www.goozp.com/uploads/2018/01/331199711.jpg\" alt=\"\"></p>\r\n<p>为了预防这玩意不管用，我还买了发泡胶！用来封老鼠洞！准备抓老鼠与封老鼠洞双管齐下！！不然这日子没法过了！<br><img src=\"https://www.goozp.com/uploads/2018/01/4106656255.jpg\" alt=\"\"></p>\r\n<p>但是，我竟然发现，老鼠洞口不是空调上的那个洞！因为那个洞是封死的！死的！<br>查了一下资料，说，只要一根手指能穿过的地方，成年老鼠就能穿过去，细思级恐，缩骨功啊。那就只能是从厕所那边通过门缝穿进来了！于是乎，我铸了一道防御工事！<br><img src=\"https://www.goozp.com/uploads/2018/01/915657141.jpg\" alt=\"\"></p>\r\n<p><img src=\"https://www.goozp.com/uploads/2018/01/4030579334.jpg\" alt=\"\"><br>肯定是从那上面下来的，因为油烟机顶上，巨量老鼠屎！</p>\r\n<p>经过这几天的老鼠贴测试，竟然抓不到老鼠！防御工事竟然起了作用。瞬间感觉自己屌屌的！</p>\r\n', '', 0, 'publish', 1, 0, '/article/14.html', '', 0, 84, '2016-04-05 15:56:48', '2016-04-05 15:56:48', '2018-01-07 19:29:10', NULL);
INSERT INTO `pt_post` VALUES (15, 10, 'article', '建中路剿鼠记（三）', '发一张我现在的状态：\r\n![](https://www.goozp.com/uploads/2018/01/3002222694.jpg)\r\n\r\n感觉没有老鼠的生活真好，不用开着灯睡觉的感觉真好！不过现在完全不敢在室内弄出香香的味道，以免招惹老鼠，吃完这个面，还得把袋子垃圾扔出去，以免引来老鼠，万一我的发泡胶被捅破了老鼠进来了，我又得折腾了，多不好。\r\n\r\n不知道没老鼠的生活可以坚持多久呢，少了老鼠的陪伴，生活还少了些许乐趣呢。啧啧……人鼠大战暂时告一段落！', '<p>发一张我现在的状态：<br><img src=\"https://www.goozp.com/uploads/2018/01/3002222694.jpg\" alt=\"\"></p>\r\n<p>感觉没有老鼠的生活真好，不用开着灯睡觉的感觉真好！不过现在完全不敢在室内弄出香香的味道，以免招惹老鼠，吃完这个面，还得把袋子垃圾扔出去，以免引来老鼠，万一我的发泡胶被捅破了老鼠进来了，我又得折腾了，多不好。</p>\r\n<p>不知道没老鼠的生活可以坚持多久呢，少了老鼠的陪伴，生活还少了些许乐趣呢。啧啧……人鼠大战暂时告一段落！</p>\r\n', '', 0, 'publish', 1, 0, '/article/15.html', '', 0, 78, '2016-04-05 16:14:33', '2016-04-05 16:14:33', '2018-01-07 19:32:54', NULL);
INSERT INTO `pt_post` VALUES (16, 10, 'article', 'JavaScript中获取当前日期的代码', '如果要用js来获取当前的时间，比如“2016年4月7日星期四”，我们可以这样写：\r\n```html\r\n<html>\r\n<head>\r\n	<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" />\r\n</head>\r\n<body>\r\n<script language=JavaScript>\r\n	var today = new Date();\r\n	function initArray()\r\n	{\r\n		this.length=initArray.arguments.length\r\n		for(var i=0;i<this.length;i++)\r\n		this[i+1]=initArray.arguments[i]\r\n	}\r\n\r\n	var d = new initArray\r\n	(\r\n		\"星期日\",\r\n		\"星期一\",\r\n		\"星期二\",\r\n		\"星期三\",\r\n		\"星期四\",\r\n		\"星期五\",\r\n		\"星期六\"\r\n	);\r\n\r\n	document.write\r\n	(\r\n		\"<font style=\'font-size:9pt;font-family: 宋体\'> \",\r\n		today.getYear(),\"年\",\r\n		today.getMonth()+1,\"月\",\r\n		today.getDate(),\"日\",\r\n		d[today.getDay()+1],\r\n		\"</font>\"\r\n	);\r\n</script>\r\n</body>\r\n</html>\r\n```', '<p>如果要用js来获取当前的时间，比如“2016年4月7日星期四”，我们可以这样写：</p>\r\n<pre><code class=\"lang-html\">&lt;html&gt;\r\n&lt;head&gt;\r\n    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;\r\n&lt;/head&gt;\r\n&lt;body&gt;\r\n&lt;script language=JavaScript&gt;\r\n    var today = new Date();\r\n    function initArray()\r\n    {\r\n        this.length=initArray.arguments.length\r\n        for(var i=0;i&lt;this.length;i++)\r\n        this[i+1]=initArray.arguments[i]\r\n    }\r\n\r\n    var d = new initArray\r\n    (\r\n        &quot;星期日&quot;,\r\n        &quot;星期一&quot;,\r\n        &quot;星期二&quot;,\r\n        &quot;星期三&quot;,\r\n        &quot;星期四&quot;,\r\n        &quot;星期五&quot;,\r\n        &quot;星期六&quot;\r\n    );\r\n\r\n    document.write\r\n    (\r\n        &quot;&lt;font style=&#39;font-size:9pt;font-family: 宋体&#39;&gt; &quot;,\r\n        today.getYear(),&quot;年&quot;,\r\n        today.getMonth()+1,&quot;月&quot;,\r\n        today.getDate(),&quot;日&quot;,\r\n        d[today.getDay()+1],\r\n        &quot;&lt;/font&gt;&quot;\r\n    );\r\n&lt;/script&gt;\r\n&lt;/body&gt;\r\n&lt;/html&gt;\r\n</code></pre>\r\n', '', 0, 'publish', 1, 0, '/article/16.html', '', 0, 82, '2016-04-06 16:59:26', '2016-04-06 16:59:26', '2018-01-07 19:42:43', NULL);
INSERT INTO `pt_post` VALUES (17, 10, 'article', '程序员要对自己好一点系列之——人生第一个机械键盘', '接触编程也大概有九个月了吧。一开始想着，程序员应该对自己好一点，是的吧，给自己买了部比较好的笔记本（对我来说，挺好了），鼠标啊键盘啊什么的，还是用的比较low的。最近几天突然思考起一个事情，这笔记本码起代码来，着实有点不怎么顺手的。\r\n\r\n瞬间想到了外接键盘！于是乎，端午节的假期，两天时间在看键盘。还是那句，“程序员嘛，对自己好点嘛”。好的，机械键盘走起。\r\n\r\n看图！\r\n![](https://www.goozp.com/uploads/2018/01/3834160044.png)\r\n对的，人生第一个机械键盘，就是这个。\r\n\r\n一开始也是纠结了很久，到底选个什么轴呢？黑轴，青轴，茶轴，红轴？本来想来一发黑轴的，因为青轴吵，茶轴没感觉，黑轴看着不错还便宜。最后还是选择了红轴，因为似乎挺多人推荐红轴的。\r\n\r\n当然，既然是第一个机械键盘，当然是买一个入门级的试试水啦。千挑万挑，挑了这一款： Ducky魔力鸭 2087s S2，必须樱桃轴，红轴，没背光，码代码感觉没必要背光了，而且似乎想要可以再DIY。嗯，恰好粉丝节嘛，下单！\r\n\r\n顺丰妥妥的第二天就到了。\r\n![](https://www.goozp.com/uploads/2018/01/1824703186.png)\r\n\r\n外壳:\r\n![](https://www.goozp.com/uploads/2018/01/2636851374.png)\r\n\r\n拆开了！哎哟还有一个啥玩意盖着~\r\n![](https://www.goozp.com/uploads/2018/01/2033684534.png)\r\n\r\n完整的，长这个样，感觉，挺好，就是要一个这种样子的，就是不知道没有小键盘会不会不习惯，不过那都不是事。\r\n![](https://www.goozp.com/uploads/2018/01/3236160541.png)\r\n\r\n好的，重点是：\r\n![](https://www.goozp.com/uploads/2018/01/1567451059.png)\r\n桌子太小了！！！！！！！\r\n\r\n不过，到目前为止，都挺满意的，敲起来跟飞起来了一样。总体感觉不错，虽然没有玩过其它轴，网吧玩过青轴，但是红轴这个质感确实不错，有一定的声音，直上直下，有弹簧的感觉, 就是感觉shift这个键,有点紧。\r\n\r\n就这样，用着吧，感觉入了这个坑，以后敲普通薄膜键盘都会不顺手了。', '<p>接触编程也大概有九个月了吧。一开始想着，程序员应该对自己好一点，是的吧，给自己买了部比较好的笔记本（对我来说，挺好了），鼠标啊键盘啊什么的，还是用的比较low的。最近几天突然思考起一个事情，这笔记本码起代码来，着实有点不怎么顺手的。</p>\r\n<p>瞬间想到了外接键盘！于是乎，端午节的假期，两天时间在看键盘。还是那句，“程序员嘛，对自己好点嘛”。好的，机械键盘走起。</p>\r\n<p>看图！<br><img src=\"https://www.goozp.com/uploads/2018/01/3834160044.png\" alt=\"\"><br>对的，人生第一个机械键盘，就是这个。</p>\r\n<p>一开始也是纠结了很久，到底选个什么轴呢？黑轴，青轴，茶轴，红轴？本来想来一发黑轴的，因为青轴吵，茶轴没感觉，黑轴看着不错还便宜。最后还是选择了红轴，因为似乎挺多人推荐红轴的。</p>\r\n<p>当然，既然是第一个机械键盘，当然是买一个入门级的试试水啦。千挑万挑，挑了这一款： Ducky魔力鸭 2087s S2，必须樱桃轴，红轴，没背光，码代码感觉没必要背光了，而且似乎想要可以再DIY。嗯，恰好粉丝节嘛，下单！</p>\r\n<p>顺丰妥妥的第二天就到了。<br><img src=\"https://www.goozp.com/uploads/2018/01/1824703186.png\" alt=\"\"></p>\r\n<p>外壳:<br><img src=\"https://www.goozp.com/uploads/2018/01/2636851374.png\" alt=\"\"></p>\r\n<p>拆开了！哎哟还有一个啥玩意盖着~<br><img src=\"https://www.goozp.com/uploads/2018/01/2033684534.png\" alt=\"\"></p>\r\n<p>完整的，长这个样，感觉，挺好，就是要一个这种样子的，就是不知道没有小键盘会不会不习惯，不过那都不是事。<br><img src=\"https://www.goozp.com/uploads/2018/01/3236160541.png\" alt=\"\"></p>\r\n<p>好的，重点是：<br><img src=\"https://www.goozp.com/uploads/2018/01/1567451059.png\" alt=\"\"><br>桌子太小了！！！！！！！</p>\r\n<p>不过，到目前为止，都挺满意的，敲起来跟飞起来了一样。总体感觉不错，虽然没有玩过其它轴，网吧玩过青轴，但是红轴这个质感确实不错，有一定的声音，直上直下，有弹簧的感觉, 就是感觉shift这个键,有点紧。</p>\r\n<p>就这样，用着吧，感觉入了这个坑，以后敲普通薄膜键盘都会不顺手了。</p>\r\n', '', 0, 'publish', 1, 0, '/article/17.html', '', 0, 82, '2016-06-13 15:41:25', '2016-06-13 15:41:25', '2018-01-07 19:50:44', NULL);
INSERT INTO `pt_post` VALUES (18, 10, 'article', '用Jquery实现动态添加和删除tr行', '# 一 效果\r\n这里放一个,用Jquery实现动态添加和删除tr行的小例子，之前自己琢磨的，毕竟js不熟，摸索中，下面是实现的样子，当然没有样式：\r\n![](https://www.goozp.com/uploads/2018/01/1398985470.png)\r\n\r\n点击添加按钮可以添加一行：\r\n![](https://www.goozp.com/uploads/2018/01/3581344272.png)\r\n\r\n点击删除可以删除本行：\r\n![](https://www.goozp.com/uploads/2018/01/4069227203.png)\r\n基本功能是这样。\r\n\r\n# 二 实现\r\n下面是代码：\r\n```\r\n<html>\r\n<head>\r\n	<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" />\r\n\r\n	<!-- 这里是引用了一个百度的jquery库,可换为本地jquery库 -->\r\n	<script src=\"http://apps.bdimg.com/libs/jquery/1.6.4/jquery.js\" type=\"text/javascript\"></script>\r\n</head>\r\n<body>\r\n\r\n<table id=\"allDatas\">\r\n	<tr>\r\n		<th>选择图片</th>\r\n		<th>图片名称</th>\r\n		<th>描述</th>\r\n		<th>操作</th>\r\n	</tr>\r\n	<tr>\r\n		<td><input type=\"file\" name=\"imageFile1\"/></td>\r\n		<td><input name=\"imageName\"></input></td>\r\n		<td><input name=\"note\" /> </td>\r\n		<td><a href=\"javascript:;\" onclick=\"deleteCurrentRow(this);\"><font color=\'red\'>删除</font></a></td>\r\n	</tr>\r\n</table>\r\n<button onclick=\"javascript:addCurrentRow();\" >添加</button>\r\n\r\n<script>\r\n	function addCurrentRow()\r\n	{\r\n		var trcomp=\"<tr><td><input type=\'file\' name=\'imageFile\'/></td><td><input name=\'imageName\'></input></td><td><input name=\'note\' /></td><td><a href=\'javascript:;\' onclick=\'deleteCurrentRow(this);\'><font color=\'red\'>删除</font></a></td></tr>\";\r\n		$(\"#allDatas tr:last-child\").after(trcomp);\r\n	}\r\n\r\n	function deleteCurrentRow(obj)\r\n	{\r\n		var isDelete=confirm(\"真的要删除吗？\");\r\n		if(isDelete){\r\n			var tr=obj.parentNode.parentNode;\r\n			var tbody=tr.parentNode;\r\n			tbody.removeChild(tr);\r\n		}\r\n	}\r\n</script>\r\n</body>\r\n</html>\r\n```\r\n', '<h1 id=\"h1--\"><a name=\"一 效果\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一 效果</h1><p>这里放一个,用Jquery实现动态添加和删除tr行的小例子，之前自己琢磨的，毕竟js不熟，摸索中，下面是实现的样子，当然没有样式：<br><img src=\"https://www.goozp.com/uploads/2018/01/1398985470.png\" alt=\"\"></p>\r\n<p>点击添加按钮可以添加一行：<br><img src=\"https://www.goozp.com/uploads/2018/01/3581344272.png\" alt=\"\"></p>\r\n<p>点击删除可以删除本行：<br><img src=\"https://www.goozp.com/uploads/2018/01/4069227203.png\" alt=\"\"><br>基本功能是这样。</p>\r\n<h1 id=\"h1--\"><a name=\"二 实现\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二 实现</h1><p>下面是代码：</p>\r\n<pre><code>&lt;html&gt;\r\n&lt;head&gt;\r\n    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;\r\n\r\n    &lt;!-- 这里是引用了一个百度的jquery库,可换为本地jquery库 --&gt;\r\n    &lt;script src=&quot;http://apps.bdimg.com/libs/jquery/1.6.4/jquery.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;\r\n&lt;/head&gt;\r\n&lt;body&gt;\r\n\r\n&lt;table id=&quot;allDatas&quot;&gt;\r\n    &lt;tr&gt;\r\n        &lt;th&gt;选择图片&lt;/th&gt;\r\n        &lt;th&gt;图片名称&lt;/th&gt;\r\n        &lt;th&gt;描述&lt;/th&gt;\r\n        &lt;th&gt;操作&lt;/th&gt;\r\n    &lt;/tr&gt;\r\n    &lt;tr&gt;\r\n        &lt;td&gt;&lt;input type=&quot;file&quot; name=&quot;imageFile1&quot;/&gt;&lt;/td&gt;\r\n        &lt;td&gt;&lt;input name=&quot;imageName&quot;&gt;&lt;/input&gt;&lt;/td&gt;\r\n        &lt;td&gt;&lt;input name=&quot;note&quot; /&gt; &lt;/td&gt;\r\n        &lt;td&gt;&lt;a href=&quot;javascript:;&quot; onclick=&quot;deleteCurrentRow(this);&quot;&gt;&lt;font color=&#39;red&#39;&gt;删除&lt;/font&gt;&lt;/a&gt;&lt;/td&gt;\r\n    &lt;/tr&gt;\r\n&lt;/table&gt;\r\n&lt;button onclick=&quot;javascript:addCurrentRow();&quot; &gt;添加&lt;/button&gt;\r\n\r\n&lt;script&gt;\r\n    function addCurrentRow()\r\n    {\r\n        var trcomp=&quot;&lt;tr&gt;&lt;td&gt;&lt;input type=&#39;file&#39; name=&#39;imageFile&#39;/&gt;&lt;/td&gt;&lt;td&gt;&lt;input name=&#39;imageName&#39;&gt;&lt;/input&gt;&lt;/td&gt;&lt;td&gt;&lt;input name=&#39;note&#39; /&gt;&lt;/td&gt;&lt;td&gt;&lt;a href=&#39;javascript:;&#39; onclick=&#39;deleteCurrentRow(this);&#39;&gt;&lt;font color=&#39;red&#39;&gt;删除&lt;/font&gt;&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&quot;;\r\n        $(&quot;#allDatas tr:last-child&quot;).after(trcomp);\r\n    }\r\n\r\n    function deleteCurrentRow(obj)\r\n    {\r\n        var isDelete=confirm(&quot;真的要删除吗？&quot;);\r\n        if(isDelete){\r\n            var tr=obj.parentNode.parentNode;\r\n            var tbody=tr.parentNode;\r\n            tbody.removeChild(tr);\r\n        }\r\n    }\r\n&lt;/script&gt;\r\n&lt;/body&gt;\r\n&lt;/html&gt;\r\n</code></pre>', '', 0, 'publish', 1, 0, '/article/18.html', '', 0, 95, '2016-05-19 15:36:33', '2016-05-19 15:36:33', '2018-01-07 20:01:05', NULL);
INSERT INTO `pt_post` VALUES (19, 10, 'article', 'PHP地理信息搜索功能——接入高德地图Web服务API，关键字搜索', '# 效果\r\n搞了一个基于高德地图Web服务API，关键字搜索服务的东西，先来效果图：\r\n![](https://www.goozp.com/uploads/2018/01/1867581207.png)\r\n\r\n搜索不到内容时：\r\n![](https://www.goozp.com/uploads/2018/01/2652457207.png)\r\n\r\n# 实现\r\n## HTML代码\r\n前端部分代码，样式就省略了：\r\n```html\r\n城市：<input type=\"text\" id=\"searchPlaceCity\" placeholder=\"输入城市\">\r\n关键字:<input type=\"text\" id=\"searchPlaceInfo\" placeholder=\"请输入关键字进行搜索...\">\r\n<a href=\"javascript:searchPlace()\">搜索</a>\r\n```\r\n\r\n## JS代码\r\n```\r\n<script>\r\n/* 高德地图api获取数据 */\r\nfunction searchPlace()\r\n{\r\n	var ajaxUrl=\"{:U(\'Map/searchPlace\')}\";\r\n	var keyword= $(\"#searchPlaceInfo\").val(); //获取输入的关键字\r\n	var city = $(\"#searchPlaceCity\").val(); //获取输入的城市\r\n\r\n	$.post(ajaxUrl,{\'keyword\':keyword,\'city\':city},function(data){\r\n		$(\'#searchResult\').html(\'\r\n			<table id=\"searchTable\" >\r\n			<tr id=\"tableTitle\">\r\n			<td>名称</td>\r\n			<td>省份/直辖市</td>\r\n			<td>城市/区</td>\r\n			<td>区划/县</td>\r\n			<td>详细地址</td>\r\n			<td>电话</td>\r\n			<td>坐标</td>\r\n			</tr>\r\n			</table>\r\n		\');\r\n\r\n		if (jQuery.isArray(data))\r\n		{\r\n			if (data.length == 0){\r\n				$(\'#searchTable\').append(\'\r\n					<tr>\r\n						<td colspan=\"7\">搜索不到内容，请尝试其它关键字！</td>\r\n					</tr>\'\r\n				);\r\n			}else{\r\n				$.each(data,function(key,value){\r\n					$(\'#searchTable\').append(\'\r\n						<tr>\r\n						<td>\'+value.name+\'</td>\r\n						<td>\'+value.pname+\'</td>\r\n						<td>\'+value.cityname+\'</td>\r\n						<td>\'+value.adname+\'</td>\r\n						<td>\'+value.address+\'</td>\r\n						<td>\'+value.tel+\'</td>\r\n						<td>\'+value.location+\'</td>\r\n						</tr>\r\n					\');\r\n				});\r\n			}\r\n		} else {\r\n			$(\'#searchTable\').append(\'\r\n				<tr>\r\n				<td colspan=\"7\">\'+data+\'</td>\r\n				</tr>\r\n			\');\r\n		}\r\n	});\r\n}\r\n</script>\r\n```\r\n\r\n## PHP代码:\r\n后台php代码，用的Thinkphp3.2框架：\r\n```php\r\n<?php \r\nnamespace Home\\Controller;\r\n\r\nuse Think\\Controller; \r\n\r\nclass MapController extends Controller\r\n{\r\n	public function searchPlace() {\r\n		$keyword = $_REQUEST[\'keyword\'];//获取keyword \r\n		$city = $_REQUEST[\'city\']; //获取城市 \r\n		$url = \"http://restapi.amap.com/v3/place/text\"; \r\n		$key = \"2f18a06**********************\";//高德开发者帐号给的key \r\n		$request = $url.\'?key=\'.$key.\'&keywords=\'.$keyword.\'&city=\'.$city; \r\n\r\n		/* 发送请求 */\r\n		$get = file_get_contents($request);\r\n		$result = json_decode($get);\r\n		$status = $result->status;//请求状态\r\n		$message = $result->info; //请求返回信息\r\n\r\n		if ($status == 1) { //请求成功\r\n			$pois = $result->pois; //地理位置信息\r\n			$this -> ajaxReturn($pois);\r\n		} else { //请求失败\r\n			$message = \"搜索失败，请尝试其它关键字！\";\r\n			$this -> ajaxReturn($message);\r\n		}\r\n	}\r\n}\r\n```', '<h1 id=\"h1-u6548u679C\"><a name=\"效果\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>效果</h1><p>搞了一个基于高德地图Web服务API，关键字搜索服务的东西，先来效果图：<br><img src=\"https://www.goozp.com/uploads/2018/01/1867581207.png\" alt=\"\"></p>\r\n<p>搜索不到内容时：<br><img src=\"https://www.goozp.com/uploads/2018/01/2652457207.png\" alt=\"\"></p>\r\n<h1 id=\"h1-u5B9Eu73B0\"><a name=\"实现\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>实现</h1><h2 id=\"h2-html-\"><a name=\"HTML代码\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>HTML代码</h2><p>前端部分代码，样式就省略了：</p>\r\n<pre><code class=\"lang-html\">城市：&lt;input type=&quot;text&quot; id=&quot;searchPlaceCity&quot; placeholder=&quot;输入城市&quot;&gt;\r\n关键字:&lt;input type=&quot;text&quot; id=&quot;searchPlaceInfo&quot; placeholder=&quot;请输入关键字进行搜索...&quot;&gt;\r\n&lt;a href=&quot;javascript:searchPlace()&quot;&gt;搜索&lt;/a&gt;\r\n</code></pre>\r\n<h2 id=\"h2-js-\"><a name=\"JS代码\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>JS代码</h2><pre><code>&lt;script&gt;\r\n/* 高德地图api获取数据 */\r\nfunction searchPlace()\r\n{\r\n    var ajaxUrl=&quot;{:U(&#39;Map/searchPlace&#39;)}&quot;;\r\n    var keyword= $(&quot;#searchPlaceInfo&quot;).val(); //获取输入的关键字\r\n    var city = $(&quot;#searchPlaceCity&quot;).val(); //获取输入的城市\r\n\r\n    $.post(ajaxUrl,{&#39;keyword&#39;:keyword,&#39;city&#39;:city},function(data){\r\n        $(&#39;#searchResult&#39;).html(&#39;\r\n            &lt;table id=&quot;searchTable&quot; &gt;\r\n            &lt;tr id=&quot;tableTitle&quot;&gt;\r\n            &lt;td&gt;名称&lt;/td&gt;\r\n            &lt;td&gt;省份/直辖市&lt;/td&gt;\r\n            &lt;td&gt;城市/区&lt;/td&gt;\r\n            &lt;td&gt;区划/县&lt;/td&gt;\r\n            &lt;td&gt;详细地址&lt;/td&gt;\r\n            &lt;td&gt;电话&lt;/td&gt;\r\n            &lt;td&gt;坐标&lt;/td&gt;\r\n            &lt;/tr&gt;\r\n            &lt;/table&gt;\r\n        &#39;);\r\n\r\n        if (jQuery.isArray(data))\r\n        {\r\n            if (data.length == 0){\r\n                $(&#39;#searchTable&#39;).append(&#39;\r\n                    &lt;tr&gt;\r\n                        &lt;td colspan=&quot;7&quot;&gt;搜索不到内容，请尝试其它关键字！&lt;/td&gt;\r\n                    &lt;/tr&gt;&#39;\r\n                );\r\n            }else{\r\n                $.each(data,function(key,value){\r\n                    $(&#39;#searchTable&#39;).append(&#39;\r\n                        &lt;tr&gt;\r\n                        &lt;td&gt;&#39;+value.name+&#39;&lt;/td&gt;\r\n                        &lt;td&gt;&#39;+value.pname+&#39;&lt;/td&gt;\r\n                        &lt;td&gt;&#39;+value.cityname+&#39;&lt;/td&gt;\r\n                        &lt;td&gt;&#39;+value.adname+&#39;&lt;/td&gt;\r\n                        &lt;td&gt;&#39;+value.address+&#39;&lt;/td&gt;\r\n                        &lt;td&gt;&#39;+value.tel+&#39;&lt;/td&gt;\r\n                        &lt;td&gt;&#39;+value.location+&#39;&lt;/td&gt;\r\n                        &lt;/tr&gt;\r\n                    &#39;);\r\n                });\r\n            }\r\n        } else {\r\n            $(&#39;#searchTable&#39;).append(&#39;\r\n                &lt;tr&gt;\r\n                &lt;td colspan=&quot;7&quot;&gt;&#39;+data+&#39;&lt;/td&gt;\r\n                &lt;/tr&gt;\r\n            &#39;);\r\n        }\r\n    });\r\n}\r\n&lt;/script&gt;\r\n</code></pre><h2 id=\"h2-php-\"><a name=\"PHP代码:\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>PHP代码:</h2><p>后台php代码，用的Thinkphp3.2框架：</p>\r\n<pre><code class=\"lang-php\">&lt;?php \r\nnamespace Home\\Controller;\r\n\r\nuse Think\\Controller; \r\n\r\nclass MapController extends Controller\r\n{\r\n    public function searchPlace() {\r\n        $keyword = $_REQUEST[&#39;keyword&#39;];//获取keyword \r\n        $city = $_REQUEST[&#39;city&#39;]; //获取城市 \r\n        $url = &quot;http://restapi.amap.com/v3/place/text&quot;; \r\n        $key = &quot;2f18a06**********************&quot;;//高德开发者帐号给的key \r\n        $request = $url.&#39;?key=&#39;.$key.&#39;&amp;keywords=&#39;.$keyword.&#39;&amp;city=&#39;.$city; \r\n\r\n        /* 发送请求 */\r\n        $get = file_get_contents($request);\r\n        $result = json_decode($get);\r\n        $status = $result-&gt;status;//请求状态\r\n        $message = $result-&gt;info; //请求返回信息\r\n\r\n        if ($status == 1) { //请求成功\r\n            $pois = $result-&gt;pois; //地理位置信息\r\n            $this -&gt; ajaxReturn($pois);\r\n        } else { //请求失败\r\n            $message = &quot;搜索失败，请尝试其它关键字！&quot;;\r\n            $this -&gt; ajaxReturn($message);\r\n        }\r\n    }\r\n}\r\n</code></pre>\r\n', '', 0, 'publish', 1, 0, '/article/19.html', '', 0, 99, '2016-07-12 06:19:57', '2016-07-12 06:19:57', '2018-01-08 03:06:03', NULL);
INSERT INTO `pt_post` VALUES (20, 10, 'article', 'ThinkPHP直接在控制器中定义_construct()报错', '碰到一个问题，直接在控制器中定义`__construct()`时，会报错。\r\n\r\n原因：必须调用父类Controller中的construct函数，所以要在定义的控制器中使用construct函数就必须用`parent::__construct()`;调用父类Controller中的`__construct`\r\n\r\n解决：可以用`_initialize`（thinkphp封装好的）直接定义一个构造函数省去频繁地调用`parent::__construct()`。\r\n\r\n比如：\r\n```php\r\n<?php\r\nclass IndexController extends Controller\r\n{\r\n	public function _initialize()\r\n	{\r\n		//检查是否登录\r\n		check_login();\r\n	}\r\n\r\n	public function index()\r\n	{\r\n		$this->display(\"index\");\r\n	}\r\n}\r\n```\r\n\r\n调用`parent::__construct()`的话：\r\n```php\r\n<?php\r\nclass IndexController extends Controller\r\n{\r\n	public function __construct()\r\n	{\r\n		parent::__construct();\r\n\r\n		//检查是否登录\r\n		check_login();\r\n	}\r\n\r\n	public function index()\r\n	{\r\n		$this->display(\"index\");\r\n	}\r\n}\r\n```', '<p>碰到一个问题，直接在控制器中定义<code>__construct()</code>时，会报错。</p>\r\n<p>原因：必须调用父类Controller中的construct函数，所以要在定义的控制器中使用construct函数就必须用<code>parent::__construct()</code>;调用父类Controller中的<code>__construct</code></p>\r\n<p>解决：可以用<code>_initialize</code>（thinkphp封装好的）直接定义一个构造函数省去频繁地调用<code>parent::__construct()</code>。</p>\r\n<p>比如：</p>\r\n<pre><code class=\"lang-php\">&lt;?php\r\nclass IndexController extends Controller\r\n{\r\n    public function _initialize()\r\n    {\r\n        //检查是否登录\r\n        check_login();\r\n    }\r\n\r\n    public function index()\r\n    {\r\n        $this-&gt;display(&quot;index&quot;);\r\n    }\r\n}\r\n</code></pre>\r\n<p>调用<code>parent::__construct()</code>的话：</p>\r\n<pre><code class=\"lang-php\">&lt;?php\r\nclass IndexController extends Controller\r\n{\r\n    public function __construct()\r\n    {\r\n        parent::__construct();\r\n\r\n        //检查是否登录\r\n        check_login();\r\n    }\r\n\r\n    public function index()\r\n    {\r\n        $this-&gt;display(&quot;index&quot;);\r\n    }\r\n}\r\n</code></pre>\r\n', '', 0, 'publish', 1, 0, '/article/20.html', '', 0, 109, '2016-10-12 13:20:39', '2016-10-12 13:20:39', '2018-01-08 03:28:04', NULL);
INSERT INTO `pt_post` VALUES (21, 10, 'article', '四种基本排序算法以及PHP实现', '因为之前没有编程基础，最近才知道排序算法这个概念，原来平时在操作数组的时候是用到“算法”这玩意的。\r\n\r\n从网上找了下资料，都一个来源；用$arr=array(1,43,54,62,21,66,32,78,36,76,39);  做例子排序。\r\n\r\n# 1. 冒泡排序\r\n## 1.1 原理\r\n在要排序的一组数中，对当前还未排好的序列，从前往后对相邻的两个数依次进行比较和调整，让较大的数往下沉，较小的往上冒。即，每当两相邻的数比较后发现它们的排序与排序要求相反时，就将它们互换。\r\n## 1.2 代码实现：\r\n```php\r\nfunction bubbleSort($arr)\r\n{\r\n	$len=count($arr);\r\n\r\n	//该层循环控制 需要冒泡的轮数\r\n	for($i=1;$i&amp;amp;lt;$len;$i++){\r\n		//该层循环用来控制每轮 冒出一个数 需要比较的次数\r\n		for($k=0;$k&amp;amp;lt;$len-$i;$k++) {\r\n			if($arr[$k]&amp;amp;gt;$arr[$k+1]){\r\n				$tmp=$arr[$k+1];\r\n				$arr[$k+1]=$arr[$k];\r\n				$arr[$k]=$tmp;\r\n			}\r\n		}\r\n	}\r\n\r\n 	return $arr;\r\n}\r\n```\r\n## 1.3 理解：\r\n假设有10个数：\r\n\r\n| 没排完 | 排完  |   |\r\n| ------------ | ------------ | ------------ |\r\n| `*********` | `*`  | （没排完的数中冒出一个最大的）  |\r\n| `********` |  `**` |  （没排完的数中冒出一个最大的放到排完的中，成为第二大的） |\r\n| ……  | ……  |   |\r\n| ……  |  …… |   |\r\n| `*` | `*********` | （直到没排完的只剩一个最小的，排序完成；过程中没排完的实际上是混序的，两两冒泡不会有排序效果，只是筛选出哪个大哪个小）  |\r\n\r\n# 2. 选择排序\r\n\r\n## 2.1 原理\r\n在要排序的一组数中，选出最小的一个数与第一个位置的数交换。然后在剩下的数当中再找最小的与第二个位置的数交换，如此循环到倒数第二个数和最后一个数比较为止。\r\n\r\n## 2.2 代码实现\r\n```\r\nfunction selectSort($arr) {\r\n	//双重循环完成，外层控制轮数，内层控制比较次数\r\n	$len=count($arr);\r\n	for($i=0; $i&lt;$len-1; $i++) {\r\n		//先假设最小的值的位置\r\n		$p = $i;\r\n		for($j=$i+1; $j&lt;$len; $j++) { //$arr[$p] 是当前已知的最小值\r\n			if($arr[$p] &gt; $arr[$j]) {\r\n				//比较，发现更小的,记录下最小值的位置；并且在下次比较时采用已知的最小值进行比较。\r\n				$p = $j;\r\n			}\r\n		}\r\n\r\n		//已经确定了当前的最小值的位置，保存到$p中。如果发现最小值的位置与当前假设的位置$i不同，则位置互换即可。\r\n		if($p != $i) {\r\n			$tmp = $arr[$p];\r\n			$arr[$p] = $arr[$i];\r\n			$arr[$i] = $tmp;\r\n		}\r\n	}\r\n\r\n	//返回最终结果\r\n	return $arr;\r\n}\r\n```\r\n\r\n## 2.3 理解\r\n假设有10个数：\r\n\r\n| 排完  |  没排完  |   |\r\n| ------------ | ------------ | ------------ |\r\n| `*`  | `*********`   |  （所有中抽出一个最小的，放到第一个） |\r\n|  `**` | `********`   | （没排完的抽出一个最小的，放到第二个）  |\r\n|  …… | ……  |   |\r\n| ……  | ……  |   |\r\n|  `*********`  | `*`   |  （直到抽完所有的数，排序完成） |\r\n\r\n# 3. 插入排序\r\n## 3.1原理\r\n在要排序的一组数中，假设前面的数已经是排好顺序的，现在要把第n个数插到前面的有序数中，使得这n个数也是排好顺序的。如此反复循环，直到全部排好顺序。\r\n\r\n## 3.2 代码实现\r\n```php\r\nfunction insertSort($arr) {\r\n	$len=count($arr);\r\n	for($i=1, $i<$len; $i++) {\r\n		$tmp = $arr[$i];\r\n		//内层循环控制，比较并插入\r\n		for($j=$i-1;$j>=0;$j--) {\r\n			if ($tmp < $arr[$j]) {\r\n				//发现插入的元素要小，交换位置，将后边的元素与前面的元素互换\r\n				$arr[$j+1] = $arr[$j];\r\n				$arr[$j] = $tmp;\r\n			} else {\r\n				//如果碰到不需要移动的元素，由于是已经排序好是数组，则前面的就不需要再次比较了。\r\n				break;\r\n			}\r\n		}\r\n	}\r\n\r\n	return $arr;\r\n}\r\n```\r\n\r\n## 3.3 理解\r\n假设有10个数：\r\n\r\n|  排完  | 没排完  |   |\r\n| ------------ | ------------ | ------------ |\r\n| `*`  |  `*********`   |  （拿出没排完的第一个数，到排完的中进行排序） |\r\n| `**`   |   `********`   | （拿出没排完的第一个数，到排完的中进行排序）  |\r\n| ……  | ……  |   |\r\n|  …… | ……  |   |\r\n|  `*********`  |  `*`  | （拿出没排完的最后一个数，到排完的中进行排序；期间是两两比较方式）  |\r\n\r\n# 4. 快速排序\r\n## 4.1 原理\r\n选择一个基准元素，通常选择第一个元素或者最后一个元素。通过一趟扫描，将待排序列分成两部分，一部分比基准元素小，一部分大于等于基准元素。此时基准元素在其排好序后的正确位置，然后再用同样的方法递归地排序划分的两部分。\r\n\r\n## 4.2 代码实现\r\n```php\r\nfunction quickSort($arr) {\r\n	//先判断是否需要继续进行\r\n	$length = count($arr);\r\n	if($length <= 1) {\r\n		return $arr;\r\n	}\r\n\r\n	//选择第一个元素作为基准\r\n	$base_num = $arr[0];\r\n	//遍历除了标尺外的所有元素，按照大小关系放入两个数组内\r\n	//初始化两个数组\r\n	$left_array = array(); //小于基准的\r\n	$right_array = array(); //大于基准的\r\n	for($i=1; $i<$length; $i++) {\r\n		if($base_num > $arr[$i]) {\r\n			//放入左边数组\r\n			$left_array[] = $arr[$i];\r\n		} else {\r\n			//放入右边\r\n			$right_array[] = $arr[$i];\r\n		}\r\n	}\r\n\r\n	//再分别对左边和右边的数组进行相同的排序处理方式递归调用这个函数\r\n	$left_array = quick_sort($left_array);\r\n	$right_array = quick_sort($right_array);\r\n\r\n	//合并\r\n	return array_merge($left_array, array($base_num), $right_array);\r\n}\r\n```\r\n\r\n## 4.3 理解\r\n假设有10个数：\r\n```\r\n小于拿出								拿出			大于拿出\r\n***										*			******\r\n小于拿出	再拿出		大于拿出	|	之前拿出	|	小于拿出	再拿出	大于拿出\r\n	*		*			*		|		*		|	**			*		***\r\n… …\r\n… …\r\n```\r\n如此循环直到最后全部拆开，再合起来，排序完成。\r\n```\r\n**********\r\n```\r\n\r\n# 5. 总结\r\n\r\n- 冒泡排序： 逐渐筛选出最大值\r\n- 选择排序：逐渐筛选出最小值\r\n- 插入排序：按顺序一个一个取出进行排序\r\n- 快速排序：逐渐递归拆分进行排序，直至全部拆分排序完成', '<p>因为之前没有编程基础，最近才知道排序算法这个概念，原来平时在操作数组的时候是用到“算法”这玩意的。</p>\r\n<p>从网上找了下资料，都一个来源；用$arr=array(1,43,54,62,21,66,32,78,36,76,39);  做例子排序。</p>\r\n<h1 id=\"h1-1-\"><a name=\"1. 冒泡排序\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1. 冒泡排序</h1><h2 id=\"h2-1-1-\"><a name=\"1.1 原理\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.1 原理</h2><p>在要排序的一组数中，对当前还未排好的序列，从前往后对相邻的两个数依次进行比较和调整，让较大的数往下沉，较小的往上冒。即，每当两相邻的数比较后发现它们的排序与排序要求相反时，就将它们互换。</p>\r\n<h2 id=\"h2-1-2-\"><a name=\"1.2 代码实现：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.2 代码实现：</h2><pre><code class=\"lang-php\">function bubbleSort($arr)\r\n{\r\n    $len=count($arr);\r\n\r\n    //该层循环控制 需要冒泡的轮数\r\n    for($i=1;$i&amp;amp;amp;lt;$len;$i++){\r\n        //该层循环用来控制每轮 冒出一个数 需要比较的次数\r\n        for($k=0;$k&amp;amp;amp;lt;$len-$i;$k++) {\r\n            if($arr[$k]&amp;amp;amp;gt;$arr[$k+1]){\r\n                $tmp=$arr[$k+1];\r\n                $arr[$k+1]=$arr[$k];\r\n                $arr[$k]=$tmp;\r\n            }\r\n        }\r\n    }\r\n\r\n     return $arr;\r\n}\r\n</code></pre>\r\n<h2 id=\"h2-1-3-\"><a name=\"1.3 理解：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.3 理解：</h2><p>假设有10个数：</p>\r\n<table>\r\n<thead>\r\n<tr>\r\n<th>没排完</th>\r\n<th>排完</th>\r\n<th></th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr>\r\n<td><code>*********</code></td>\r\n<td><code>*</code></td>\r\n<td>（没排完的数中冒出一个最大的）</td>\r\n</tr>\r\n<tr>\r\n<td><code>********</code></td>\r\n<td><code>**</code></td>\r\n<td>（没排完的数中冒出一个最大的放到排完的中，成为第二大的）</td>\r\n</tr>\r\n<tr>\r\n<td>……</td>\r\n<td>……</td>\r\n<td></td>\r\n</tr>\r\n<tr>\r\n<td>……</td>\r\n<td>……</td>\r\n<td></td>\r\n</tr>\r\n<tr>\r\n<td><code>*</code></td>\r\n<td><code>*********</code></td>\r\n<td>（直到没排完的只剩一个最小的，排序完成；过程中没排完的实际上是混序的，两两冒泡不会有排序效果，只是筛选出哪个大哪个小）</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<h1 id=\"h1-2-\"><a name=\"2. 选择排序\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2. 选择排序</h1><h2 id=\"h2-2-1-\"><a name=\"2.1 原理\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.1 原理</h2><p>在要排序的一组数中，选出最小的一个数与第一个位置的数交换。然后在剩下的数当中再找最小的与第二个位置的数交换，如此循环到倒数第二个数和最后一个数比较为止。</p>\r\n<h2 id=\"h2-2-2-\"><a name=\"2.2 代码实现\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.2 代码实现</h2><pre><code>function selectSort($arr) {\r\n    //双重循环完成，外层控制轮数，内层控制比较次数\r\n    $len=count($arr);\r\n    for($i=0; $i&amp;lt;$len-1; $i++) {\r\n        //先假设最小的值的位置\r\n        $p = $i;\r\n        for($j=$i+1; $j&amp;lt;$len; $j++) { //$arr[$p] 是当前已知的最小值\r\n            if($arr[$p] &amp;gt; $arr[$j]) {\r\n                //比较，发现更小的,记录下最小值的位置；并且在下次比较时采用已知的最小值进行比较。\r\n                $p = $j;\r\n            }\r\n        }\r\n\r\n        //已经确定了当前的最小值的位置，保存到$p中。如果发现最小值的位置与当前假设的位置$i不同，则位置互换即可。\r\n        if($p != $i) {\r\n            $tmp = $arr[$p];\r\n            $arr[$p] = $arr[$i];\r\n            $arr[$i] = $tmp;\r\n        }\r\n    }\r\n\r\n    //返回最终结果\r\n    return $arr;\r\n}\r\n</code></pre><h2 id=\"h2-2-3-\"><a name=\"2.3 理解\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.3 理解</h2><p>假设有10个数：</p>\r\n<table>\r\n<thead>\r\n<tr>\r\n<th>排完</th>\r\n<th>没排完</th>\r\n<th></th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr>\r\n<td><code>*</code></td>\r\n<td><code>*********</code></td>\r\n<td>（所有中抽出一个最小的，放到第一个）</td>\r\n</tr>\r\n<tr>\r\n<td><code>**</code></td>\r\n<td><code>********</code></td>\r\n<td>（没排完的抽出一个最小的，放到第二个）</td>\r\n</tr>\r\n<tr>\r\n<td>……</td>\r\n<td>……</td>\r\n<td></td>\r\n</tr>\r\n<tr>\r\n<td>……</td>\r\n<td>……</td>\r\n<td></td>\r\n</tr>\r\n<tr>\r\n<td><code>*********</code></td>\r\n<td><code>*</code></td>\r\n<td>（直到抽完所有的数，排序完成）</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<h1 id=\"h1-3-\"><a name=\"3. 插入排序\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3. 插入排序</h1><h2 id=\"h2-3-1-\"><a name=\"3.1原理\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.1原理</h2><p>在要排序的一组数中，假设前面的数已经是排好顺序的，现在要把第n个数插到前面的有序数中，使得这n个数也是排好顺序的。如此反复循环，直到全部排好顺序。</p>\r\n<h2 id=\"h2-3-2-\"><a name=\"3.2 代码实现\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.2 代码实现</h2><pre><code class=\"lang-php\">function insertSort($arr) {\r\n    $len=count($arr);\r\n    for($i=1, $i&lt;$len; $i++) {\r\n        $tmp = $arr[$i];\r\n        //内层循环控制，比较并插入\r\n        for($j=$i-1;$j&gt;=0;$j--) {\r\n            if ($tmp &lt; $arr[$j]) {\r\n                //发现插入的元素要小，交换位置，将后边的元素与前面的元素互换\r\n                $arr[$j+1] = $arr[$j];\r\n                $arr[$j] = $tmp;\r\n            } else {\r\n                //如果碰到不需要移动的元素，由于是已经排序好是数组，则前面的就不需要再次比较了。\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    return $arr;\r\n}\r\n</code></pre>\r\n<h2 id=\"h2-3-3-\"><a name=\"3.3 理解\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.3 理解</h2><p>假设有10个数：</p>\r\n<table>\r\n<thead>\r\n<tr>\r\n<th>排完</th>\r\n<th>没排完</th>\r\n<th></th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr>\r\n<td><code>*</code></td>\r\n<td><code>*********</code></td>\r\n<td>（拿出没排完的第一个数，到排完的中进行排序）</td>\r\n</tr>\r\n<tr>\r\n<td><code>**</code></td>\r\n<td><code>********</code></td>\r\n<td>（拿出没排完的第一个数，到排完的中进行排序）</td>\r\n</tr>\r\n<tr>\r\n<td>……</td>\r\n<td>……</td>\r\n<td></td>\r\n</tr>\r\n<tr>\r\n<td>……</td>\r\n<td>……</td>\r\n<td></td>\r\n</tr>\r\n<tr>\r\n<td><code>*********</code></td>\r\n<td><code>*</code></td>\r\n<td>（拿出没排完的最后一个数，到排完的中进行排序；期间是两两比较方式）</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<h1 id=\"h1-4-\"><a name=\"4. 快速排序\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4. 快速排序</h1><h2 id=\"h2-4-1-\"><a name=\"4.1 原理\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.1 原理</h2><p>选择一个基准元素，通常选择第一个元素或者最后一个元素。通过一趟扫描，将待排序列分成两部分，一部分比基准元素小，一部分大于等于基准元素。此时基准元素在其排好序后的正确位置，然后再用同样的方法递归地排序划分的两部分。</p>\r\n<h2 id=\"h2-4-2-\"><a name=\"4.2 代码实现\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.2 代码实现</h2><pre><code class=\"lang-php\">function quickSort($arr) {\r\n    //先判断是否需要继续进行\r\n    $length = count($arr);\r\n    if($length &lt;= 1) {\r\n        return $arr;\r\n    }\r\n\r\n    //选择第一个元素作为基准\r\n    $base_num = $arr[0];\r\n    //遍历除了标尺外的所有元素，按照大小关系放入两个数组内\r\n    //初始化两个数组\r\n    $left_array = array(); //小于基准的\r\n    $right_array = array(); //大于基准的\r\n    for($i=1; $i&lt;$length; $i++) {\r\n        if($base_num &gt; $arr[$i]) {\r\n            //放入左边数组\r\n            $left_array[] = $arr[$i];\r\n        } else {\r\n            //放入右边\r\n            $right_array[] = $arr[$i];\r\n        }\r\n    }\r\n\r\n    //再分别对左边和右边的数组进行相同的排序处理方式递归调用这个函数\r\n    $left_array = quick_sort($left_array);\r\n    $right_array = quick_sort($right_array);\r\n\r\n    //合并\r\n    return array_merge($left_array, array($base_num), $right_array);\r\n}\r\n</code></pre>\r\n<h2 id=\"h2-4-3-\"><a name=\"4.3 理解\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.3 理解</h2><p>假设有10个数：</p>\r\n<pre><code>小于拿出                                拿出            大于拿出\r\n***                                        *            ******\r\n小于拿出    再拿出        大于拿出    |    之前拿出    |    小于拿出    再拿出    大于拿出\r\n    *        *            *        |        *        |    **            *        ***\r\n… …\r\n… …\r\n</code></pre><p>如此循环直到最后全部拆开，再合起来，排序完成。</p>\r\n<pre><code>**********\r\n</code></pre><h1 id=\"h1-5-\"><a name=\"5. 总结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5. 总结</h1><ul>\r\n<li>冒泡排序： 逐渐筛选出最大值</li><li>选择排序：逐渐筛选出最小值</li><li>插入排序：按顺序一个一个取出进行排序</li><li>快速排序：逐渐递归拆分进行排序，直至全部拆分排序完成</li></ul>\r\n', '', 0, 'publish', 1, 0, '/article/21.html', '', 0, 91, '2016-10-12 15:42:56', '2016-10-12 15:42:56', '2018-01-08 04:13:17', NULL);
INSERT INTO `pt_post` VALUES (22, 10, 'article', '《高性能MySQL》学习笔记1——MySQL架构', '这是通读《高性能MySQL》（第三版）的第一篇笔记，这本书真的是一本不可多得的好书，光是第一章就解决了一些我一直以来的疑惑，估计学完会有和不小的收获。\r\n\r\n第一章是MySQL的架构与历史，本章收获：\r\n- 认识MySQL的架构；\r\n- 认识“锁”；\r\n- 系统认识事务的原理；\r\n- 认识MySQL的存储引擎；\r\n- 如何选择合适的存储引擎等。\r\n\r\n其中，InnoDB存储引擎和MyISAM引擎的区别以及如何选择是我之前一直还未了解但是必须了解的问题，通过这章内容也有了一定的认识。（笔记只记下来觉得非常有用的一些知识点作为回顾整理再者方便以后查阅，详情还是看原书。）\r\n\r\n# 1.1 MySQL逻辑架构\r\nMySQL的服务器逻辑架构图：\r\n![](https://www.goozp.com/uploads/2018/01/mysql_jiagou.jpg)\r\n\r\n# 1.2 并发控制\r\n## 读写锁\r\n在处理并发读或者是写时，可以通过实现一个由两种类型的锁组成的锁系统来解决问题。这两个类型的锁通常被称为**共享锁（shared lock）**和**排他锁（exclusive lock）**，也叫**读锁（read lock）**和**写锁（write lock）**。\r\n\r\n读锁是共享的，或者说是相互不阻塞的。多个用户在同一时刻可以同时读取同一个资源，而互不干扰。\r\n\r\n写锁则是排他的，也就是说一个写锁会阻塞其它的写锁和读锁，这是出于安全策略的考虑，只有这样，才能确保在给定的时间里，只有一个用户能执行写入，并防止其他用户读取正在写入的同一资源。\r\n\r\n## 锁策略\r\n锁策略：在锁的开销和数据的安全性之间寻求平衡，这种平衡当然也会影响到性能。\r\n\r\n两种最重要的锁策略：\r\n\r\n**表锁（table lock）**\r\n表锁是MySQL中最基本的锁策略，并且是开销最小的策略。表锁锁定整张表。\r\n\r\n**行级锁（row lock）**\r\n行级锁可以最大程度地支持并发处理（同时也带来了最大的锁开销）。InnoDB和XtraDB（用来代替InnoDB的InnoDB增强版），以及一些其他的存储引擎中实现了行级锁。行级锁只在存储引擎层实现。\r\n\r\n# 1.3 事务\r\n事务就是一组原子性的SQL查询，或者说一个独立的工作单元。如果数据库引擎能够成功地对数据库应用该组查询的全部语句，那么就执行该组查询。如果其中有任何一条语句因为崩溃或者其他原因无法执行，那么所有的语句都不会执行。事务内的语句，要么全部执行成功，要么全部执行失败。\r\n\r\n事务SQL例子：\r\n```sql\r\nSTART TRANSACTION;\r\n\r\nSELECT balance FROM checking WHERE customer_id=10233276;\r\n\r\nUPDATE checking SET balance = balance - 200.00 WHERE customer_id = 10233276;\r\n\r\nUPDATE saving SET balance = balance + 200.00 WHERE customer_id = 10233276;\r\n\r\nCOMMIT;\r\n```\r\n\r\n一个运行良好的事务处理系统，必须具备ACID特征。\r\n\r\n## ACID\r\n\r\nACID表示**原子性（atomicity）**、**一致性（consistency）**、**隔离性（isolation）**和**持久性（durability）**。\r\n\r\n- 原子性\r\n整个事务中的所有操作要么全部提交成功，要么全部失败回滚。对于一个事务来说，不可能只执行其中一部分操作，这就是事务的原子性。\r\n\r\n- 一致性\r\n数据库总是从一个一致性的状态转换到另一个一致性的状态。一致性确保了事务执行到一半时系统崩溃，但是事务最终没有提交，所以数据中所做的修改也不会保存的数据库中。\r\n\r\n- 隔离性\r\n通常来说（隔离级别），一个事务所做的修改在最终提交之前，对其他事务是不可见的。\r\n\r\n- 持久性\r\n一旦事务提交，则其所做的修改就会永久保存到数据库中。此时即使系统崩溃，修改的数据也不会丢失。\r\n\r\n一个实现了ACID的数据库，相比没有实现ACID的数据库，通常会需要更强的CPU处理能力、更大的内存和更多的磁盘空间。用户可以根据业务是否需要事务处理，来选择合适的存储引擎。**对于一些不需要事务的查询类应用，选择一个非事务型的存储引擎，可以获得更高的性能。**即使存储引擎不支持事务，也可以通过LOCK TABLES语句为应用提供一定程度的保护，这些选择用户都可以自主决定。\r\n\r\n## 隔离级别\r\n![](https://www.goozp.com/uploads/2018/01/mysql_geli.jpg)\r\n\r\n**四种隔离级别：**\r\n\r\n- READ UNCOMMITTED（未提交读）\r\n事务中的修改，即使没有提交，对其他事务也都是可见的。事务可以读取未提交的数据，这也被称为脏读（Dirty Read）。\r\n\r\n- READ COMMITTED（提交读）\r\n一个事务开始时，只能”看见“已经提交的事务所做的修改。换句话说，一个 事务从开始直到提交前，所做的任何修改对其他事务都是不可见的。这个级别有时候也叫做不可重读读。\r\n\r\n- REPEATABLE READ（可重复读）\r\n解决了脏读的问题。保证了在同一个事务中多次读取同样记录的结果是一致的。但是理论上，可重复读隔离级别还是无法解决另外一个幻读的问题。幻读，指的是当某个事务在读取某个范围内的记录时，另外一个事务又插入了新的记录，当之前的事务再次读取该范围的记录时，会产生幻行。InnoDB和XtraDB存储引擎通过多版本并发控制（MVCC）解决了幻读的问题。\r\n\r\n- SERIALIZALE（可串行化）\r\n最高隔离级别。会在读取的每一行数据都加上锁，所以可能导致大量的超时和锁争用的问题。只有在非常需要确保数据的一致性而且可以接受没有并发控制的情况下，才考虑采用该级别。\r\n\r\n## 死锁\r\n死锁是指两个或者多个事务在同一个资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象。当多个事务视图以不同的的顺序锁定资源时，就可能会产生死锁。\r\n\r\n两个对方都等待对方释放锁，同时又持有对方需要的锁，则陷入死循环。除非有外部因素介入才可能解除死锁。\r\n\r\n为了解决这种问题，数据库系统实现了各种死锁检测和死锁超时机制。InnoDB目前处理死锁的方法是，将持有的最少行级排他锁的事务进行回滚（这是比较简单的死锁回滚方法）。\r\n\r\n死锁的产生有双重原因：有些是因为真正的数据冲突，这种情况通常很难避免，但有些则完全是由于存储引擎的实现方式导致的。\r\n\r\n## MySQL中的事务\r\nMySQL的两种事务型存储引擎：InnoDB和NDB Cluster。\r\n\r\n### 自动提交（AUTOCOMMIT）\r\nMySQL默认采用自动提交模式。如果不是显式地开始一个事务，每一个查询都被当作一个事务执行提交操作。在当前链接中可以设置AUTOCOMMIT变量来启用或者禁用自动提交模式：\r\n```sql\r\nmysql>SHOW VARIABLES LIKE \'AUTOCOMMIT\';\r\n\r\nmysql>SET AUTOCOMMIT = 1;\r\n```\r\n1或者ON表示启用，0或者OFF表示禁用。当AUTOCOMMIT=0时，所有的查询都是在一个事务中，直到显式地执行COMMMIT或者ROLLBACK回滚，该事务结束，同时又开始了另一个新事务。\r\n\r\n修改AUTOCOMMIT对非事务型的表，比如MyISAM或者内存表，不会有任何影响。对这类表来说，没有COMMMIT或者ROLLBACK的概念，也就是说可以相当于一直处于AUTOCOMMIT启用的模式。\r\n\r\nMySQL可以通过执行SET TRANSACTION ISOLATION LEVEL命令来设置隔离级别。新的隔离级别会在下一个事务开始的时候生效。可以在配置文件中设置整个数据库的隔离级别，也可以只改变当前会话的隔离级别：\r\n```\r\nmysql>SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;\r\n```\r\n\r\n### 在事务中混合使用存储引擎\r\nMySQL服务层不管理事务，事务是由下层的存储引擎实现的。\r\n\r\n如果事务中混合使用了事务型和非事务型的表，在正常提交的情况下不会有什么问题。\r\n\r\n但是如果事务需要回滚，非事务型的表上的表更就无法撤销。\r\n\r\n为每张表选择合适的存储引擎非常重要。\r\n\r\n### 隐式和显式锁定\r\n隐式锁定：存储引擎自动进行的锁定\r\n\r\n显式锁定：通过LOCK TABLES等语句进行锁定\r\n\r\n建议：除了事务中禁用了AUTOCOMMIT，可以使用LOCK TABLES之外，其他任何时候都不要显式地执行LOCK TABLES，不管使用的是什么存储引擎。\r\n\r\n# 1.4 多版本并发控制（MVCC）\r\nMVCC的实现，是通过保存数据在某个时间点的快照来实现的。\r\n\r\nInnoDB的MVCC，是通过在每行记录的后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存行的过期时间（或删除时间）。当然存储的并不是实际的时间值，而是系统版本号。保存这两个额外的系统版本号，使大多数读操作都可以不用加锁。\r\n\r\nMVCC只在REPEATABLE READ和READ COMMITTED两个隔离级别下工作。\r\n\r\n# 1.5 MySQL的存储引擎\r\n## InnoDB存储引擎\r\nInnoDB采用MVCC来支持高并发，并且实现了四个标准的隔离级别。其默认级别是REPEATABLE READ（可重复读），并且通过间隙锁（next-key locking）策略防止幻读的出现。间隙锁使得InnoDB不仅仅锁定查询设计的行，还会对索引中的间隙进行锁定，以防止幻影行的插入。\r\n\r\nInnoDB的表是基于聚簇索引建立的。InnoDB的索引结构和MySQL其他存储引擎有很大的不同，聚簇索引对主键查询有很高的性能。\r\n\r\n作为事务型的存储引擎，InnoDB通过一些机制和工具支持真正的热备份。\r\n\r\nMySQL的其他存储引擎不支持热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。\r\n\r\n## MyISAM存储引擎\r\nMyISAM提供了大量的特性，包括全文索引、压缩、空间函数（GIS）等，但**MyISAM不支持事务和行级锁，而且有一个毫无疑问的缺陷就是崩溃后无法安全恢复**。\r\n\r\n对于只读的数据，或者表比较小、可以忍受修复操作，则依然可以继续使用MyISAM（但请不要默认使用MyISAM，而是应当默认使用InnoDB）。\r\n\r\n### MyISAM特性\r\n加锁与并发：对整张表加锁，而不是针对行。在表有读取查询时，也可以往表中插入新的记录（并发插入）。\r\n\r\n修复（和事务恢复以及崩溃恢复不是一个概念）：手工或者自动执行检查和修复操作。通过CHECK TABLE mytable检查表的错误，如果有错误可以通过执行REPAIR TABLE mytable进行修复。\r\n\r\n索引特性：即使是BLOB和TEXT等长字段，也可以基于其前500个字符创建索引。MyISAM也支持全文索引。\r\n\r\n延迟更新索引键（Delayed Key Write）：创建表的时候如果指定了DELAY_KEY_WRITE选项，在每次修改执行完成时，不会立刻将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入到磁盘。\r\n\r\n### MyISAM压缩表\r\n可以使用myisampack对MyISAM表进行压缩。压缩表可以极大地减少磁盘空间占用，也可以减少磁盘I/O，从而提升查询性能。\r\n\r\n### MyISAM性能\r\nMyISAM最典型的问题还是表锁的问题，如果你发现所有的查询都查询都长期处于“Locked”\r\n状态，那么毫无疑问表锁就是罪魁祸首。\r\n\r\n## MySQL内建的其他存储引擎\r\n- Archive引擎：不是一个事务型引擎，而是一个针对告诉插入和压缩做了优化的简单引擎。\r\n- Blackhole引擎\r\n- CSV引擎：可以将Excel等电子表格软件中的数据存储为CSV文件，然后复制到MySQL数据目录下，就能在MySQL中打开使用。\r\n- Memory引擎：所有数据保存在内存中，不需要进行磁盘I/O。Memory是表级锁，所以并发写入性能较低。\r\n- Merge引擎\r\n- NDB集群引擎：MySQL服务器、NDB集群存储引擎，以及分布式的、share-nothing的、容灾的、高可用的NDB数据库的组合，被称为MySQL集群（MySQL Cluster）。\r\n\r\n## 第三方存储引擎\r\nPercona的XtraDB存储引擎是基于InnoDB引擎的一个改进版本。\r\n\r\n## 选择合适的引擎\r\n除非需要用到某些InnoDB不具备的特性，并且没有其他的办法可以替代，否则都应该**优先选择InnoDB引擎**。\r\n\r\n例如：如果要用到全文索引，建议优先考虑InnoDB+Sphinx的组合，而不是使用支持全文索引的MyISAM。\r\n\r\n除非万不得已，否则**建议不要混合使用多种存储引擎**，否则可能带来一列复杂的问题，以及一些潜在的bug和边界问题。至少，混合存储对一致性备份和服务器参数配置都带来了一些困难。\r\n\r\n选择引擎时需要考虑的因素：事务、备份、奔溃恢复、特有的特性\r\n\r\n**不要轻易相信“MyISAM比InnoDB快”之类的经验之谈，这个结论往往不是绝对的**。\r\n\r\n如果涉及订单处理，那么支持事务就是必要选项。\r\n\r\n## 转换表的引擎\r\n### 1. ALTER TABLE\r\n```\r\nmysql> ALTER TABLE mytable ENGINE = InnoDB;\r\n```\r\n缺点：需要执行很长时间；复制期间消耗系统所有的I/O能力；原表上会加上读锁。\r\n\r\n### 2. 导入与导出\r\n使用mysqldump工具将数据导出到文件，然后修改文件中CREATE TABLE语句的存储引擎选项，注意同时修改表名。\r\n\r\n### 3. 创建与查询（CREATE 和 SELECT）\r\n综合了前两种方法的高效和安全。创建一个新的存储引擎的表，然后利用INSERT···SELECT语法来导数据：\r\n```\r\nmysql>CREATE TABLE innno_table LIKE myisam_table;\r\n\r\nmysql>ALTER TABLE innodb_table ENGINE=InnoDB;\r\n\r\nmysql>INSERT INTO innodb_table SELECT * FROM myisam_table;\r\n```\r\n数据量很大时，可以用事务分批处理：\r\n```\r\nmysql> START TRANSACTION;\r\n\r\nmysql> INSERT INTO innodb_table SELECT * FROM myisam_table\r\n\r\n-> WHERE id BETWEEN x AND y;\r\n\r\nmysql> COMMIT;\r\n```\r\n如果有必要，可以在执行的过程中对原表加锁，以确保新表和原表的数据一致。', '<p>这是通读《高性能MySQL》（第三版）的第一篇笔记，这本书真的是一本不可多得的好书，光是第一章就解决了一些我一直以来的疑惑，估计学完会有和不小的收获。</p>\r\n<p>第一章是MySQL的架构与历史，本章收获：</p>\r\n<ul>\r\n<li>认识MySQL的架构；</li><li>认识“锁”；</li><li>系统认识事务的原理；</li><li>认识MySQL的存储引擎；</li><li>如何选择合适的存储引擎等。</li></ul>\r\n<p>其中，InnoDB存储引擎和MyISAM引擎的区别以及如何选择是我之前一直还未了解但是必须了解的问题，通过这章内容也有了一定的认识。（笔记只记下来觉得非常有用的一些知识点作为回顾整理再者方便以后查阅，详情还是看原书。）</p>\r\n<h1 id=\"h1-1-1-mysql-\"><a name=\"1.1 MySQL逻辑架构\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.1 MySQL逻辑架构</h1><p>MySQL的服务器逻辑架构图：<br><img src=\"https://www.goozp.com/uploads/2018/01/mysql_jiagou.jpg\" alt=\"\"></p>\r\n<h1 id=\"h1-1-2-\"><a name=\"1.2 并发控制\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.2 并发控制</h1><h2 id=\"h2-u8BFBu5199u9501\"><a name=\"读写锁\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>读写锁</h2><p>在处理并发读或者是写时，可以通过实现一个由两种类型的锁组成的锁系统来解决问题。这两个类型的锁通常被称为<strong>共享锁（shared lock）</strong>和<strong>排他锁（exclusive lock）</strong>，也叫<strong>读锁（read lock）</strong>和<strong>写锁（write lock）</strong>。</p>\r\n<p>读锁是共享的，或者说是相互不阻塞的。多个用户在同一时刻可以同时读取同一个资源，而互不干扰。</p>\r\n<p>写锁则是排他的，也就是说一个写锁会阻塞其它的写锁和读锁，这是出于安全策略的考虑，只有这样，才能确保在给定的时间里，只有一个用户能执行写入，并防止其他用户读取正在写入的同一资源。</p>\r\n<h2 id=\"h2-u9501u7B56u7565\"><a name=\"锁策略\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>锁策略</h2><p>锁策略：在锁的开销和数据的安全性之间寻求平衡，这种平衡当然也会影响到性能。</p>\r\n<p>两种最重要的锁策略：</p>\r\n<p><strong>表锁（table lock）</strong><br>表锁是MySQL中最基本的锁策略，并且是开销最小的策略。表锁锁定整张表。</p>\r\n<p><strong>行级锁（row lock）</strong><br>行级锁可以最大程度地支持并发处理（同时也带来了最大的锁开销）。InnoDB和XtraDB（用来代替InnoDB的InnoDB增强版），以及一些其他的存储引擎中实现了行级锁。行级锁只在存储引擎层实现。</p>\r\n<h1 id=\"h1-1-3-\"><a name=\"1.3 事务\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.3 事务</h1><p>事务就是一组原子性的SQL查询，或者说一个独立的工作单元。如果数据库引擎能够成功地对数据库应用该组查询的全部语句，那么就执行该组查询。如果其中有任何一条语句因为崩溃或者其他原因无法执行，那么所有的语句都不会执行。事务内的语句，要么全部执行成功，要么全部执行失败。</p>\r\n<p>事务SQL例子：</p>\r\n<pre><code class=\"lang-sql\">START TRANSACTION;\r\n\r\nSELECT balance FROM checking WHERE customer_id=10233276;\r\n\r\nUPDATE checking SET balance = balance - 200.00 WHERE customer_id = 10233276;\r\n\r\nUPDATE saving SET balance = balance + 200.00 WHERE customer_id = 10233276;\r\n\r\nCOMMIT;\r\n</code></pre>\r\n<p>一个运行良好的事务处理系统，必须具备ACID特征。</p>\r\n<h2 id=\"h2-acid\"><a name=\"ACID\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>ACID</h2><p>ACID表示<strong>原子性（atomicity）</strong>、<strong>一致性（consistency）</strong>、<strong>隔离性（isolation）</strong>和<strong>持久性（durability）</strong>。</p>\r\n<ul>\r\n<li><p>原子性<br>整个事务中的所有操作要么全部提交成功，要么全部失败回滚。对于一个事务来说，不可能只执行其中一部分操作，这就是事务的原子性。</p>\r\n</li><li><p>一致性<br>数据库总是从一个一致性的状态转换到另一个一致性的状态。一致性确保了事务执行到一半时系统崩溃，但是事务最终没有提交，所以数据中所做的修改也不会保存的数据库中。</p>\r\n</li><li><p>隔离性<br>通常来说（隔离级别），一个事务所做的修改在最终提交之前，对其他事务是不可见的。</p>\r\n</li><li><p>持久性<br>一旦事务提交，则其所做的修改就会永久保存到数据库中。此时即使系统崩溃，修改的数据也不会丢失。</p>\r\n</li></ul>\r\n<p>一个实现了ACID的数据库，相比没有实现ACID的数据库，通常会需要更强的CPU处理能力、更大的内存和更多的磁盘空间。用户可以根据业务是否需要事务处理，来选择合适的存储引擎。<strong>对于一些不需要事务的查询类应用，选择一个非事务型的存储引擎，可以获得更高的性能。</strong>即使存储引擎不支持事务，也可以通过LOCK TABLES语句为应用提供一定程度的保护，这些选择用户都可以自主决定。</p>\r\n<h2 id=\"h2-u9694u79BBu7EA7u522B\"><a name=\"隔离级别\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>隔离级别</h2><p><img src=\"https://www.goozp.com/uploads/2018/01/mysql_geli.jpg\" alt=\"\"></p>\r\n<p><strong>四种隔离级别：</strong></p>\r\n<ul>\r\n<li><p>READ UNCOMMITTED（未提交读）<br>事务中的修改，即使没有提交，对其他事务也都是可见的。事务可以读取未提交的数据，这也被称为脏读（Dirty Read）。</p>\r\n</li><li><p>READ COMMITTED（提交读）<br>一个事务开始时，只能”看见“已经提交的事务所做的修改。换句话说，一个 事务从开始直到提交前，所做的任何修改对其他事务都是不可见的。这个级别有时候也叫做不可重读读。</p>\r\n</li><li><p>REPEATABLE READ（可重复读）<br>解决了脏读的问题。保证了在同一个事务中多次读取同样记录的结果是一致的。但是理论上，可重复读隔离级别还是无法解决另外一个幻读的问题。幻读，指的是当某个事务在读取某个范围内的记录时，另外一个事务又插入了新的记录，当之前的事务再次读取该范围的记录时，会产生幻行。InnoDB和XtraDB存储引擎通过多版本并发控制（MVCC）解决了幻读的问题。</p>\r\n</li><li><p>SERIALIZALE（可串行化）<br>最高隔离级别。会在读取的每一行数据都加上锁，所以可能导致大量的超时和锁争用的问题。只有在非常需要确保数据的一致性而且可以接受没有并发控制的情况下，才考虑采用该级别。</p>\r\n</li></ul>\r\n<h2 id=\"h2-u6B7Bu9501\"><a name=\"死锁\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>死锁</h2><p>死锁是指两个或者多个事务在同一个资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象。当多个事务视图以不同的的顺序锁定资源时，就可能会产生死锁。</p>\r\n<p>两个对方都等待对方释放锁，同时又持有对方需要的锁，则陷入死循环。除非有外部因素介入才可能解除死锁。</p>\r\n<p>为了解决这种问题，数据库系统实现了各种死锁检测和死锁超时机制。InnoDB目前处理死锁的方法是，将持有的最少行级排他锁的事务进行回滚（这是比较简单的死锁回滚方法）。</p>\r\n<p>死锁的产生有双重原因：有些是因为真正的数据冲突，这种情况通常很难避免，但有些则完全是由于存储引擎的实现方式导致的。</p>\r\n<h2 id=\"h2-mysql-\"><a name=\"MySQL中的事务\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>MySQL中的事务</h2><p>MySQL的两种事务型存储引擎：InnoDB和NDB Cluster。</p>\r\n<h3 id=\"h3--autocommit-\"><a name=\"自动提交（AUTOCOMMIT）\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>自动提交（AUTOCOMMIT）</h3><p>MySQL默认采用自动提交模式。如果不是显式地开始一个事务，每一个查询都被当作一个事务执行提交操作。在当前链接中可以设置AUTOCOMMIT变量来启用或者禁用自动提交模式：</p>\r\n<pre><code class=\"lang-sql\">mysql&gt;SHOW VARIABLES LIKE &#39;AUTOCOMMIT&#39;;\r\n\r\nmysql&gt;SET AUTOCOMMIT = 1;\r\n</code></pre>\r\n<p>1或者ON表示启用，0或者OFF表示禁用。当AUTOCOMMIT=0时，所有的查询都是在一个事务中，直到显式地执行COMMMIT或者ROLLBACK回滚，该事务结束，同时又开始了另一个新事务。</p>\r\n<p>修改AUTOCOMMIT对非事务型的表，比如MyISAM或者内存表，不会有任何影响。对这类表来说，没有COMMMIT或者ROLLBACK的概念，也就是说可以相当于一直处于AUTOCOMMIT启用的模式。</p>\r\n<p>MySQL可以通过执行SET TRANSACTION ISOLATION LEVEL命令来设置隔离级别。新的隔离级别会在下一个事务开始的时候生效。可以在配置文件中设置整个数据库的隔离级别，也可以只改变当前会话的隔离级别：</p>\r\n<pre><code>mysql&gt;SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;\r\n</code></pre><h3 id=\"h3-u5728u4E8Bu52A1u4E2Du6DF7u5408u4F7Fu7528u5B58u50A8u5F15u64CE\"><a name=\"在事务中混合使用存储引擎\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>在事务中混合使用存储引擎</h3><p>MySQL服务层不管理事务，事务是由下层的存储引擎实现的。</p>\r\n<p>如果事务中混合使用了事务型和非事务型的表，在正常提交的情况下不会有什么问题。</p>\r\n<p>但是如果事务需要回滚，非事务型的表上的表更就无法撤销。</p>\r\n<p>为每张表选择合适的存储引擎非常重要。</p>\r\n<h3 id=\"h3-u9690u5F0Fu548Cu663Eu5F0Fu9501u5B9A\"><a name=\"隐式和显式锁定\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>隐式和显式锁定</h3><p>隐式锁定：存储引擎自动进行的锁定</p>\r\n<p>显式锁定：通过LOCK TABLES等语句进行锁定</p>\r\n<p>建议：除了事务中禁用了AUTOCOMMIT，可以使用LOCK TABLES之外，其他任何时候都不要显式地执行LOCK TABLES，不管使用的是什么存储引擎。</p>\r\n<h1 id=\"h1-1-4-mvcc-\"><a name=\"1.4 多版本并发控制（MVCC）\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.4 多版本并发控制（MVCC）</h1><p>MVCC的实现，是通过保存数据在某个时间点的快照来实现的。</p>\r\n<p>InnoDB的MVCC，是通过在每行记录的后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存行的过期时间（或删除时间）。当然存储的并不是实际的时间值，而是系统版本号。保存这两个额外的系统版本号，使大多数读操作都可以不用加锁。</p>\r\n<p>MVCC只在REPEATABLE READ和READ COMMITTED两个隔离级别下工作。</p>\r\n<h1 id=\"h1-1-5-mysql-\"><a name=\"1.5 MySQL的存储引擎\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.5 MySQL的存储引擎</h1><h2 id=\"h2-innodb-\"><a name=\"InnoDB存储引擎\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>InnoDB存储引擎</h2><p>InnoDB采用MVCC来支持高并发，并且实现了四个标准的隔离级别。其默认级别是REPEATABLE READ（可重复读），并且通过间隙锁（next-key locking）策略防止幻读的出现。间隙锁使得InnoDB不仅仅锁定查询设计的行，还会对索引中的间隙进行锁定，以防止幻影行的插入。</p>\r\n<p>InnoDB的表是基于聚簇索引建立的。InnoDB的索引结构和MySQL其他存储引擎有很大的不同，聚簇索引对主键查询有很高的性能。</p>\r\n<p>作为事务型的存储引擎，InnoDB通过一些机制和工具支持真正的热备份。</p>\r\n<p>MySQL的其他存储引擎不支持热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。</p>\r\n<h2 id=\"h2-myisam-\"><a name=\"MyISAM存储引擎\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>MyISAM存储引擎</h2><p>MyISAM提供了大量的特性，包括全文索引、压缩、空间函数（GIS）等，但<strong>MyISAM不支持事务和行级锁，而且有一个毫无疑问的缺陷就是崩溃后无法安全恢复</strong>。</p>\r\n<p>对于只读的数据，或者表比较小、可以忍受修复操作，则依然可以继续使用MyISAM（但请不要默认使用MyISAM，而是应当默认使用InnoDB）。</p>\r\n<h3 id=\"h3-myisam-\"><a name=\"MyISAM特性\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>MyISAM特性</h3><p>加锁与并发：对整张表加锁，而不是针对行。在表有读取查询时，也可以往表中插入新的记录（并发插入）。</p>\r\n<p>修复（和事务恢复以及崩溃恢复不是一个概念）：手工或者自动执行检查和修复操作。通过CHECK TABLE mytable检查表的错误，如果有错误可以通过执行REPAIR TABLE mytable进行修复。</p>\r\n<p>索引特性：即使是BLOB和TEXT等长字段，也可以基于其前500个字符创建索引。MyISAM也支持全文索引。</p>\r\n<p>延迟更新索引键（Delayed Key Write）：创建表的时候如果指定了DELAY_KEY_WRITE选项，在每次修改执行完成时，不会立刻将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入到磁盘。</p>\r\n<h3 id=\"h3-myisam-\"><a name=\"MyISAM压缩表\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>MyISAM压缩表</h3><p>可以使用myisampack对MyISAM表进行压缩。压缩表可以极大地减少磁盘空间占用，也可以减少磁盘I/O，从而提升查询性能。</p>\r\n<h3 id=\"h3-myisam-\"><a name=\"MyISAM性能\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>MyISAM性能</h3><p>MyISAM最典型的问题还是表锁的问题，如果你发现所有的查询都查询都长期处于“Locked”<br>状态，那么毫无疑问表锁就是罪魁祸首。</p>\r\n<h2 id=\"h2-mysql-\"><a name=\"MySQL内建的其他存储引擎\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>MySQL内建的其他存储引擎</h2><ul>\r\n<li>Archive引擎：不是一个事务型引擎，而是一个针对告诉插入和压缩做了优化的简单引擎。</li><li>Blackhole引擎</li><li>CSV引擎：可以将Excel等电子表格软件中的数据存储为CSV文件，然后复制到MySQL数据目录下，就能在MySQL中打开使用。</li><li>Memory引擎：所有数据保存在内存中，不需要进行磁盘I/O。Memory是表级锁，所以并发写入性能较低。</li><li>Merge引擎</li><li>NDB集群引擎：MySQL服务器、NDB集群存储引擎，以及分布式的、share-nothing的、容灾的、高可用的NDB数据库的组合，被称为MySQL集群（MySQL Cluster）。</li></ul>\r\n<h2 id=\"h2-u7B2Cu4E09u65B9u5B58u50A8u5F15u64CE\"><a name=\"第三方存储引擎\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>第三方存储引擎</h2><p>Percona的XtraDB存储引擎是基于InnoDB引擎的一个改进版本。</p>\r\n<h2 id=\"h2-u9009u62E9u5408u9002u7684u5F15u64CE\"><a name=\"选择合适的引擎\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>选择合适的引擎</h2><p>除非需要用到某些InnoDB不具备的特性，并且没有其他的办法可以替代，否则都应该<strong>优先选择InnoDB引擎</strong>。</p>\r\n<p>例如：如果要用到全文索引，建议优先考虑InnoDB+Sphinx的组合，而不是使用支持全文索引的MyISAM。</p>\r\n<p>除非万不得已，否则<strong>建议不要混合使用多种存储引擎</strong>，否则可能带来一列复杂的问题，以及一些潜在的bug和边界问题。至少，混合存储对一致性备份和服务器参数配置都带来了一些困难。</p>\r\n<p>选择引擎时需要考虑的因素：事务、备份、奔溃恢复、特有的特性</p>\r\n<p><strong>不要轻易相信“MyISAM比InnoDB快”之类的经验之谈，这个结论往往不是绝对的</strong>。</p>\r\n<p>如果涉及订单处理，那么支持事务就是必要选项。</p>\r\n<h2 id=\"h2-u8F6Cu6362u8868u7684u5F15u64CE\"><a name=\"转换表的引擎\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>转换表的引擎</h2><h3 id=\"h3-1-alter-table\"><a name=\"1. ALTER TABLE\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1. ALTER TABLE</h3><pre><code>mysql&gt; ALTER TABLE mytable ENGINE = InnoDB;\r\n</code></pre><p>缺点：需要执行很长时间；复制期间消耗系统所有的I/O能力；原表上会加上读锁。</p>\r\n<h3 id=\"h3-2-\"><a name=\"2. 导入与导出\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2. 导入与导出</h3><p>使用mysqldump工具将数据导出到文件，然后修改文件中CREATE TABLE语句的存储引擎选项，注意同时修改表名。</p>\r\n<h3 id=\"h3-3-create-select-\"><a name=\"3. 创建与查询（CREATE 和 SELECT）\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3. 创建与查询（CREATE 和 SELECT）</h3><p>综合了前两种方法的高效和安全。创建一个新的存储引擎的表，然后利用INSERT···SELECT语法来导数据：</p>\r\n<pre><code>mysql&gt;CREATE TABLE innno_table LIKE myisam_table;\r\n\r\nmysql&gt;ALTER TABLE innodb_table ENGINE=InnoDB;\r\n\r\nmysql&gt;INSERT INTO innodb_table SELECT * FROM myisam_table;\r\n</code></pre><p>数据量很大时，可以用事务分批处理：</p>\r\n<pre><code>mysql&gt; START TRANSACTION;\r\n\r\nmysql&gt; INSERT INTO innodb_table SELECT * FROM myisam_table\r\n\r\n-&gt; WHERE id BETWEEN x AND y;\r\n\r\nmysql&gt; COMMIT;\r\n</code></pre><p>如果有必要，可以在执行的过程中对原表加锁，以确保新表和原表的数据一致。</p>\r\n', '', 0, 'publish', 1, 0, '/article/22.html', '', 0, 96, '2016-11-14 18:56:25', '2016-11-14 18:56:25', '2018-01-08 07:58:50', NULL);
INSERT INTO `pt_post` VALUES (23, 10, 'article', 'PHP加密技术', '# Md5()加密算法\r\n**方式**: 单向加密\r\n\r\n**语法**: md5(string $str [, bool $raw_output = false])\r\n$str:原始字符串\r\n$raw_output:如果可选的raw_output被设置为true, 那么md5报文摘要将以16字节长度的原始二进制格式返回. 返回以32位字符十六进制数字形式返回散列值\r\n\r\n**md5二次加密**: md5(md5($string, true))\r\n\r\n# Crypt()加密算法\r\n**方式**: 单向加密\r\n\r\n**语法**: string crypt(string $str[, string $salt]), 返回一个基于标准UNIX DES算法或系统上其它可用的替代算法的三列字符串\r\n$str: 需要加密的明文\r\n$salt: 加密时的干扰串,是编码更安全\r\n\r\n**注意**: 如果加密时没有加上这个$salt参数, 将随机生成一个干扰串, 否则刷新加密秘文不变\r\n\r\n**算法常量**:\r\n- [CRYPT_SALT_LENGTH]\r\n默认的加密长度。使用标准的 DES 加密，长度为 2\r\n- [CRYPT_STD_DES]\r\n基于标准 DES 算法的散列使用 “./0-9A-Za-z” 字符中的两个字符作为盐值。在盐值中使用非法的字符将导致 crypt() 失败。\r\n- [CRYPT_EXT_DES]\r\n扩展的基于 DES 算法的散列。其盐值为 9 个字符的字符串，由 1 个下划线后面跟着 4 字节循环次数和 4 字节盐值组成。它们被编码成可打印字符，每个字符 6 位，有效位最少的优先。0 到 63 被编码为 “./0-9A-Za-z”。在盐值中使用非法的字符将导致 crypt() 失败。\r\n- [CRYPT_MD5]\r\nMD5 散列使用一个以 $1$ 开始的 12 字符的字符串盐值。\r\n- [CRYPT_BLOWFISH]\r\nBlowfish 算法使用如下盐值：“$2a$”，一个两位 cost 参数，“$” 以及 64 位由 “./0-9A-Za-z” 中的字符组合而成的字符串。在盐值中使用此范围之外的字符将导致 crypt() 返回一个空字符串。两位 cost 参数是循环次数以 2 为底的对数，它的范围是 04-31，超出这个范围将导致 crypt() 失败。\r\n- CRYPT_SHA256\r\nSHA-256 算法使用一个以 $5$ 开头的 16 字符字符串盐值进行散列。如果盐值字符串以 “rounds=<N>$” 开头，N 的数字值将被用来指定散列循环的执行次数，这点很像 Blowfish 算法的 cost 参数。默认的循环次数是 5000，最小是 1000，最大是 999,999,999。超出这个范围的 N 将会被转换为最接近的值。\r\n- CRYPT_SHA512\r\nSHA-512 算法使用一个以 $6$ 开头的 16 字符字符串盐值进行散列。如果盐值字符串以 “rounds=<N>$” 开头，N 的数字值将被用来指定散列循环的执行次数，这点很像 Blowfish 算法的 cost 参数。默认的循环次数是 5000，最小是 1000，最大是 999,999,999。超出这个范围的 N 将会被转换为最接近的值。\r\n\r\n例:\r\n```php\r\nif(CRYPT_MD5){\r\n    echo \"MD5加密:\".crypt(\'something\',\'$1$somethin$\');\r\n}\r\n```\r\n\r\n# Sha1()加密算法\r\n**方式**: 单向加密\r\n\r\n**语法**: string sha1(string $str [, bool $raw_output=false]) 计算字符串的sha1散列值\r\n$str: 加密的字符串\r\n$raw_output: 如果可选的raw_output参数被设置为TRUE, 那么sha1摘要将以20字符长度的原始格式返回, 否则返回值是一个40字符串长度的十六进制数字.\r\n\r\n# URL编码加密技术\r\n**编码URL字符串**: urlencode(string $str)\r\n\r\n**解码已编码的URL字符串**: urldeocde(string $str)\r\n\r\n**编码规范**: 此字符串中除了-_.之外的所有非字母数字字符都将被替换成百分号(%)后跟两位十六进制数, 空格则编码为加号(+)\r\n\r\n**按照RFC1738对URL进行编码**: rawurlencode(string $str): 返回从字符串,把空格编码为%20\r\n**对已编码的字符串进行解码**: rawurldecode(string $str): 返回字符串, 此字符串中百分号%后跟两位十六进制的序列豆将被替换成原义字符\r\n\r\n**urlencode和rawurlencode的区别只在于空格.**\r\n\r\n# Base64编码加密技术\r\n**使用base64对data进行编码**: base64_encode(string $data)\r\n\r\n**对使用MIME base64编码的数据进行解码**: base64_decode(string $data[, $strict=false]); $strict:如果输入的数据超出了base64的字母表,则返回false.\r\nbase64编码的图片还可以直接放在<img>标签中显示:\r\n<img src=”data:image/jpeg;base64,编码字符串” alt=””/>\r\n<img src=”data:;base64,编码字符串” alt=””/>\r\n\r\n# 信息加密技术:\r\n## 1 单项散列加密:\r\n指通过不同输入的长度的信息进行散列计算, 得到固定长度的输出, 这个散列计算过程是单向的, 既不能对固定长度的输出进行计算从而活儿输出信息.\r\n\r\n## 2 对称散列加密\r\n指加密和解密的密匙是同一个密匙或者可以互相推算.\r\n\r\n## 3 非对称散列加密\r\n非对称加密和解密的密匙不是同一个密匙, 其中一个对外公开, 被称作公钥, 另一个只有所有者知道.\r\n', '<h1 id=\"h1-md5-\"><a name=\"Md5()加密算法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Md5()加密算法</h1><p><strong>方式</strong>: 单向加密</p>\r\n<p><strong>语法</strong>: md5(string $str [, bool $raw_output = false])<br>$str:原始字符串<br>$raw_output:如果可选的raw_output被设置为true, 那么md5报文摘要将以16字节长度的原始二进制格式返回. 返回以32位字符十六进制数字形式返回散列值</p>\r\n<p><strong>md5二次加密</strong>: md5(md5($string, true))</p>\r\n<h1 id=\"h1-crypt-\"><a name=\"Crypt()加密算法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Crypt()加密算法</h1><p><strong>方式</strong>: 单向加密</p>\r\n<p><strong>语法</strong>: string crypt(string $str[, string $salt]), 返回一个基于标准UNIX DES算法或系统上其它可用的替代算法的三列字符串<br>$str: 需要加密的明文<br>$salt: 加密时的干扰串,是编码更安全</p>\r\n<p><strong>注意</strong>: 如果加密时没有加上这个$salt参数, 将随机生成一个干扰串, 否则刷新加密秘文不变</p>\r\n<p><strong>算法常量</strong>:</p>\r\n<ul>\r\n<li>[CRYPT_SALT_LENGTH]<br>默认的加密长度。使用标准的 DES 加密，长度为 2</li><li>[CRYPT_STD_DES]<br>基于标准 DES 算法的散列使用 “./0-9A-Za-z” 字符中的两个字符作为盐值。在盐值中使用非法的字符将导致 crypt() 失败。</li><li>[CRYPT_EXT_DES]<br>扩展的基于 DES 算法的散列。其盐值为 9 个字符的字符串，由 1 个下划线后面跟着 4 字节循环次数和 4 字节盐值组成。它们被编码成可打印字符，每个字符 6 位，有效位最少的优先。0 到 63 被编码为 “./0-9A-Za-z”。在盐值中使用非法的字符将导致 crypt() 失败。</li><li>[CRYPT_MD5]<br>MD5 散列使用一个以 $1$ 开始的 12 字符的字符串盐值。</li><li>[CRYPT_BLOWFISH]<br>Blowfish 算法使用如下盐值：“$2a$”，一个两位 cost 参数，“$” 以及 64 位由 “./0-9A-Za-z” 中的字符组合而成的字符串。在盐值中使用此范围之外的字符将导致 crypt() 返回一个空字符串。两位 cost 参数是循环次数以 2 为底的对数，它的范围是 04-31，超出这个范围将导致 crypt() 失败。</li><li>CRYPT_SHA256<br>SHA-256 算法使用一个以 $5$ 开头的 16 字符字符串盐值进行散列。如果盐值字符串以 “rounds=&lt;N&gt;$” 开头，N 的数字值将被用来指定散列循环的执行次数，这点很像 Blowfish 算法的 cost 参数。默认的循环次数是 5000，最小是 1000，最大是 999,999,999。超出这个范围的 N 将会被转换为最接近的值。</li><li>CRYPT_SHA512<br>SHA-512 算法使用一个以 $6$ 开头的 16 字符字符串盐值进行散列。如果盐值字符串以 “rounds=&lt;N&gt;$” 开头，N 的数字值将被用来指定散列循环的执行次数，这点很像 Blowfish 算法的 cost 参数。默认的循环次数是 5000，最小是 1000，最大是 999,999,999。超出这个范围的 N 将会被转换为最接近的值。</li></ul>\r\n<p>例:</p>\r\n<pre><code class=\"lang-php\">if(CRYPT_MD5){\r\n    echo &quot;MD5加密:&quot;.crypt(&#39;something&#39;,&#39;$1$somethin$&#39;);\r\n}\r\n</code></pre>\r\n<h1 id=\"h1-sha1-\"><a name=\"Sha1()加密算法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Sha1()加密算法</h1><p><strong>方式</strong>: 单向加密</p>\r\n<p><strong>语法</strong>: string sha1(string $str [, bool $raw_output=false]) 计算字符串的sha1散列值<br>$str: 加密的字符串<br>$raw_output: 如果可选的raw_output参数被设置为TRUE, 那么sha1摘要将以20字符长度的原始格式返回, 否则返回值是一个40字符串长度的十六进制数字.</p>\r\n<h1 id=\"h1-url-\"><a name=\"URL编码加密技术\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>URL编码加密技术</h1><p><strong>编码URL字符串</strong>: urlencode(string $str)</p>\r\n<p><strong>解码已编码的URL字符串</strong>: urldeocde(string $str)</p>\r\n<p><strong>编码规范</strong>: 此字符串中除了-_.之外的所有非字母数字字符都将被替换成百分号(%)后跟两位十六进制数, 空格则编码为加号(+)</p>\r\n<p><strong>按照RFC1738对URL进行编码</strong>: rawurlencode(string $str): 返回从字符串,把空格编码为%20<br><strong>对已编码的字符串进行解码</strong>: rawurldecode(string $str): 返回字符串, 此字符串中百分号%后跟两位十六进制的序列豆将被替换成原义字符</p>\r\n<p><strong>urlencode和rawurlencode的区别只在于空格.</strong></p>\r\n<h1 id=\"h1-base64-\"><a name=\"Base64编码加密技术\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Base64编码加密技术</h1><p><strong>使用base64对data进行编码</strong>: base64_encode(string $data)</p>\r\n<p><strong>对使用MIME base64编码的数据进行解码</strong>: base64_decode(string $data[, $strict=false]); $strict:如果输入的数据超出了base64的字母表,则返回false.<br>base64编码的图片还可以直接放在&lt;img&gt;标签中显示:<br>&lt;img src=”data:image/jpeg;base64,编码字符串” alt=””/&gt;<br>&lt;img src=”data:;base64,编码字符串” alt=””/&gt;</p>\r\n<h1 id=\"h1--\"><a name=\"信息加密技术:\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>信息加密技术:</h1><h2 id=\"h2-1-\"><a name=\"1 单项散列加密:\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1 单项散列加密:</h2><p>指通过不同输入的长度的信息进行散列计算, 得到固定长度的输出, 这个散列计算过程是单向的, 既不能对固定长度的输出进行计算从而活儿输出信息.</p>\r\n<h2 id=\"h2-2-\"><a name=\"2 对称散列加密\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2 对称散列加密</h2><p>指加密和解密的密匙是同一个密匙或者可以互相推算.</p>\r\n<h2 id=\"h2-3-\"><a name=\"3 非对称散列加密\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3 非对称散列加密</h2><p>非对称加密和解密的密匙不是同一个密匙, 其中一个对外公开, 被称作公钥, 另一个只有所有者知道.</p>\r\n', '', 0, 'publish', 1, 0, '/article/23.html', 'https://www.goozp.com/uploads/2018/01/php_jiami.jpg', 0, 96, '2016-11-19 08:30:50', '2016-11-19 08:30:50', '2018-01-08 08:58:07', NULL);
INSERT INTO `pt_post` VALUES (24, 10, 'article', 'Linux定时任务crontab', '# 定时任务命令\r\n1. 定时任务服务提供crontab命令来设定服务\r\n2. crontab -e //编辑某个用户的cron服务\r\n3. crontab -l //列出某个用户cron服务的详细内容\r\n4. cron -r //删除某个用户的cron服务\r\n\r\n# 任务crontab格式\r\n| 分  |  小时 | 日  | 月  |  星期 | 命令  |\r\n| ------------ | ------------ | ------------ | ------------ | ------------ | ------------ |\r\n| *  | *  |  * |  * | *  |   |\r\n| 0-59  | 0-23  | 1-31  |  1-12 | 0-6  | command  |\r\n注意：“*”代表取值范围内的数字；“/”代表每，比如每分钟等。\r\n\r\n# 任务例子:\r\n`*/1 * * * * php /data/www/cron.php`\r\n意思是每分钟执行cron.php\r\n\r\n`50 7 * * * /sbin/sercive sshd start`\r\n意思是每天7:50开启ssh服务\r\n\r\n# crontab服务\r\n一般启动服务用`/sbin/service crond start`\r\n\r\n若是根用户的cron服务可以用 `udo service crond start`\r\n\r\n这里还是要注意下不同版本linux系统启动的服务的命令也不同\r\n\r\n# 服务是否已经运行\r\n`ps -ax | grep cron`\r\n', '<h1 id=\"h1-u5B9Au65F6u4EFBu52A1u547Du4EE4\"><a name=\"定时任务命令\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>定时任务命令</h1><ol>\r\n<li>定时任务服务提供crontab命令来设定服务</li><li>crontab -e //编辑某个用户的cron服务</li><li>crontab -l //列出某个用户cron服务的详细内容</li><li>cron -r //删除某个用户的cron服务</li></ol>\r\n<h1 id=\"h1--crontab-\"><a name=\"任务crontab格式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>任务crontab格式</h1><table>\r\n<thead>\r\n<tr>\r\n<th>分</th>\r\n<th>小时</th>\r\n<th>日</th>\r\n<th>月</th>\r\n<th>星期</th>\r\n<th>命令</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr>\r\n<td>*</td>\r\n<td>*</td>\r\n<td>*</td>\r\n<td>*</td>\r\n<td>*</td>\r\n<td></td>\r\n</tr>\r\n<tr>\r\n<td>0-59</td>\r\n<td>0-23</td>\r\n<td>1-31</td>\r\n<td>1-12</td>\r\n<td>0-6</td>\r\n<td>command</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<p>注意：“*”代表取值范围内的数字；“/”代表每，比如每分钟等。</p>\r\n<h1 id=\"h1--\"><a name=\"任务例子:\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>任务例子:</h1><p><code>*/1 * * * * php /data/www/cron.php</code><br>意思是每分钟执行cron.php</p>\r\n<p><code>50 7 * * * /sbin/sercive sshd start</code><br>意思是每天7:50开启ssh服务</p>\r\n<h1 id=\"h1-crontab-\"><a name=\"crontab服务\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>crontab服务</h1><p>一般启动服务用<code>/sbin/service crond start</code></p>\r\n<p>若是根用户的cron服务可以用 <code>udo service crond start</code></p>\r\n<p>这里还是要注意下不同版本linux系统启动的服务的命令也不同</p>\r\n<h1 id=\"h1-u670Du52A1u662Fu5426u5DF2u7ECFu8FD0u884C\"><a name=\"服务是否已经运行\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>服务是否已经运行</h1><p><code>ps -ax | grep cron</code></p>\r\n', '', 0, 'publish', 1, 0, '/article/24.html', '', 0, 81, '2016-11-24 16:35:08', '2016-11-24 16:35:08', '2018-01-08 17:33:22', NULL);
INSERT INTO `pt_post` VALUES (25, 10, 'article', 'JS复制指定id内容到粘贴板（Ctrl+C效果）', '最近捣鼓一个小问题，搞一个按钮，点击复制url到黏贴板，但是不是当前页面url，而是对应一个元素的url，且一个页面会有多个url。一开始找到一个方法，但是竟然只兼容IE浏览器，神奇了，竟然有只兼容IE的东西。后来发现一个zeroclipboard.js这个插件，但是怎么也搞不出那个效果，有点麻烦。\r\n\r\n最后翻到了一个js封装好的方法，有效！\r\n\r\n想要实现的一个效果是，下面html代码：\r\n```html\r\n<tr>\r\n <td>\r\n  <a id=\"copy_{$key}\" onclick=\"getUrl(\'{$key}\')\">复制文件链接</a>\r\n  <input id=\"file_{$key}\" value=\"{$file.file_url}\" style=\"margin-left: -9999px\"/>\r\n </td>\r\n</tr>\r\n```\r\n\r\n点击复制文件链接这个按钮，复制input框里的value值，是传进去的一个url；首先点击a标签会触发getUrl这个函数；传进去id用于找到对应的input然后取值（因为遍历了多个td，有许多个input框一一对应去取）。\r\n\r\n下面js代码：\r\n```js\r\n<script type=\"application/javascript\">\r\n    function getUrl(id) {\r\n        if (copyToClipboard(document.getElementById(\"file_\"+id))){\r\n            alert(\"成功复制到黏贴板！\");\r\n        }else{\r\n            alert(\"复制到黏贴板失败！\");\r\n        }\r\n    }\r\n\r\n    function copyToClipboard(elem) {\r\n        // create hidden text element, if it doesn\'t already exist\r\n        var targetId = \"_hiddenCopyText_\";\r\n        var isInput = elem.tagName === \"INPUT\" || elem.tagName === \"TEXTAREA\";\r\n        var origSelectionStart, origSelectionEnd;\r\n        if (isInput) {\r\n            // can just use the original source element for the selection and copy\r\n            target = elem;\r\n            origSelectionStart = elem.selectionStart;\r\n            origSelectionEnd = elem.selectionEnd;\r\n        } else {\r\n            // must use a temporary form element for the selection and copy\r\n            target = document.getElementById(targetId);\r\n            if (!target) {\r\n                var target = document.createElement(\"textarea\");\r\n                target.style.position = \"absolute\";\r\n                target.style.left = \"-9999px\";\r\n                target.style.top = \"0\";\r\n                target.id = targetId;\r\n                document.body.appendChild(target);\r\n            }\r\n            target.textContent = elem.textContent;\r\n        }\r\n        // select the content\r\n        var currentFocus = document.activeElement;\r\n        target.focus();\r\n        target.setSelectionRange(0, target.value.length);\r\n\r\n        // copy the selection\r\n        var succeed;\r\n        try {\r\n            succeed = document.execCommand(\"copy\");\r\n        } catch(e) {\r\n            succeed = false;\r\n        }\r\n        // restore original focus\r\n        if (currentFocus && typeof currentFocus.focus === \"function\") {\r\n            currentFocus.focus();\r\n        }\r\n\r\n        if (isInput) {\r\n            // restore prior selection\r\n            elem.setSelectionRange(origSelectionStart, origSelectionEnd);\r\n        } else {\r\n            // clear temporary content\r\n            target.textContent = \"\";\r\n        }\r\n        return succeed;\r\n    }\r\n</script>\r\n```\r\ngetUrl中调用了封装好的copyToClipboard方法实现了功能。有一点的是html中input的样式用style=”margin-left: -9999px”进行隐藏，因为不知道为什么用type=”hiden”或者display=”none”去隐藏都只会获取源代码而不是动态的url遍历出来的值。', '<p>最近捣鼓一个小问题，搞一个按钮，点击复制url到黏贴板，但是不是当前页面url，而是对应一个元素的url，且一个页面会有多个url。一开始找到一个方法，但是竟然只兼容IE浏览器，神奇了，竟然有只兼容IE的东西。后来发现一个zeroclipboard.js这个插件，但是怎么也搞不出那个效果，有点麻烦。</p>\r\n<p>最后翻到了一个js封装好的方法，有效！</p>\r\n<p>想要实现的一个效果是，下面html代码：</p>\r\n<pre><code class=\"lang-html\">&lt;tr&gt;\r\n &lt;td&gt;\r\n  &lt;a id=&quot;copy_{$key}&quot; onclick=&quot;getUrl(&#39;{$key}&#39;)&quot;&gt;复制文件链接&lt;/a&gt;\r\n  &lt;input id=&quot;file_{$key}&quot; value=&quot;{$file.file_url}&quot; style=&quot;margin-left: -9999px&quot;/&gt;\r\n &lt;/td&gt;\r\n&lt;/tr&gt;\r\n</code></pre>\r\n<p>点击复制文件链接这个按钮，复制input框里的value值，是传进去的一个url；首先点击a标签会触发getUrl这个函数；传进去id用于找到对应的input然后取值（因为遍历了多个td，有许多个input框一一对应去取）。</p>\r\n<p>下面js代码：</p>\r\n<pre><code class=\"lang-js\">&lt;script type=&quot;application/javascript&quot;&gt;\r\n    function getUrl(id) {\r\n        if (copyToClipboard(document.getElementById(&quot;file_&quot;+id))){\r\n            alert(&quot;成功复制到黏贴板！&quot;);\r\n        }else{\r\n            alert(&quot;复制到黏贴板失败！&quot;);\r\n        }\r\n    }\r\n\r\n    function copyToClipboard(elem) {\r\n        // create hidden text element, if it doesn&#39;t already exist\r\n        var targetId = &quot;_hiddenCopyText_&quot;;\r\n        var isInput = elem.tagName === &quot;INPUT&quot; || elem.tagName === &quot;TEXTAREA&quot;;\r\n        var origSelectionStart, origSelectionEnd;\r\n        if (isInput) {\r\n            // can just use the original source element for the selection and copy\r\n            target = elem;\r\n            origSelectionStart = elem.selectionStart;\r\n            origSelectionEnd = elem.selectionEnd;\r\n        } else {\r\n            // must use a temporary form element for the selection and copy\r\n            target = document.getElementById(targetId);\r\n            if (!target) {\r\n                var target = document.createElement(&quot;textarea&quot;);\r\n                target.style.position = &quot;absolute&quot;;\r\n                target.style.left = &quot;-9999px&quot;;\r\n                target.style.top = &quot;0&quot;;\r\n                target.id = targetId;\r\n                document.body.appendChild(target);\r\n            }\r\n            target.textContent = elem.textContent;\r\n        }\r\n        // select the content\r\n        var currentFocus = document.activeElement;\r\n        target.focus();\r\n        target.setSelectionRange(0, target.value.length);\r\n\r\n        // copy the selection\r\n        var succeed;\r\n        try {\r\n            succeed = document.execCommand(&quot;copy&quot;);\r\n        } catch(e) {\r\n            succeed = false;\r\n        }\r\n        // restore original focus\r\n        if (currentFocus &amp;&amp; typeof currentFocus.focus === &quot;function&quot;) {\r\n            currentFocus.focus();\r\n        }\r\n\r\n        if (isInput) {\r\n            // restore prior selection\r\n            elem.setSelectionRange(origSelectionStart, origSelectionEnd);\r\n        } else {\r\n            // clear temporary content\r\n            target.textContent = &quot;&quot;;\r\n        }\r\n        return succeed;\r\n    }\r\n&lt;/script&gt;\r\n</code></pre>\r\n<p>getUrl中调用了封装好的copyToClipboard方法实现了功能。有一点的是html中input的样式用style=”margin-left: -9999px”进行隐藏，因为不知道为什么用type=”hiden”或者display=”none”去隐藏都只会获取源代码而不是动态的url遍历出来的值。</p>\r\n', '', 0, 'publish', 1, 0, '/article/25.html', '', 0, 98, '2016-12-12 06:44:21', '2016-12-12 06:44:21', '2018-01-08 09:41:57', NULL);
INSERT INTO `pt_post` VALUES (26, 10, 'article', 'ThinkPHP5支持Pathinfo模式的Nginx配置', '最近搞TP5，配置Nginx服务器。玩惯了Apache，发现nginx确实很不一样。尝试了N种方法都无法配置成功。\r\n\r\n因为用windows本地开发调试的，根目录下又有多个目录，一直不知道在怎么弄。最后终于找到解决方法。\r\n```\r\nlocation ~ \\.php {    #去掉$\r\n     root          H:/PHPServer/WWW;\r\n     fastcgi_pass   127.0.0.1:9000;\r\n     fastcgi_index  index.php;\r\n     fastcgi_split_path_info ^(.+\\.php)(.*)$;     #增加这一句\r\n     fastcgi_param PATH_INFO $fastcgi_path_info;    #增加这一句\r\n     fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;\r\n     include        fastcgi_params;\r\n}\r\n```\r\n\r\n再去掉index.php：\r\n```\r\nlocation /sgy/ {\r\n    if (!-e $request_filename){\r\n    rewrite ^/sgy/public/(.*)$ /sgy/public/index.php?s=$1 last;\r\n    }\r\n}\r\n```\r\n\r\n------------\r\n\r\n**2016.12.17后续:**\r\n发现了一直以来一个错误，导致一直出现的不理解的问题，现在解决了；**在不解析到/public/目录的情况下**，经常出现文件找不到的情况。之前的配置方法一直是像上面那样：\r\n```\r\nlocation / {\r\n    root   D:/wnmp/www;\r\n    index  index.html index.htm index.php;\r\n}\r\nlocation /sgy/ {\r\n    if (!-e $request_filename){\r\n    rewrite ^/sgy/public/(.*)$ /sgy/public/index.php?s=$1 last;\r\n    }\r\n}\r\n```\r\n但是这样的话，下面的并没有指定root！改为：\r\n```\r\nlocation / {\r\n    root D:/wnmp/www;\r\n    index index.html index.htm index.php;\r\n    if (!-e $request_filename){\r\n    rewrite ^/sgy/public/(.*)$ /sgy/public/index.php?s=$1 last;\r\n    }\r\n}\r\n```\r\n然后问题就解决了。', '<p>最近搞TP5，配置Nginx服务器。玩惯了Apache，发现nginx确实很不一样。尝试了N种方法都无法配置成功。</p>\r\n<p>因为用windows本地开发调试的，根目录下又有多个目录，一直不知道在怎么弄。最后终于找到解决方法。</p>\r\n<pre><code>location ~ \\.php {    #去掉$\r\n     root          H:/PHPServer/WWW;\r\n     fastcgi_pass   127.0.0.1:9000;\r\n     fastcgi_index  index.php;\r\n     fastcgi_split_path_info ^(.+\\.php)(.*)$;     #增加这一句\r\n     fastcgi_param PATH_INFO $fastcgi_path_info;    #增加这一句\r\n     fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;\r\n     include        fastcgi_params;\r\n}\r\n</code></pre><p>再去掉index.php：</p>\r\n<pre><code>location /sgy/ {\r\n    if (!-e $request_filename){\r\n    rewrite ^/sgy/public/(.*)$ /sgy/public/index.php?s=$1 last;\r\n    }\r\n}\r\n</code></pre><hr>\r\n<p><strong>2016.12.17后续:</strong><br>发现了一直以来一个错误，导致一直出现的不理解的问题，现在解决了；<strong>在不解析到/public/目录的情况下</strong>，经常出现文件找不到的情况。之前的配置方法一直是像上面那样：</p>\r\n<pre><code>location / {\r\n    root   D:/wnmp/www;\r\n    index  index.html index.htm index.php;\r\n}\r\nlocation /sgy/ {\r\n    if (!-e $request_filename){\r\n    rewrite ^/sgy/public/(.*)$ /sgy/public/index.php?s=$1 last;\r\n    }\r\n}\r\n</code></pre><p>但是这样的话，下面的并没有指定root！改为：</p>\r\n<pre><code>location / {\r\n    root D:/wnmp/www;\r\n    index index.html index.htm index.php;\r\n    if (!-e $request_filename){\r\n    rewrite ^/sgy/public/(.*)$ /sgy/public/index.php?s=$1 last;\r\n    }\r\n}\r\n</code></pre><p>然后问题就解决了。</p>\r\n', '', 0, 'publish', 1, 0, '/article/26.html', '', 0, 126, '2016-12-15 06:40:58', '2016-12-15 06:40:58', '2018-01-08 09:56:26', NULL);
INSERT INTO `pt_post` VALUES (27, 10, 'article', '基于ThinkPHP5的cURL封装类', '现在一个项目，需要频繁调用API从数据层获取数据，数据层业务层分离。封装了一个基于此的cURL封装类：\r\n```php\r\n<?php\r\n/**\r\n * cURL封装类\r\n *\r\n * @author guo\r\n * @date 2016-12-17\r\n */\r\nnamespace app\\home\\Request;\r\n\r\nclass cURL {\r\n    private static $url = \'\';         // 访问的url\r\n    private static $oriUrl = \'\';      // Referer url,告诉服务器来源页面\r\n    private static $data = array();   // 可能发出的请求参数 get和post都有数组传参方式\r\n    private static $method;           // 访问方式，默认是GET请求\r\n    private static $cookie = \'\';      // 是否传递cookie; 默认为空, 需要时传入cookie参数\r\n    private static $returnCookie = 0; // 是否返回cookie; 默认0不返回\r\n\r\n    /*\r\n     * 发送请求入口\r\n     * **/\r\n    public static function send($url, $data = array(), $method = \'get\', $cookie = \'\', $returnCookie = 0)\r\n    {\r\n        //判断传入的url\r\n        if (!$url){\r\n            return self::output(\'100\', \'url不能为空!\', \'\');\r\n        }\r\n        self::$url = $url;\r\n        self::$data = $data;\r\n        self::$method = $method;\r\n        self::$oriUrl = request()->url(true);//助手函数request获取当前url\r\n        self::$cookie = $cookie;\r\n        self::$returnCookie = $returnCookie;\r\n        // 请求方式判断\r\n        if ( !in_array(self::$method, array(\'get\', \'post\') )) {\r\n            return self::output(\'101\', \'非法请求方式!\', \'\');\r\n        }\r\n\r\n        return self::doRequest(self::$method);\r\n    }\r\n\r\n    /**\r\n     * 基础发起curl请求函数\r\n     * @param string $method 请求方式, get或者post\r\n     */\r\n    private static function doRequest($method)\r\n    {\r\n        $curl = curl_init(); //初始化curl\r\n        /* get方式 */\r\n        if ($method != 1) {\r\n            self::$data = empty(self::$data) ? \'\' : self::dealGetData(self::$data);//处理get数据\r\n            self::$url  = self::$url.self::$data;\r\n        }\r\n        curl_setopt($curl, CURLOPT_URL, self::$url); //抓取指定网页\r\n        curl_setopt($curl, CURLOPT_USERAGENT, \'Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.1; Trident/6.0)\');\r\n        curl_setopt($curl, CURLOPT_FOLLOWLOCATION, 1);\r\n        curl_setopt($curl, CURLOPT_AUTOREFERER, 1);\r\n        curl_setopt($curl, CURLOPT_REFERER, self::$oriUrl); //来源,获取的当前站点url\r\n        curl_setopt($curl, CURLOPT_RETURNTRANSFER, 1);//要求结果为字符串且输出到屏幕上\r\n        /* post方式数据传递 */\r\n        if ($method == 1)\r\n        {\r\n            curl_setopt($curl, CURLOPT_POST, 1);\r\n            curl_setopt($curl, CURLOPT_POSTFIELDS, http_build_query(self::$data));\r\n        }\r\n\r\n        /* 如果提交了cookie参数, 传递cookie参数 */\r\n        if(self::$cookie) {\r\n            curl_setopt($curl, CURLOPT_COOKIE, self::$cookie);\r\n        }\r\n\r\n        curl_setopt($curl, CURLOPT_HEADER, self::$returnCookie); //是否返回cookie\r\n        curl_setopt($curl, CURLOPT_TIMEOUT, 30); //超时设置\r\n\r\n        /* 执行并获取数据 */\r\n        $result = curl_exec($curl);\r\n\r\n        /* 出错时的操作 */\r\n        $error_num = curl_error($curl); // 获取错误码,正常时为0\r\n        //出错时\r\n        if ($error_num >0){\r\n            $error = include \'cURLError.php\'; //载入错误信息\r\n            $error_msg = $error[$error_num]; //获取对应错误信息\r\n            return self::output($error_num, $error_msg, \'\');\r\n        } else {\r\n            $error_num = \'0\';\r\n            $error_msg = \"请求正常！\";\r\n            curl_close($curl); //关闭\r\n\r\n            /* 如果返回cookie */\r\n            if(self::$returnCookie){\r\n                list($header, $body) = explode(\"\\r\\n\\r\\n\", $result, 2);\r\n                preg_match_all(\"/Set\\-Cookie:([^;]*);/\", $header, $matches);\r\n                $info[\'cookie\']  = substr($matches[1][0], 1);\r\n                $info[\'content\'] = $body;\r\n                return self::output($error_num, $error_msg, $info);\r\n            } else {\r\n                return self::output($error_num, $error_msg, $result);\r\n            }\r\n        }\r\n    }\r\n\r\n    /*\r\n     * 处理get数据\r\n     * @param array $data 传入的需要处理的数据\r\n     * @return string 包含参数与值的字符串\r\n     * **/\r\n    public static function dealGetData($data)\r\n    {\r\n        $output = \'?\';\r\n        foreach ($data as $k => $v){\r\n            $output .= $k.\'=\'.$v.\'&\';\r\n        }\r\n        $output = substr($output, 0 , -1);\r\n        return $output;\r\n    }\r\n\r\n    /*\r\n     * 返回数据\r\n     * @param int $code 状态码,为0时是ok的没有出错正常请求\r\n     * @param string $info  返回的错误信息\r\n     * @param array $result 返回的数据\r\n     * @return array\r\n     * **/\r\n    public static function output($code, $info, $result)\r\n    {\r\n        return array(\r\n            \'code\'   => $code,\r\n            \'info\'   => $info,\r\n            \'result\' => $result\r\n        );\r\n    }\r\n}\r\n```', '<p>现在一个项目，需要频繁调用API从数据层获取数据，数据层业务层分离。封装了一个基于此的cURL封装类：</p>\r\n<pre><code class=\"lang-php\">&lt;?php\r\n/**\r\n * cURL封装类\r\n *\r\n * @author guo\r\n * @date 2016-12-17\r\n */\r\nnamespace app\\home\\Request;\r\n\r\nclass cURL {\r\n    private static $url = &#39;&#39;;         // 访问的url\r\n    private static $oriUrl = &#39;&#39;;      // Referer url,告诉服务器来源页面\r\n    private static $data = array();   // 可能发出的请求参数 get和post都有数组传参方式\r\n    private static $method;           // 访问方式，默认是GET请求\r\n    private static $cookie = &#39;&#39;;      // 是否传递cookie; 默认为空, 需要时传入cookie参数\r\n    private static $returnCookie = 0; // 是否返回cookie; 默认0不返回\r\n\r\n    /*\r\n     * 发送请求入口\r\n     * **/\r\n    public static function send($url, $data = array(), $method = &#39;get&#39;, $cookie = &#39;&#39;, $returnCookie = 0)\r\n    {\r\n        //判断传入的url\r\n        if (!$url){\r\n            return self::output(&#39;100&#39;, &#39;url不能为空!&#39;, &#39;&#39;);\r\n        }\r\n        self::$url = $url;\r\n        self::$data = $data;\r\n        self::$method = $method;\r\n        self::$oriUrl = request()-&gt;url(true);//助手函数request获取当前url\r\n        self::$cookie = $cookie;\r\n        self::$returnCookie = $returnCookie;\r\n        // 请求方式判断\r\n        if ( !in_array(self::$method, array(&#39;get&#39;, &#39;post&#39;) )) {\r\n            return self::output(&#39;101&#39;, &#39;非法请求方式!&#39;, &#39;&#39;);\r\n        }\r\n\r\n        return self::doRequest(self::$method);\r\n    }\r\n\r\n    /**\r\n     * 基础发起curl请求函数\r\n     * @param string $method 请求方式, get或者post\r\n     */\r\n    private static function doRequest($method)\r\n    {\r\n        $curl = curl_init(); //初始化curl\r\n        /* get方式 */\r\n        if ($method != 1) {\r\n            self::$data = empty(self::$data) ? &#39;&#39; : self::dealGetData(self::$data);//处理get数据\r\n            self::$url  = self::$url.self::$data;\r\n        }\r\n        curl_setopt($curl, CURLOPT_URL, self::$url); //抓取指定网页\r\n        curl_setopt($curl, CURLOPT_USERAGENT, &#39;Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.1; Trident/6.0)&#39;);\r\n        curl_setopt($curl, CURLOPT_FOLLOWLOCATION, 1);\r\n        curl_setopt($curl, CURLOPT_AUTOREFERER, 1);\r\n        curl_setopt($curl, CURLOPT_REFERER, self::$oriUrl); //来源,获取的当前站点url\r\n        curl_setopt($curl, CURLOPT_RETURNTRANSFER, 1);//要求结果为字符串且输出到屏幕上\r\n        /* post方式数据传递 */\r\n        if ($method == 1)\r\n        {\r\n            curl_setopt($curl, CURLOPT_POST, 1);\r\n            curl_setopt($curl, CURLOPT_POSTFIELDS, http_build_query(self::$data));\r\n        }\r\n\r\n        /* 如果提交了cookie参数, 传递cookie参数 */\r\n        if(self::$cookie) {\r\n            curl_setopt($curl, CURLOPT_COOKIE, self::$cookie);\r\n        }\r\n\r\n        curl_setopt($curl, CURLOPT_HEADER, self::$returnCookie); //是否返回cookie\r\n        curl_setopt($curl, CURLOPT_TIMEOUT, 30); //超时设置\r\n\r\n        /* 执行并获取数据 */\r\n        $result = curl_exec($curl);\r\n\r\n        /* 出错时的操作 */\r\n        $error_num = curl_error($curl); // 获取错误码,正常时为0\r\n        //出错时\r\n        if ($error_num &gt;0){\r\n            $error = include &#39;cURLError.php&#39;; //载入错误信息\r\n            $error_msg = $error[$error_num]; //获取对应错误信息\r\n            return self::output($error_num, $error_msg, &#39;&#39;);\r\n        } else {\r\n            $error_num = &#39;0&#39;;\r\n            $error_msg = &quot;请求正常！&quot;;\r\n            curl_close($curl); //关闭\r\n\r\n            /* 如果返回cookie */\r\n            if(self::$returnCookie){\r\n                list($header, $body) = explode(&quot;\\r\\n\\r\\n&quot;, $result, 2);\r\n                preg_match_all(&quot;/Set\\-Cookie:([^;]*);/&quot;, $header, $matches);\r\n                $info[&#39;cookie&#39;]  = substr($matches[1][0], 1);\r\n                $info[&#39;content&#39;] = $body;\r\n                return self::output($error_num, $error_msg, $info);\r\n            } else {\r\n                return self::output($error_num, $error_msg, $result);\r\n            }\r\n        }\r\n    }\r\n\r\n    /*\r\n     * 处理get数据\r\n     * @param array $data 传入的需要处理的数据\r\n     * @return string 包含参数与值的字符串\r\n     * **/\r\n    public static function dealGetData($data)\r\n    {\r\n        $output = &#39;?&#39;;\r\n        foreach ($data as $k =&gt; $v){\r\n            $output .= $k.&#39;=&#39;.$v.&#39;&amp;&#39;;\r\n        }\r\n        $output = substr($output, 0 , -1);\r\n        return $output;\r\n    }\r\n\r\n    /*\r\n     * 返回数据\r\n     * @param int $code 状态码,为0时是ok的没有出错正常请求\r\n     * @param string $info  返回的错误信息\r\n     * @param array $result 返回的数据\r\n     * @return array\r\n     * **/\r\n    public static function output($code, $info, $result)\r\n    {\r\n        return array(\r\n            &#39;code&#39;   =&gt; $code,\r\n            &#39;info&#39;   =&gt; $info,\r\n            &#39;result&#39; =&gt; $result\r\n        );\r\n    }\r\n}\r\n</code></pre>\r\n', '', 0, 'publish', 1, 0, '/article/27.html', '', 0, 148, '2016-12-30 03:08:15', '2016-12-30 03:08:15', '2018-01-08 10:01:44', NULL);
INSERT INTO `pt_post` VALUES (28, 10, 'article', '如何使用Composer', '现在很多框架，拓展都使用了composer模式进行安装；现在TP5也使用composer了，总结一下。这里以thinkphp5框架安装一个think-captcha验证码拓展为例子。\r\n\r\n首先，先安装composer，因为是本地用的，我是windows系统，有无脑安装版本，先用这个版本，其实其他方法包括Linux系统，也不复杂，没问题。\r\n\r\nwindows安装包下载：[Composer-Setup.exe](https://getcomposer.org/Composer-Setup.exe \"Composer-Setup.exe\")\r\n\r\n然后就是next，next就好，选择代理的那里不选即可。\r\n\r\n安装完之后就可以用了，我们发现thinkphp根目录 （下载的压缩包）下已经有一个composer.json了。这时候，如果我们需要安装验证码拓展（tp5需要下载拓展包），可以先用命令行进入项目目录：\r\n![](https://www.goozp.com/uploads/2018/01/Install_composer1.png)\r\n执行：\r\n```\r\ncomposer require topthink/think-captcha\r\n```\r\n\r\n如果发现没反应，不要急！因为镜像原因，比较慢，等等就好，完事之后就是这样：\r\n![](https://www.goozp.com/uploads/2018/01/Install_composer2.png)\r\n\r\n这个时候发现：\r\n\r\n根目录的composer.json多出来一行，同时自动生成了composer.lock进行版本控制:\r\n![](https://www.goozp.com/uploads/2018/01/Install_composer3.png)\r\n\r\n总之，进入项目目录后，如果是局部安装的composer，用`php composer.phar`命令，全局安装的用`composer`。\r\n\r\n使用install进行安装，先定义好composer.json的依赖，执行：\r\n`php composer.phar install`或者`composer install`\r\n\r\ncomposer会自动去找到composer.json的定义安装。\r\n\r\n使用require进行添加依赖（就像上面安装think-captcha库那样）：`php composer.phar require`或者`composer require`\r\n\r\n更新：`php composer.phar update`或者`composer update`\r\n\r\n所有的拓展包都安装在了vendor目录下，导入autoload.php就可以自动载入。 而在TP5中，自动导入了vendor拓展包并且定义了think下的命名空间。 例如think-captcha拓展包，我们只需要：\r\n\r\n```\r\nuse think\\captcha\\Captcha;\r\n```\r\n\r\n然后new Captcha()调用这个类就行。', '<p>现在很多框架，拓展都使用了composer模式进行安装；现在TP5也使用composer了，总结一下。这里以thinkphp5框架安装一个think-captcha验证码拓展为例子。</p>\r\n<p>首先，先安装composer，因为是本地用的，我是windows系统，有无脑安装版本，先用这个版本，其实其他方法包括Linux系统，也不复杂，没问题。</p>\r\n<p>windows安装包下载：<a href=\"https://getcomposer.org/Composer-Setup.exe\" title=\"Composer-Setup.exe\">Composer-Setup.exe</a></p>\r\n<p>然后就是next，next就好，选择代理的那里不选即可。</p>\r\n<p>安装完之后就可以用了，我们发现thinkphp根目录 （下载的压缩包）下已经有一个composer.json了。这时候，如果我们需要安装验证码拓展（tp5需要下载拓展包），可以先用命令行进入项目目录：<br><img src=\"https://www.goozp.com/uploads/2018/01/Install_composer1.png\" alt=\"\"><br>执行：</p>\r\n<pre><code>composer require topthink/think-captcha\r\n</code></pre><p>如果发现没反应，不要急！因为镜像原因，比较慢，等等就好，完事之后就是这样：<br><img src=\"https://www.goozp.com/uploads/2018/01/Install_composer2.png\" alt=\"\"></p>\r\n<p>这个时候发现：</p>\r\n<p>根目录的composer.json多出来一行，同时自动生成了composer.lock进行版本控制:<br><img src=\"https://www.goozp.com/uploads/2018/01/Install_composer3.png\" alt=\"\"></p>\r\n<p>总之，进入项目目录后，如果是局部安装的composer，用<code>php composer.phar</code>命令，全局安装的用<code>composer</code>。</p>\r\n<p>使用install进行安装，先定义好composer.json的依赖，执行：<br><code>php composer.phar install</code>或者<code>composer install</code></p>\r\n<p>composer会自动去找到composer.json的定义安装。</p>\r\n<p>使用require进行添加依赖（就像上面安装think-captcha库那样）：<code>php composer.phar require</code>或者<code>composer require</code></p>\r\n<p>更新：<code>php composer.phar update</code>或者<code>composer update</code></p>\r\n<p>所有的拓展包都安装在了vendor目录下，导入autoload.php就可以自动载入。 而在TP5中，自动导入了vendor拓展包并且定义了think下的命名空间。 例如think-captcha拓展包，我们只需要：</p>\r\n<pre><code>use think\\captcha\\Captcha;\r\n</code></pre><p>然后new Captcha()调用这个类就行。</p>\r\n', '', 0, 'publish', 1, 0, '/article/28.html', 'https://www.goozp.com/uploads/2018/01/composer_logo.png', 0, 110, '2016-12-16 05:49:25', '2016-12-16 05:49:25', '2018-01-09 02:46:06', NULL);
INSERT INTO `pt_post` VALUES (29, 10, 'article', 'serialize序列化和json的比较', '关于将数据序列化存储这块，一直有一个疑问，就是serialize和json应该用哪一个更好。\r\n\r\n参考了很多文章和讨论：\r\n1. [Serialize or json in PHP?](https://stackoverflow.com/questions/2574728/serialize-or-json-in-php \"Serialize or json in PHP?\")\r\n2. [JSON vs. Serialized Array in database](https://stackoverflow.com/questions/1306740/json-vs-serialized-array-in-database \"JSON vs. Serialized Array in database\")\r\n3. [PHP的serialize序列化数据与JSON格式化数据](https://www.helloweba.net/php/319.html \"PHP的serialize序列化数据与JSON格式化数据\")\r\n4. [php的serialize序列化和json性能测试](http://blog.csdn.net/hguisu/article/details/7651730 \"php的serialize序列化和json性能测试\")\r\n\r\n总结一下：\r\n1. serialize解码比json快\r\n2. 数据量越大， json效率越高\r\n3. serialize是php里才有的，而json便于与其它语言交互\r\n4. serialize可以保留php的object，而json会改变\r\n5. json只支持utf8编码\r\n6. serialize占用空间会大一些\r\n\r\n**什么时候用什么？**\r\n如果需要存储对象数据，用serialize，否则可以直接使用json，非绝对。\r\n', '<p>关于将数据序列化存储这块，一直有一个疑问，就是serialize和json应该用哪一个更好。</p>\r\n<p>参考了很多文章和讨论：</p>\r\n<ol>\r\n<li><a href=\"https://stackoverflow.com/questions/2574728/serialize-or-json-in-php\" title=\"Serialize or json in PHP?\">Serialize or json in PHP?</a></li><li><a href=\"https://stackoverflow.com/questions/1306740/json-vs-serialized-array-in-database\" title=\"JSON vs. Serialized Array in database\">JSON vs. Serialized Array in database</a></li><li><a href=\"https://www.helloweba.net/php/319.html\" title=\"PHP的serialize序列化数据与JSON格式化数据\">PHP的serialize序列化数据与JSON格式化数据</a></li><li><a href=\"http://blog.csdn.net/hguisu/article/details/7651730\" title=\"php的serialize序列化和json性能测试\">php的serialize序列化和json性能测试</a></li></ol>\r\n<p>总结一下：</p>\r\n<ol>\r\n<li>serialize解码比json快</li><li>数据量越大， json效率越高</li><li>serialize是php里才有的，而json便于与其它语言交互</li><li>serialize可以保留php的object，而json会改变</li><li>json只支持utf8编码</li><li>serialize占用空间会大一些</li></ol>\r\n<p><strong>什么时候用什么？</strong><br>如果需要存储对象数据，用serialize，否则可以直接使用json，非绝对。</p>\r\n', '', 0, 'publish', 1, 0, '/article/29.html', '', 0, 100, '2017-01-05 03:21:48', '2017-01-05 03:21:48', '2018-01-09 02:52:29', NULL);
INSERT INTO `pt_post` VALUES (30, 10, 'article', 'PHP开发之网站安全', '# 一. 防止SQL注入\r\n## 1 危害\r\n1. 攻击者可以利用它读取、修改或者删除数据库内的数据，获取数据库中的用户名和密码等敏感信息\r\n2. 甚至可以 获得数据库管理员的权限。\r\n3. 如果能够再利用SQLServer扩展存储过程和自定义扩展存储过程来执行一些系统命令，攻击者还可以获得该系统的控制权。\r\n4. SQL Injection 也很难防范。网站管理员无法通过安装系统补丁或者进行简单的安全配置进行自我保护，一般的防火墙也无法拦截SQL Injection 攻击。\r\n\r\n## 2 原理\r\n结构化查询语言(SQL)是一种用来和数据库交互的文本语言。SQL Injection 就是利用某些数据库的外部接口把用户数据插入到实际的数据库操作语言(SQL)当中，从而达到入侵数据库乃至操作系统的目的。它的产生主要是由于程序对用户输入 的数据没有进行严格的过滤，导致非法数据库查询语句的执行。\r\n\r\n## 3 注入方式举例\r\n例如下面的用户登陆验证程序：\r\n```php\r\n$sql = \"SELECT * FROM user WHERE username=\'$username\' AND password=\'$password\'\";\r\n$result = mysql_db_query($dbname, $sql);\r\n```\r\n\r\n1. or 注入\r\n如果我们提交如下url：\r\n`http://127.0.0.1/injection/user.php?username=angel\'or\'1=1`\r\n这个sql就变成：\r\n```sql\r\nSELECT * FROM user WHERE username=’angel’ or ‘1=1’ AND password=’$password\r\n```\r\npassword部分就被这个or给怼没了，那么就可以不输入密码成功登陆系统\r\n\r\n2. 注释注入\r\n同样我们也可以利用sql的注释语句实现sql注入，如下面的例子：\r\n`http://127.0.0.1/injection/user.php?username=angel\'/*`\r\n`http://127.0.0.1/injection/user.php?username=angel\'%23`\r\n根据mysql的特性，mysql支持/*和#两种注释格式，所以我们提交的时候是把后面的代码注释掉，值得注意的是由于编码问题，在地址栏里提交#会变成空的，所以我们在地址栏提交的时候，应该提交%23，才会变成#，就成功注释了。\r\n\r\n3. SQL注入语句大全\r\nhttp://blog.csdn.net/zzq19860626/article/details/10220427\r\n\r\n## 4 需要注意以下几个要点\r\n\r\n1. 永远不要信任用户的输入。对用户的输入进行校验，可以通过正则表达式，或限制长度；对单引号和 双”-“进行转换等。\r\n2. 永远不要使用动态拼装sql，可以使用参数化的sql或者直接使用存储过程进行数据查询存取。\r\n3. 永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。\r\n4. 不要把机密信息直接存放，加密或者hash掉密码和敏感的信息。\r\n5. 应用的异常信息应该给出尽可能少的提示，最好使用自定义的错误信息对原始错误信息进行包装\r\n\r\n## 5 PHP中我们如何解决\r\n### 1） PHP手册介绍的预防措施\r\nPHP手册的SQL注入部分：[http://php.net/manual/zh/security.database.sql-injection.php](http://php.net/manual/zh/security.database.sql-injection.php \"http://php.net/manual/zh/security.database.sql-injection.php\")\r\n- 永远不要使用超级用户或所有者帐号去连接数据库。要用权限被严格限制的帐号。\r\n- 检查输入的数据是否具有所期望的数据格式。PHP 有很多可以用于检查输入的函数，从简单的变量函数和字符类型函数（比如 is_numeric()，ctype_digit()）到复杂的 Perl 兼容正则表达式函数都可以完成这个工作。\r\n- 如果程序等待输入一个数字，可以考虑使用 is_numeric() 来检查，或者直接使用 settype() 来转换它的类型，也可以用 sprintf() 把它格式化为数字。\r\n- 使用数据库特定的敏感字符转义函数（比如 mysql_escape_string() 和 sql_escape_string()）把用户提交上来的非数字数据进行转义。如果数据库没有专门的敏感字符转义功能的话 addslashes() 和 str_replace() 可以代替完成这个工作。\r\n- 要不择手段避免显示出任何有关数据库的信心，尤其是数据库结构。参见错误报告和错误处理函数。\r\n- 也可以选择使用数据库的存储过程和预定义指针等特性来抽象数库访问，使用户不能直接访问数据表和视图。但这个办法又有别的影响。\r\n- 在允许的情况下，使用代码或数据库系统保存查询日志也是一个好办法。显然，日志并不能防止任何攻击，但利用它可以跟踪到哪个程序曾经被尝试攻击过。日志本身没用，要查阅其中包含的信息才行。毕竟，更多的信息总比没有要好。\r\n\r\n### 2）使用PDO防止SQL注入\r\nPDO防注入原理分析以及使用PDO的注意事项：[https://my.oschina.net/zxu/blog/148432](https://my.oschina.net/zxu/blog/148432 \"https://my.oschina.net/zxu/blog/148432\")\r\n\r\n# 二. 验证码\r\n对于识别验证码的程序来说，最难的部分是验证字符的切割和特征码的建立，而国内很多程序员只做验证码时，总是喜欢在验证码加很多干扰素，干扰线，影响效果不说，还达不到很好的效果；所以，要想使自己验证码难于本识别，只做下面两点就够了\r\n- 字符粘连，最好所有的字符都有粘连的部分；\r\n- 不要使用规格字符，验证码的各个部分使用不同比例的缩放或者旋转。\r\n\r\n只要做到这两点，或者这两点的变形，识别程序就很难识别。\r\n\r\n# 三. 刷新提交\r\n## 场景\r\n- 点击提交按钮两次。\r\n- 点击刷新按钮。\r\n- 使用浏览器后退按钮重复之前的操作，导致重复提交表单。\r\n- 使用浏览器历史记录重复提交表单。\r\n- 浏览器重复的HTTP请求。\r\n\r\n用户提交表单时可能因为网速的原因，或者网页被恶意刷新，致使同一条记录重复插入到数据库中，这是一个比较棘手的问题。我们可以从客户端和服务器端一起着手，设法避免同一表单的重复提交。\r\n\r\n## 有效策略\r\n- js禁掉提交按钮。\r\n表单提交后使用Javascript使提交按钮disable。这种方法防止心急的用户多次点击按钮。但有个问题，如果客户端把Javascript给禁止掉，这种方法就无效了。\r\n- 使用Post/Redirect/Get模式。\r\n在提交后执行页面重定向，这就是所谓的Post-Redirect-Get (PRG)模式。简言之，当用户提交了表单后，你去执行一个客户端的重定向，转到提交成功信息页面。这能避免用户按F5导致的重复提交，而其也不会出现浏览器表单重复提交的警告，也能消除按浏览器前进和后退按导致的同样问题。\r\n- 在session中存放一个特殊标志。\r\n当表单页面被请求时，生成一个特殊的字符标志串，存在session中，同时放在表单的隐藏域里。接受处理表单数据时，检查标识字串是否存在，并立即从session中删除它，然后正常处理数据。\r\n如果发现表单提交里没有有效的标志串，这说明表单已经被提交过了，忽略这次提交。\r\n- 使用header函数转向\r\n当用户提交表单，服务器端处理后立即转向其他的页面，代码如下所示。\r\n```\r\nif (isset($_POST[\'action\']) && $_POST[\'action\'] == \'submitted\') {\r\n     //处理数据，如插入数据后，立即转向到其他页面\r\n     header(\'location:submits_success.php\');\r\n}\r\n```\r\n这样，即使用户使用刷新键，也不会导致表单的重复提交，因为已经转向新的页面，而这个页面脚本已经不理会任何提交的数据了。\r\n- 在数据库里添加约束。\r\n在数据库里添加唯一约束或创建唯一索引，防止出现重复数据。这是最有效的防止重复提交数据的方法。\r\n- 使用Cookie处理\r\n使用Cookie记录表单提交的状态，根据其状态可以检查是否已经提交表单。如果客户端禁止了Cookie，该方法将不起任何作用，这点请注意。\r\n\r\n# 四. DOS攻击\r\n防止 DDoS 攻击的方式：\r\n- 减少公开暴露\r\n- 利用扩展和冗余\r\n- 充足的网络带宽保证\r\n- 分布式服务拒绝 DDoS 攻击\r\n- 实时监控系统性能\r\n- 修改配置；这里提供一个简单的参考方法，修改php.ini文件\r\n - “disable_functions”改成gzinflate，默认是放空\r\n - ”allow_url_fopen“设为Off\r\n - php_sockets.dll 把这个模块打开\r\n 重启使配置生效，一般可以抵御掉DDOS攻击。\r\n\r\n参考资料：\r\n51CTOblog的DDOS攻击与防御专题：[http://blog.51cto.com/zt/282](http://blog.51cto.com/zt/282 \"http://blog.51cto.com/zt/282\")\r\n\r\n# 五. 跨域攻击\r\n> 注：以下内容摘自：[https://blog.tonyseek.com/post/introduce-to-xss-and-csrf/](https://blog.tonyseek.com/post/introduce-to-xss-and-csrf/ \"https://blog.tonyseek.com/post/introduce-to-xss-and-csrf/\")\r\n\r\n## XSS\r\nXSS全称“跨站脚本”，是注入攻击的一种。其特点是不对服务器端造成任何伤害，而是通过一些正常的站内交互途径，例如发布评论，提交含有 JavaScript 的内容文本。这时服务器端如果没有过滤或转义掉这些脚本，作为内容发布到了页面上，其他用户访问这个页面的时候就会运行这些脚本。\r\n\r\n**防止 XSS 的根本之道还是过滤用户输入。**用户输入总是不可信任的，这点对于 Web 开发者应该是常识。\r\n\r\n如果我们不需要用户输入 HTML 而只想让他们输入纯文本，那么把所有用户输入进行 HTML 转义输出是个不错的做法。似乎很多 Web 开发框架、模版引擎的开发者也发现了这一点，Django 内置模版和 Jinja2 模版总是默认转义输出变量的。如果没有使用它们，我们自己也可以这么做。**PHP 可以用 htmlspecialchars 函数**，**Python 可以导入 cgi 模块用其中的 cgi.escape 函数**。如果使用了某款模版引擎，那么其必自带了方便快捷的转义方式。\r\n\r\n对于复杂的情况，简单的方法就是白名单重新整理。“白名单”消毒 HTML 标签和属性（Sanitize HTML）的开源解决方案：\r\n- JavaScript: sanitize-html\r\n- PHP: htmlpurifier\r\n\r\n## CSRF\r\n\r\nCSRF 和 XSS 根本是两个不同维度上的分类。**XSS 是实现 CSRF 的诸多途径中的一条，但绝对不是唯一的一条**。一般习惯上把通过 XSS 来实现的 CSRF 称为 XSRF。\r\n\r\nCSRF 的全称是“跨站请求伪造”。**CSRF 的全称是“跨站请求伪造”，而 XSS 的全称是“跨站脚本”**。看起来有点相似，它们都是属于跨站攻击——不攻击服务器端而攻击正常访问网站的用户。CSRF 顾名思义，是伪造请求，冒充用户在站内的正常操作。我们知道，绝大多数网站是通过 cookie 等方式辨识用户身份（包括使用服务器端 Session 的网站，因为 Session ID 也是大多保存在 cookie 里面的），再予以授权的。所以要伪造用户的正常操作，最好的方法是通过 XSS 或链接欺骗等途径，让用户在本机（即拥有身份 cookie 的浏览器端）发起用户所不知道的请求。\r\n\r\nCSRF 并不一定要有站内的输入，因为它并不属于注入攻击，而是请求伪造。被伪造的请求可以是任何来源，而非一定是站内。所以我们唯有一条路可行，就是过滤请求的处理者。\r\n\r\n首先可以提高的一个门槛，就是改良站内 API 的设计。对于发布帖子这一类创建资源的操作，应该只接受 POST 请求，而 GET 请求应该只浏览而不改变服务器端资源。\r\n\r\n接下来我们就可以用比较简单也比较有效的方法来防御 CSRF，这个方法就是“请求令牌”。实现方法非常简单，首先服务器端要以某种策略生成随机字符串，作为令牌（token），保存在 Session 里。然后在发出请求的页面，把该令牌以隐藏域一类的形式，与其他信息一并发出。在接收请求的页面，把接收到的信息中的令牌与 Session 中的令牌比较，只有一致的时候才处理请求，否则返回 HTTP 403 拒绝请求或者要求用户重新登录验证身份。\r\n\r\n如下也列出一些据说能有效防范 CSRF，其实效果甚微的方式甚至无效的做法：\r\n通过 referer 判定来源页面：referer 是在 HTTP Request Head 里面的，也就是由请求的发送者决定的。如果我喜欢，可以给 referer 任何值。当然这个做法并不是毫无作用，起码可以防小白。但我觉得性价比不如令牌。\r\n\r\n过滤所有用户发布的链接：这个是最无效的做法，因为首先攻击者不一定要从站内发起请求（上面提到过了），而且就算从站内发起请求，途径也远远不止链接一条。比如 <img src=”./create_post.php” /> 就是个不错的选择，还不需要用户去点击，只要用户的浏览器会自动加载图片，就会自动发起请求。\r\n\r\n在请求发起页面用 alert 弹窗提醒用户：这个方法看上去能干扰站外通过 iframe 发起的 CSRF，但攻击者也可以考虑用 window.alert = function(){}; 把 alert 弄哑，或者干脆脱离 iframe，使用 Flash 来达到目的。\r\n', '<h1 id=\"h1--sql-\"><a name=\"一. 防止SQL注入\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一. 防止SQL注入</h1><h2 id=\"h2-1-\"><a name=\"1 危害\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1 危害</h2><ol>\r\n<li>攻击者可以利用它读取、修改或者删除数据库内的数据，获取数据库中的用户名和密码等敏感信息</li><li>甚至可以 获得数据库管理员的权限。</li><li>如果能够再利用SQLServer扩展存储过程和自定义扩展存储过程来执行一些系统命令，攻击者还可以获得该系统的控制权。</li><li>SQL Injection 也很难防范。网站管理员无法通过安装系统补丁或者进行简单的安全配置进行自我保护，一般的防火墙也无法拦截SQL Injection 攻击。</li></ol>\r\n<h2 id=\"h2-2-\"><a name=\"2 原理\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2 原理</h2><p>结构化查询语言(SQL)是一种用来和数据库交互的文本语言。SQL Injection 就是利用某些数据库的外部接口把用户数据插入到实际的数据库操作语言(SQL)当中，从而达到入侵数据库乃至操作系统的目的。它的产生主要是由于程序对用户输入 的数据没有进行严格的过滤，导致非法数据库查询语句的执行。</p>\r\n<h2 id=\"h2-3-\"><a name=\"3 注入方式举例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3 注入方式举例</h2><p>例如下面的用户登陆验证程序：</p>\r\n<pre><code class=\"lang-php\">$sql = &quot;SELECT * FROM user WHERE username=&#39;$username&#39; AND password=&#39;$password&#39;&quot;;\r\n$result = mysql_db_query($dbname, $sql);\r\n</code></pre>\r\n<ol>\r\n<li><p>or 注入<br>如果我们提交如下url：<br><code>http://127.0.0.1/injection/user.php?username=angel&#39;or&#39;1=1</code><br>这个sql就变成：</p>\r\n<pre><code class=\"lang-sql\">SELECT * FROM user WHERE username=’angel’ or ‘1=1’ AND password=’$password\r\n</code></pre>\r\n<p>password部分就被这个or给怼没了，那么就可以不输入密码成功登陆系统</p>\r\n</li><li><p>注释注入<br>同样我们也可以利用sql的注释语句实现sql注入，如下面的例子：<br><code>http://127.0.0.1/injection/user.php?username=angel&#39;/*</code><br><code>http://127.0.0.1/injection/user.php?username=angel&#39;%23</code><br>根据mysql的特性，mysql支持/*和#两种注释格式，所以我们提交的时候是把后面的代码注释掉，值得注意的是由于编码问题，在地址栏里提交#会变成空的，所以我们在地址栏提交的时候，应该提交%23，才会变成#，就成功注释了。</p>\r\n</li><li><p>SQL注入语句大全<br><a href=\"http://blog.csdn.net/zzq19860626/article/details/10220427\">http://blog.csdn.net/zzq19860626/article/details/10220427</a></p>\r\n</li></ol>\r\n<h2 id=\"h2-4-\"><a name=\"4 需要注意以下几个要点\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4 需要注意以下几个要点</h2><ol>\r\n<li>永远不要信任用户的输入。对用户的输入进行校验，可以通过正则表达式，或限制长度；对单引号和 双”-“进行转换等。</li><li>永远不要使用动态拼装sql，可以使用参数化的sql或者直接使用存储过程进行数据查询存取。</li><li>永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。</li><li>不要把机密信息直接存放，加密或者hash掉密码和敏感的信息。</li><li>应用的异常信息应该给出尽可能少的提示，最好使用自定义的错误信息对原始错误信息进行包装</li></ol>\r\n<h2 id=\"h2-5-php-\"><a name=\"5 PHP中我们如何解决\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5 PHP中我们如何解决</h2><h3 id=\"h3-1-php-\"><a name=\"1） PHP手册介绍的预防措施\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1） PHP手册介绍的预防措施</h3><p>PHP手册的SQL注入部分：<a href=\"http://php.net/manual/zh/security.database.sql-injection.php\" title=\"http://php.net/manual/zh/security.database.sql-injection.php\">http://php.net/manual/zh/security.database.sql-injection.php</a></p>\r\n<ul>\r\n<li>永远不要使用超级用户或所有者帐号去连接数据库。要用权限被严格限制的帐号。</li><li>检查输入的数据是否具有所期望的数据格式。PHP 有很多可以用于检查输入的函数，从简单的变量函数和字符类型函数（比如 is_numeric()，ctype_digit()）到复杂的 Perl 兼容正则表达式函数都可以完成这个工作。</li><li>如果程序等待输入一个数字，可以考虑使用 is_numeric() 来检查，或者直接使用 settype() 来转换它的类型，也可以用 sprintf() 把它格式化为数字。</li><li>使用数据库特定的敏感字符转义函数（比如 mysql_escape_string() 和 sql_escape_string()）把用户提交上来的非数字数据进行转义。如果数据库没有专门的敏感字符转义功能的话 addslashes() 和 str_replace() 可以代替完成这个工作。</li><li>要不择手段避免显示出任何有关数据库的信心，尤其是数据库结构。参见错误报告和错误处理函数。</li><li>也可以选择使用数据库的存储过程和预定义指针等特性来抽象数库访问，使用户不能直接访问数据表和视图。但这个办法又有别的影响。</li><li>在允许的情况下，使用代码或数据库系统保存查询日志也是一个好办法。显然，日志并不能防止任何攻击，但利用它可以跟踪到哪个程序曾经被尝试攻击过。日志本身没用，要查阅其中包含的信息才行。毕竟，更多的信息总比没有要好。</li></ul>\r\n<h3 id=\"h3-2-pdo-sql-\"><a name=\"2）使用PDO防止SQL注入\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2）使用PDO防止SQL注入</h3><p>PDO防注入原理分析以及使用PDO的注意事项：<a href=\"https://my.oschina.net/zxu/blog/148432\" title=\"https://my.oschina.net/zxu/blog/148432\">https://my.oschina.net/zxu/blog/148432</a></p>\r\n<h1 id=\"h1--\"><a name=\"二. 验证码\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二. 验证码</h1><p>对于识别验证码的程序来说，最难的部分是验证字符的切割和特征码的建立，而国内很多程序员只做验证码时，总是喜欢在验证码加很多干扰素，干扰线，影响效果不说，还达不到很好的效果；所以，要想使自己验证码难于本识别，只做下面两点就够了</p>\r\n<ul>\r\n<li>字符粘连，最好所有的字符都有粘连的部分；</li><li>不要使用规格字符，验证码的各个部分使用不同比例的缩放或者旋转。</li></ul>\r\n<p>只要做到这两点，或者这两点的变形，识别程序就很难识别。</p>\r\n<h1 id=\"h1--\"><a name=\"三. 刷新提交\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>三. 刷新提交</h1><h2 id=\"h2-u573Au666F\"><a name=\"场景\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>场景</h2><ul>\r\n<li>点击提交按钮两次。</li><li>点击刷新按钮。</li><li>使用浏览器后退按钮重复之前的操作，导致重复提交表单。</li><li>使用浏览器历史记录重复提交表单。</li><li>浏览器重复的HTTP请求。</li></ul>\r\n<p>用户提交表单时可能因为网速的原因，或者网页被恶意刷新，致使同一条记录重复插入到数据库中，这是一个比较棘手的问题。我们可以从客户端和服务器端一起着手，设法避免同一表单的重复提交。</p>\r\n<h2 id=\"h2-u6709u6548u7B56u7565\"><a name=\"有效策略\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>有效策略</h2><ul>\r\n<li>js禁掉提交按钮。<br>表单提交后使用Javascript使提交按钮disable。这种方法防止心急的用户多次点击按钮。但有个问题，如果客户端把Javascript给禁止掉，这种方法就无效了。</li><li>使用Post/Redirect/Get模式。<br>在提交后执行页面重定向，这就是所谓的Post-Redirect-Get (PRG)模式。简言之，当用户提交了表单后，你去执行一个客户端的重定向，转到提交成功信息页面。这能避免用户按F5导致的重复提交，而其也不会出现浏览器表单重复提交的警告，也能消除按浏览器前进和后退按导致的同样问题。</li><li>在session中存放一个特殊标志。<br>当表单页面被请求时，生成一个特殊的字符标志串，存在session中，同时放在表单的隐藏域里。接受处理表单数据时，检查标识字串是否存在，并立即从session中删除它，然后正常处理数据。<br>如果发现表单提交里没有有效的标志串，这说明表单已经被提交过了，忽略这次提交。</li><li>使用header函数转向<br>当用户提交表单，服务器端处理后立即转向其他的页面，代码如下所示。<pre><code>if (isset($_POST[&#39;action&#39;]) &amp;&amp; $_POST[&#39;action&#39;] == &#39;submitted&#39;) {\r\n   //处理数据，如插入数据后，立即转向到其他页面\r\n   header(&#39;location:submits_success.php&#39;);\r\n}\r\n</code></pre>这样，即使用户使用刷新键，也不会导致表单的重复提交，因为已经转向新的页面，而这个页面脚本已经不理会任何提交的数据了。</li><li>在数据库里添加约束。<br>在数据库里添加唯一约束或创建唯一索引，防止出现重复数据。这是最有效的防止重复提交数据的方法。</li><li>使用Cookie处理<br>使用Cookie记录表单提交的状态，根据其状态可以检查是否已经提交表单。如果客户端禁止了Cookie，该方法将不起任何作用，这点请注意。</li></ul>\r\n<h1 id=\"h1--dos-\"><a name=\"四. DOS攻击\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>四. DOS攻击</h1><p>防止 DDoS 攻击的方式：</p>\r\n<ul>\r\n<li>减少公开暴露</li><li>利用扩展和冗余</li><li>充足的网络带宽保证</li><li>分布式服务拒绝 DDoS 攻击</li><li>实时监控系统性能</li><li>修改配置；这里提供一个简单的参考方法，修改php.ini文件<ul>\r\n<li>“disable_functions”改成gzinflate，默认是放空</li><li>”allow_url_fopen“设为Off</li><li>php_sockets.dll 把这个模块打开<br>重启使配置生效，一般可以抵御掉DDOS攻击。</li></ul>\r\n</li></ul>\r\n<p>参考资料：<br>51CTOblog的DDOS攻击与防御专题：<a href=\"http://blog.51cto.com/zt/282\" title=\"http://blog.51cto.com/zt/282\">http://blog.51cto.com/zt/282</a></p>\r\n<h1 id=\"h1--\"><a name=\"五. 跨域攻击\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>五. 跨域攻击</h1><blockquote>\r\n<p>注：以下内容摘自：<a href=\"https://blog.tonyseek.com/post/introduce-to-xss-and-csrf/\" title=\"https://blog.tonyseek.com/post/introduce-to-xss-and-csrf/\">https://blog.tonyseek.com/post/introduce-to-xss-and-csrf/</a></p>\r\n</blockquote>\r\n<h2 id=\"h2-xss\"><a name=\"XSS\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>XSS</h2><p>XSS全称“跨站脚本”，是注入攻击的一种。其特点是不对服务器端造成任何伤害，而是通过一些正常的站内交互途径，例如发布评论，提交含有 JavaScript 的内容文本。这时服务器端如果没有过滤或转义掉这些脚本，作为内容发布到了页面上，其他用户访问这个页面的时候就会运行这些脚本。</p>\r\n<p><strong>防止 XSS 的根本之道还是过滤用户输入。</strong>用户输入总是不可信任的，这点对于 Web 开发者应该是常识。</p>\r\n<p>如果我们不需要用户输入 HTML 而只想让他们输入纯文本，那么把所有用户输入进行 HTML 转义输出是个不错的做法。似乎很多 Web 开发框架、模版引擎的开发者也发现了这一点，Django 内置模版和 Jinja2 模版总是默认转义输出变量的。如果没有使用它们，我们自己也可以这么做。<strong>PHP 可以用 htmlspecialchars 函数</strong>，<strong>Python 可以导入 cgi 模块用其中的 cgi.escape 函数</strong>。如果使用了某款模版引擎，那么其必自带了方便快捷的转义方式。</p>\r\n<p>对于复杂的情况，简单的方法就是白名单重新整理。“白名单”消毒 HTML 标签和属性（Sanitize HTML）的开源解决方案：</p>\r\n<ul>\r\n<li>JavaScript: sanitize-html</li><li>PHP: htmlpurifier</li></ul>\r\n<h2 id=\"h2-csrf\"><a name=\"CSRF\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>CSRF</h2><p>CSRF 和 XSS 根本是两个不同维度上的分类。<strong>XSS 是实现 CSRF 的诸多途径中的一条，但绝对不是唯一的一条</strong>。一般习惯上把通过 XSS 来实现的 CSRF 称为 XSRF。</p>\r\n<p>CSRF 的全称是“跨站请求伪造”。<strong>CSRF 的全称是“跨站请求伪造”，而 XSS 的全称是“跨站脚本”</strong>。看起来有点相似，它们都是属于跨站攻击——不攻击服务器端而攻击正常访问网站的用户。CSRF 顾名思义，是伪造请求，冒充用户在站内的正常操作。我们知道，绝大多数网站是通过 cookie 等方式辨识用户身份（包括使用服务器端 Session 的网站，因为 Session ID 也是大多保存在 cookie 里面的），再予以授权的。所以要伪造用户的正常操作，最好的方法是通过 XSS 或链接欺骗等途径，让用户在本机（即拥有身份 cookie 的浏览器端）发起用户所不知道的请求。</p>\r\n<p>CSRF 并不一定要有站内的输入，因为它并不属于注入攻击，而是请求伪造。被伪造的请求可以是任何来源，而非一定是站内。所以我们唯有一条路可行，就是过滤请求的处理者。</p>\r\n<p>首先可以提高的一个门槛，就是改良站内 API 的设计。对于发布帖子这一类创建资源的操作，应该只接受 POST 请求，而 GET 请求应该只浏览而不改变服务器端资源。</p>\r\n<p>接下来我们就可以用比较简单也比较有效的方法来防御 CSRF，这个方法就是“请求令牌”。实现方法非常简单，首先服务器端要以某种策略生成随机字符串，作为令牌（token），保存在 Session 里。然后在发出请求的页面，把该令牌以隐藏域一类的形式，与其他信息一并发出。在接收请求的页面，把接收到的信息中的令牌与 Session 中的令牌比较，只有一致的时候才处理请求，否则返回 HTTP 403 拒绝请求或者要求用户重新登录验证身份。</p>\r\n<p>如下也列出一些据说能有效防范 CSRF，其实效果甚微的方式甚至无效的做法：<br>通过 referer 判定来源页面：referer 是在 HTTP Request Head 里面的，也就是由请求的发送者决定的。如果我喜欢，可以给 referer 任何值。当然这个做法并不是毫无作用，起码可以防小白。但我觉得性价比不如令牌。</p>\r\n<p>过滤所有用户发布的链接：这个是最无效的做法，因为首先攻击者不一定要从站内发起请求（上面提到过了），而且就算从站内发起请求，途径也远远不止链接一条。比如 &lt;img src=”./create_post.php” /&gt; 就是个不错的选择，还不需要用户去点击，只要用户的浏览器会自动加载图片，就会自动发起请求。</p>\r\n<p>在请求发起页面用 alert 弹窗提醒用户：这个方法看上去能干扰站外通过 iframe 发起的 CSRF，但攻击者也可以考虑用 window.alert = function(){}; 把 alert 弄哑，或者干脆脱离 iframe，使用 Flash 来达到目的。</p>\r\n', '', 0, 'publish', 1, 0, '/article/30.html', '', 0, 81, '2017-01-11 08:30:56', '2017-01-11 08:30:56', '2018-01-09 03:28:34', NULL);
INSERT INTO `pt_post` VALUES (31, 10, 'article', 'Git——基本概念理解', '# Git文件三种状态\r\n- 已提交（committed）表示数据已经安全的保存在本地数据库中。\r\n- 已修改（modified）表示修改了文件，但还没保存到数据库中。\r\n- 已暂存（staged）表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。\r\n\r\n# Git 项目的三个工作区域\r\n- Git 仓库目录：是 Git 用来保存项目的元数据和对象数据库的地方。 这是 Git 中最重要的部分，从其它计算机克隆仓库时，拷贝的就是这里的数据。 （’Git目录’ 一般就是指项目根目录下的’.git’目录）\r\n- 工作目录：是对项目的某个版本独立提取出来的内容。 这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。\r\n- 暂存区域：是一个文件，保存了下次将提交的文件列表信息，一般在 Git 仓库目录中。 有时候也被称作`‘索引’’，不过一般说法还是叫暂存区域。\r\n\r\n![](https://www.goozp.com/uploads/2018/01/git_1.png)\r\n\r\n根据上面的图片，下面给出了每个部分的简要说明：\r\n- Directory：使用Git管理的一个目录，也就是一个仓库，包含我们的工作空间和Git的管理空间。\r\n- WorkSpace：需要通过Git进行版本控制的目录和文件，这些目录和文件组成了工作空间。\r\n- .git：存放Git管理信息的目录，初始化仓库的时候自动创建。\r\n- Index/Stage：暂存区，或者叫待提交更新区，在提交进入repo之前，我们可以把所有的更新放在暂存区。\r\n- Local Repo：本地仓库，一个存放在本地的版本库；HEAD会只是当前的开发分支（branch）。\r\n- Stash：是一个工作状态保存栈，用于保存/恢复WorkSpace中的临时状态。\r\n\r\n# Git 工作流程\r\n基本的 Git 工作流程如下：\r\n- 在工作目录中修改文件。\r\n- 暂存文件，将文件的快照放入暂存区域。\r\n- 提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录。\r\n\r\n# 使用 Git 时文件的生命周期\r\n![](https://www.goozp.com/uploads/2018/01/git_2.png)\r\n', '<h1 id=\"h1-git-\"><a name=\"Git文件三种状态\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Git文件三种状态</h1><ul>\r\n<li>已提交（committed）表示数据已经安全的保存在本地数据库中。</li><li>已修改（modified）表示修改了文件，但还没保存到数据库中。</li><li>已暂存（staged）表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。</li></ul>\r\n<h1 id=\"h1-git-\"><a name=\"Git 项目的三个工作区域\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Git 项目的三个工作区域</h1><ul>\r\n<li>Git 仓库目录：是 Git 用来保存项目的元数据和对象数据库的地方。 这是 Git 中最重要的部分，从其它计算机克隆仓库时，拷贝的就是这里的数据。 （’Git目录’ 一般就是指项目根目录下的’.git’目录）</li><li>工作目录：是对项目的某个版本独立提取出来的内容。 这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。</li><li>暂存区域：是一个文件，保存了下次将提交的文件列表信息，一般在 Git 仓库目录中。 有时候也被称作`‘索引’’，不过一般说法还是叫暂存区域。</li></ul>\r\n<p><img src=\"https://www.goozp.com/uploads/2018/01/git_1.png\" alt=\"\"></p>\r\n<p>根据上面的图片，下面给出了每个部分的简要说明：</p>\r\n<ul>\r\n<li>Directory：使用Git管理的一个目录，也就是一个仓库，包含我们的工作空间和Git的管理空间。</li><li>WorkSpace：需要通过Git进行版本控制的目录和文件，这些目录和文件组成了工作空间。</li><li>.git：存放Git管理信息的目录，初始化仓库的时候自动创建。</li><li>Index/Stage：暂存区，或者叫待提交更新区，在提交进入repo之前，我们可以把所有的更新放在暂存区。</li><li>Local Repo：本地仓库，一个存放在本地的版本库；HEAD会只是当前的开发分支（branch）。</li><li>Stash：是一个工作状态保存栈，用于保存/恢复WorkSpace中的临时状态。</li></ul>\r\n<h1 id=\"h1-git-\"><a name=\"Git 工作流程\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Git 工作流程</h1><p>基本的 Git 工作流程如下：</p>\r\n<ul>\r\n<li>在工作目录中修改文件。</li><li>暂存文件，将文件的快照放入暂存区域。</li><li>提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录。</li></ul>\r\n<h1 id=\"h1--git-\"><a name=\"使用 Git 时文件的生命周期\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>使用 Git 时文件的生命周期</h1><p><img src=\"https://www.goozp.com/uploads/2018/01/git_2.png\" alt=\"\"></p>\r\n', '', 0, 'publish', 1, 0, '/article/31.html', 'https://www.goozp.com/uploads/2018/01/git_square_logo.png', 0, 95, '2017-02-08 07:57:52', '2017-02-08 07:57:52', '2018-01-09 04:53:26', NULL);
INSERT INTO `pt_post` VALUES (32, 10, 'article', '常用 Git 命令清单', '> 注：本文转载自 阮一峰的网络日志，原文地址为[常用 Git 命令清单](http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html?20170208142509 \"常用 Git 命令清单\")。\r\n\r\n我每天使用 Git ，但是很多命令记不住。\r\n\r\n一般来说，日常使用只要记住下图6个命令，就可以了。但是熟练使用，恐怕要记住60～100个命令。\r\n![](https://www.goozp.com/uploads/2018/01/bg2015120901.png)\r\n\r\n下面是我整理的常用 Git 命令清单。几个专用名词的译名如下。\r\n- Workspace：工作区\r\n- Index / Stage：暂存区\r\n- Repository：仓库区（或本地仓库）\r\n- Remote：远程仓库\r\n\r\n# 一、新建代码库\r\n```\r\n# 在当前目录新建一个Git代码库\r\n$ git init\r\n\r\n# 新建一个目录，将其初始化为Git代码库\r\n$ git init [project-name]\r\n\r\n# 下载一个项目和它的整个代码历史\r\n$ git clone [url]\r\n```\r\n\r\n# 二、配置\r\nGit的设置文件为 .gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。\r\n```\r\n# 显示当前的Git配置\r\n$ git config --list\r\n\r\n# 编辑Git配置文件\r\n$ git config -e [--global]\r\n\r\n# 设置提交代码时的用户信息\r\n$ git config [--global] user.name \"[name]\"\r\n$ git config [--global] user.email \"[email address]\"\r\n```\r\n\r\n# 三、增加/删除文件\r\n```\r\n# 添加指定文件到暂存区\r\n$ git add [file1] [file2] ...\r\n\r\n# 添加指定目录到暂存区，包括子目录\r\n$ git add [dir]\r\n\r\n# 添加当前目录的所有文件到暂存区\r\n$ git add .\r\n\r\n# 添加每个变化前，都会要求确认\r\n# 对于同一个文件的多处变化，可以实现分次提交\r\n$ git add -p\r\n\r\n# 删除工作区文件，并且将这次删除放入暂存区\r\n$ git rm [file1] [file2] ...\r\n\r\n# 停止追踪指定文件，但该文件会保留在工作区\r\n$ git rm --cached [file]\r\n\r\n# 改名文件，并且将这个改名放入暂存区\r\n$ git mv [file-original] [file-renamed]\r\n```\r\n\r\n# 四、代码提交\r\n```\r\n# 提交暂存区到仓库区\r\n$ git commit -m [message]\r\n\r\n# 提交暂存区的指定文件到仓库区\r\n$ git commit [file1] [file2] ... -m [message]\r\n\r\n# 提交工作区自上次commit之后的变化，直接到仓库区\r\n$ git commit -a\r\n\r\n# 提交时显示所有diff信息\r\n$ git commit -v\r\n\r\n# 使用一次新的commit，替代上一次提交\r\n# 如果代码没有任何新变化，则用来改写上一次commit的提交信息\r\n$ git commit --amend -m [message]\r\n\r\n# 重做上一次commit，并包括指定文件的新变化\r\n$ git commit --amend [file1] [file2] ...\r\n```\r\n\r\n# 五、分支\r\n```\r\n# 列出所有本地分支\r\n$ git branch\r\n\r\n# 列出所有远程分支\r\n$ git branch -r\r\n\r\n# 列出所有本地分支和远程分支\r\n$ git branch -a\r\n\r\n# 新建一个分支，但依然停留在当前分支\r\n$ git branch [branch-name]\r\n\r\n# 新建一个分支，并切换到该分支\r\n$ git checkout -b [branch]\r\n\r\n# 新建一个分支，指向指定commit\r\n$ git branch [branch] [commit]\r\n\r\n# 新建一个分支，与指定的远程分支建立追踪关系\r\n$ git branch --track [branch] [remote-branch]\r\n\r\n# 切换到指定分支，并更新工作区\r\n$ git checkout [branch-name]\r\n\r\n# 切换到上一个分支\r\n$ git checkout -\r\n\r\n# 建立追踪关系，在现有分支与指定的远程分支之间\r\n$ git branch --set-upstream [branch] [remote-branch]\r\n\r\n# 合并指定分支到当前分支\r\n$ git merge [branch]\r\n\r\n# 选择一个commit，合并进当前分支\r\n$ git cherry-pick [commit]\r\n\r\n# 删除分支\r\n$ git branch -d [branch-name]\r\n\r\n# 删除远程分支\r\n$ git push origin --delete [branch-name]\r\n$ git branch -dr [remote/branch]\r\n```\r\n\r\n# 六、标签\r\n```\r\n# 列出所有tag\r\n$ git tag\r\n\r\n# 新建一个tag在当前commit\r\n$ git tag [tag]\r\n\r\n# 新建一个tag在指定commit\r\n$ git tag [tag] [commit]\r\n\r\n# 删除本地tag\r\n$ git tag -d [tag]\r\n\r\n# 删除远程tag\r\n$ git push origin :refs/tags/[tagName]\r\n\r\n# 查看tag信息\r\n$ git show [tag]\r\n\r\n# 提交指定tag\r\n$ git push [remote] [tag]\r\n\r\n# 提交所有tag\r\n$ git push [remote] --tags\r\n\r\n# 新建一个分支，指向某个tag\r\n$ git checkout -b [branch] [tag]\r\n```\r\n\r\n# 七、查看信息\r\n```\r\n# 显示有变更的文件\r\n$ git status\r\n\r\n# 显示当前分支的版本历史\r\n$ git log\r\n\r\n# 显示commit历史，以及每次commit发生变更的文件\r\n$ git log --stat\r\n\r\n# 搜索提交历史，根据关键词\r\n$ git log -S [keyword]\r\n\r\n# 显示某个commit之后的所有变动，每个commit占据一行\r\n$ git log [tag] HEAD --pretty=format:%s\r\n\r\n# 显示某个commit之后的所有变动，其\"提交说明\"必须符合搜索条件\r\n$ git log [tag] HEAD --grep feature\r\n\r\n# 显示某个文件的版本历史，包括文件改名\r\n$ git log --follow [file]\r\n$ git whatchanged [file]\r\n\r\n# 显示指定文件相关的每一次diff\r\n$ git log -p [file]\r\n\r\n# 显示过去5次提交\r\n$ git log -5 --pretty --oneline\r\n\r\n# 显示所有提交过的用户，按提交次数排序\r\n$ git shortlog -sn\r\n\r\n# 显示指定文件是什么人在什么时间修改过\r\n$ git blame [file]\r\n\r\n# 显示暂存区和工作区的差异\r\n$ git diff\r\n\r\n# 显示暂存区和上一个commit的差异\r\n$ git diff --cached [file]\r\n\r\n# 显示工作区与当前分支最新commit之间的差异\r\n$ git diff HEAD\r\n\r\n# 显示两次提交之间的差异\r\n$ git diff [first-branch]...[second-branch]\r\n\r\n# 显示今天你写了多少行代码\r\n$ git diff --shortstat \"@{0 day ago}\"\r\n\r\n# 显示某次提交的元数据和内容变化\r\n$ git show [commit]\r\n\r\n# 显示某次提交发生变化的文件\r\n$ git show --name-only [commit]\r\n\r\n# 显示某次提交时，某个文件的内容\r\n$ git show [commit]:[filename]\r\n\r\n# 显示当前分支的最近几次提交\r\n$ git reflog\r\n```\r\n\r\n# 八、远程同步\r\n```\r\n# 下载远程仓库的所有变动\r\n$ git fetch [remote]\r\n\r\n# 显示所有远程仓库\r\n$ git remote -v\r\n\r\n# 显示某个远程仓库的信息\r\n$ git remote show [remote]\r\n\r\n# 增加一个新的远程仓库，并命名\r\n$ git remote add [shortname] [url]\r\n\r\n# 取回远程仓库的变化，并与本地分支合并\r\n$ git pull [remote] [branch]\r\n\r\n# 上传本地指定分支到远程仓库\r\n$ git push [remote] [branch]\r\n\r\n# 强行推送当前分支到远程仓库，即使有冲突\r\n$ git push [remote] --force\r\n\r\n# 推送所有分支到远程仓库\r\n$ git push [remote] --all\r\n```\r\n\r\n# 九、撤销\r\n```\r\n# 恢复暂存区的指定文件到工作区\r\n$ git checkout [file]\r\n\r\n# 恢复某个commit的指定文件到暂存区和工作区\r\n$ git checkout [commit] [file]\r\n\r\n# 恢复暂存区的所有文件到工作区\r\n$ git checkout .\r\n\r\n# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变\r\n$ git reset [file]\r\n\r\n# 重置暂存区与工作区，与上一次commit保持一致\r\n$ git reset --hard\r\n\r\n# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变\r\n$ git reset [commit]\r\n\r\n# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致\r\n$ git reset --hard [commit]\r\n\r\n# 重置当前HEAD为指定commit，但保持暂存区和工作区不变\r\n$ git reset --keep [commit]\r\n\r\n# 新建一个commit，用来撤销指定commit\r\n# 后者的所有变化都将被前者抵消，并且应用到当前分支\r\n$ git revert [commit]\r\n\r\n# 暂时将未提交的变化移除，稍后再移入\r\n$ git stash\r\n$ git stash pop\r\n```\r\n\r\n# 十、其他\r\n```\r\n# 生成一个可供发布的压缩包\r\n$ git archive\r\n```', '<blockquote>\r\n<p>注：本文转载自 阮一峰的网络日志，原文地址为<a href=\"http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html?20170208142509\" title=\"常用 Git 命令清单\">常用 Git 命令清单</a>。</p>\r\n</blockquote>\r\n<p>我每天使用 Git ，但是很多命令记不住。</p>\r\n<p>一般来说，日常使用只要记住下图6个命令，就可以了。但是熟练使用，恐怕要记住60～100个命令。<br><img src=\"https://www.goozp.com/uploads/2018/01/bg2015120901.png\" alt=\"\"></p>\r\n<p>下面是我整理的常用 Git 命令清单。几个专用名词的译名如下。</p>\r\n<ul>\r\n<li>Workspace：工作区</li><li>Index / Stage：暂存区</li><li>Repository：仓库区（或本地仓库）</li><li>Remote：远程仓库</li></ul>\r\n<h1 id=\"h1--\"><a name=\"一、新建代码库\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一、新建代码库</h1><pre><code># 在当前目录新建一个Git代码库\r\n$ git init\r\n\r\n# 新建一个目录，将其初始化为Git代码库\r\n$ git init [project-name]\r\n\r\n# 下载一个项目和它的整个代码历史\r\n$ git clone [url]\r\n</code></pre><h1 id=\"h1--\"><a name=\"二、配置\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二、配置</h1><p>Git的设置文件为 .gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。</p>\r\n<pre><code># 显示当前的Git配置\r\n$ git config --list\r\n\r\n# 编辑Git配置文件\r\n$ git config -e [--global]\r\n\r\n# 设置提交代码时的用户信息\r\n$ git config [--global] user.name &quot;[name]&quot;\r\n$ git config [--global] user.email &quot;[email address]&quot;\r\n</code></pre><h1 id=\"h1--\"><a name=\"三、增加/删除文件\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>三、增加/删除文件</h1><pre><code># 添加指定文件到暂存区\r\n$ git add [file1] [file2] ...\r\n\r\n# 添加指定目录到暂存区，包括子目录\r\n$ git add [dir]\r\n\r\n# 添加当前目录的所有文件到暂存区\r\n$ git add .\r\n\r\n# 添加每个变化前，都会要求确认\r\n# 对于同一个文件的多处变化，可以实现分次提交\r\n$ git add -p\r\n\r\n# 删除工作区文件，并且将这次删除放入暂存区\r\n$ git rm [file1] [file2] ...\r\n\r\n# 停止追踪指定文件，但该文件会保留在工作区\r\n$ git rm --cached [file]\r\n\r\n# 改名文件，并且将这个改名放入暂存区\r\n$ git mv [file-original] [file-renamed]\r\n</code></pre><h1 id=\"h1--\"><a name=\"四、代码提交\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>四、代码提交</h1><pre><code># 提交暂存区到仓库区\r\n$ git commit -m [message]\r\n\r\n# 提交暂存区的指定文件到仓库区\r\n$ git commit [file1] [file2] ... -m [message]\r\n\r\n# 提交工作区自上次commit之后的变化，直接到仓库区\r\n$ git commit -a\r\n\r\n# 提交时显示所有diff信息\r\n$ git commit -v\r\n\r\n# 使用一次新的commit，替代上一次提交\r\n# 如果代码没有任何新变化，则用来改写上一次commit的提交信息\r\n$ git commit --amend -m [message]\r\n\r\n# 重做上一次commit，并包括指定文件的新变化\r\n$ git commit --amend [file1] [file2] ...\r\n</code></pre><h1 id=\"h1--\"><a name=\"五、分支\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>五、分支</h1><pre><code># 列出所有本地分支\r\n$ git branch\r\n\r\n# 列出所有远程分支\r\n$ git branch -r\r\n\r\n# 列出所有本地分支和远程分支\r\n$ git branch -a\r\n\r\n# 新建一个分支，但依然停留在当前分支\r\n$ git branch [branch-name]\r\n\r\n# 新建一个分支，并切换到该分支\r\n$ git checkout -b [branch]\r\n\r\n# 新建一个分支，指向指定commit\r\n$ git branch [branch] [commit]\r\n\r\n# 新建一个分支，与指定的远程分支建立追踪关系\r\n$ git branch --track [branch] [remote-branch]\r\n\r\n# 切换到指定分支，并更新工作区\r\n$ git checkout [branch-name]\r\n\r\n# 切换到上一个分支\r\n$ git checkout -\r\n\r\n# 建立追踪关系，在现有分支与指定的远程分支之间\r\n$ git branch --set-upstream [branch] [remote-branch]\r\n\r\n# 合并指定分支到当前分支\r\n$ git merge [branch]\r\n\r\n# 选择一个commit，合并进当前分支\r\n$ git cherry-pick [commit]\r\n\r\n# 删除分支\r\n$ git branch -d [branch-name]\r\n\r\n# 删除远程分支\r\n$ git push origin --delete [branch-name]\r\n$ git branch -dr [remote/branch]\r\n</code></pre><h1 id=\"h1--\"><a name=\"六、标签\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>六、标签</h1><pre><code># 列出所有tag\r\n$ git tag\r\n\r\n# 新建一个tag在当前commit\r\n$ git tag [tag]\r\n\r\n# 新建一个tag在指定commit\r\n$ git tag [tag] [commit]\r\n\r\n# 删除本地tag\r\n$ git tag -d [tag]\r\n\r\n# 删除远程tag\r\n$ git push origin :refs/tags/[tagName]\r\n\r\n# 查看tag信息\r\n$ git show [tag]\r\n\r\n# 提交指定tag\r\n$ git push [remote] [tag]\r\n\r\n# 提交所有tag\r\n$ git push [remote] --tags\r\n\r\n# 新建一个分支，指向某个tag\r\n$ git checkout -b [branch] [tag]\r\n</code></pre><h1 id=\"h1--\"><a name=\"七、查看信息\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>七、查看信息</h1><pre><code># 显示有变更的文件\r\n$ git status\r\n\r\n# 显示当前分支的版本历史\r\n$ git log\r\n\r\n# 显示commit历史，以及每次commit发生变更的文件\r\n$ git log --stat\r\n\r\n# 搜索提交历史，根据关键词\r\n$ git log -S [keyword]\r\n\r\n# 显示某个commit之后的所有变动，每个commit占据一行\r\n$ git log [tag] HEAD --pretty=format:%s\r\n\r\n# 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件\r\n$ git log [tag] HEAD --grep feature\r\n\r\n# 显示某个文件的版本历史，包括文件改名\r\n$ git log --follow [file]\r\n$ git whatchanged [file]\r\n\r\n# 显示指定文件相关的每一次diff\r\n$ git log -p [file]\r\n\r\n# 显示过去5次提交\r\n$ git log -5 --pretty --oneline\r\n\r\n# 显示所有提交过的用户，按提交次数排序\r\n$ git shortlog -sn\r\n\r\n# 显示指定文件是什么人在什么时间修改过\r\n$ git blame [file]\r\n\r\n# 显示暂存区和工作区的差异\r\n$ git diff\r\n\r\n# 显示暂存区和上一个commit的差异\r\n$ git diff --cached [file]\r\n\r\n# 显示工作区与当前分支最新commit之间的差异\r\n$ git diff HEAD\r\n\r\n# 显示两次提交之间的差异\r\n$ git diff [first-branch]...[second-branch]\r\n\r\n# 显示今天你写了多少行代码\r\n$ git diff --shortstat &quot;@{0 day ago}&quot;\r\n\r\n# 显示某次提交的元数据和内容变化\r\n$ git show [commit]\r\n\r\n# 显示某次提交发生变化的文件\r\n$ git show --name-only [commit]\r\n\r\n# 显示某次提交时，某个文件的内容\r\n$ git show [commit]:[filename]\r\n\r\n# 显示当前分支的最近几次提交\r\n$ git reflog\r\n</code></pre><h1 id=\"h1--\"><a name=\"八、远程同步\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>八、远程同步</h1><pre><code># 下载远程仓库的所有变动\r\n$ git fetch [remote]\r\n\r\n# 显示所有远程仓库\r\n$ git remote -v\r\n\r\n# 显示某个远程仓库的信息\r\n$ git remote show [remote]\r\n\r\n# 增加一个新的远程仓库，并命名\r\n$ git remote add [shortname] [url]\r\n\r\n# 取回远程仓库的变化，并与本地分支合并\r\n$ git pull [remote] [branch]\r\n\r\n# 上传本地指定分支到远程仓库\r\n$ git push [remote] [branch]\r\n\r\n# 强行推送当前分支到远程仓库，即使有冲突\r\n$ git push [remote] --force\r\n\r\n# 推送所有分支到远程仓库\r\n$ git push [remote] --all\r\n</code></pre><h1 id=\"h1--\"><a name=\"九、撤销\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>九、撤销</h1><pre><code># 恢复暂存区的指定文件到工作区\r\n$ git checkout [file]\r\n\r\n# 恢复某个commit的指定文件到暂存区和工作区\r\n$ git checkout [commit] [file]\r\n\r\n# 恢复暂存区的所有文件到工作区\r\n$ git checkout .\r\n\r\n# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变\r\n$ git reset [file]\r\n\r\n# 重置暂存区与工作区，与上一次commit保持一致\r\n$ git reset --hard\r\n\r\n# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变\r\n$ git reset [commit]\r\n\r\n# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致\r\n$ git reset --hard [commit]\r\n\r\n# 重置当前HEAD为指定commit，但保持暂存区和工作区不变\r\n$ git reset --keep [commit]\r\n\r\n# 新建一个commit，用来撤销指定commit\r\n# 后者的所有变化都将被前者抵消，并且应用到当前分支\r\n$ git revert [commit]\r\n\r\n# 暂时将未提交的变化移除，稍后再移入\r\n$ git stash\r\n$ git stash pop\r\n</code></pre><h1 id=\"h1--\"><a name=\"十、其他\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>十、其他</h1><pre><code># 生成一个可供发布的压缩包\r\n$ git archive\r\n</code></pre>', '', 0, 'publish', 1, 0, '/article/32.html', 'https://www.goozp.com/uploads/2018/01/git_square_logo.png', 0, 101, '2017-02-08 08:11:37', '2017-02-08 08:11:37', '2018-01-09 04:54:28', NULL);
INSERT INTO `pt_post` VALUES (33, 10, 'article', '解决windows下php-cgi进程经常自动关闭', 'php-cgi在linux中有fpm管理，Apache不是采用cgi这种模式，于是乎就出现了，在windows下，采用nginx时，开启的php-cgi监听非常不稳定，经常奔溃关闭。现在解决了这个问题。注意是win32位系统下解决的，虽然服务器上64位系统也跑起来了，但是环境装的都是32位的。\r\n\r\n采用了这个叫xxfpm的FastCGI进程管理器：[xxfpm](http://xiaoxia.org/2011/02/01/xxfpm-wrote-a-fastcgi-process-manager/ \"xxfpm\")\r\n\r\n下载后运行xxfpm.exe，如果出现报错缺少pthreadgc2.dll，需要下载pthreads-win32：[http://sourceware.org/pthreads-win32/](http://sourceware.org/pthreads-win32/)\r\n![](https://www.goozp.com/uploads/2018/01/xxfpm1.png)\r\n将这个文件复制到C:/Windows/System32下（如果系统是64位的请将32位的dll文件复制到C:\\Windows\\SysWOW64目录）；\r\n然后打开“开始-运行-输入regsvr32 pthreadgc2.dll”，回车，如果报错，用下面的方法。\r\n\r\n新建一个文件“注册.bat“，内容：\r\n```\r\n@echo 开始注册\r\ncopy pthreadgc2.dll %windir%\\system32\\\r\nregsvr32 %windir%\\system32\\pthreadgc2.dll /s\r\n@echo pthreadgc2.dll注册成功\r\n@pause\r\n```\r\n双击注册.bat，就会自动完成pthreadgc2.dll注册（如果64位的系统安装32位的dll文件，请将system32替换为SysWOW64）。完了就可以将这个文件删了。\r\n\r\n接下里将下载下来的xxfpm目录copy到nginx下：\r\n![](https://www.goozp.com/uploads/2018/01/xxfpm2.png)\r\n\r\n为了方便修改一下当初安装nginx时的RunHiddenConsole启动关闭文件（如果你是在windows手动搭建Nginx环境这样安装的话）：\r\n修改start_nginx.bat为：\r\n```\r\n@echo off\r\nREM Windows 下无效\r\nREM set PHP_FCGI_CHILDREN=5\r\nREM 每个进程处理的最大请求数，或设置为 Windows 环境变量\r\nset PHP_FCGI_MAX_REQUESTS=1000\r\necho Starting PHP FastCGI…\r\nRunHiddenConsole D:/wnmp/nginx-1.10.2/xxfpm/bin/xxfpm.exe “D:/wnmp/php-5.6/php-cgi.exe -c D:/wnmp/php-5.6/php.ini” -n 5 -i 127.0.0.1 -p 9000\r\necho Starting nginx…\r\nRunHiddenConsole D:/wnmp/nginx-1.10.2/nginx.exe -p D:/wnmp/nginx-1.10.2\r\nexit\r\n```\r\n修改stop_nginx.bat为：\r\n```\r\n@echo off\r\necho Stopping nginx…\r\ntaskkill /F /IM nginx.exe > nul\r\necho Stopping PHP FastCGI…\r\ntaskkill /F /IM xxfpm.exe > nul\r\nexit\r\n```\r\n\r\n现在在开启nginx时，我们就同时开启了5个php-cgi进程，因为我们传了参数 -n 为5。\r\n![](https://www.goozp.com/uploads/2018/01/xxfpm3.png)\r\n如果我们手动断掉一个，会发现又多出来一个，还是5个。xxfpm将会管理php-cgi，将其维持在5个php-cgi进程，防止cgi进程崩溃关闭。还有一点注意，监听端口注意与nginx的配置文件对齐。', '<p>php-cgi在linux中有fpm管理，Apache不是采用cgi这种模式，于是乎就出现了，在windows下，采用nginx时，开启的php-cgi监听非常不稳定，经常奔溃关闭。现在解决了这个问题。注意是win32位系统下解决的，虽然服务器上64位系统也跑起来了，但是环境装的都是32位的。</p>\r\n<p>采用了这个叫xxfpm的FastCGI进程管理器：<a href=\"http://xiaoxia.org/2011/02/01/xxfpm-wrote-a-fastcgi-process-manager/\" title=\"xxfpm\">xxfpm</a></p>\r\n<p>下载后运行xxfpm.exe，如果出现报错缺少pthreadgc2.dll，需要下载pthreads-win32：<a href=\"http://sourceware.org/pthreads-win32/\">http://sourceware.org/pthreads-win32/</a><br><img src=\"https://www.goozp.com/uploads/2018/01/xxfpm1.png\" alt=\"\"><br>将这个文件复制到C:/Windows/System32下（如果系统是64位的请将32位的dll文件复制到C:\\Windows\\SysWOW64目录）；<br>然后打开“开始-运行-输入regsvr32 pthreadgc2.dll”，回车，如果报错，用下面的方法。</p>\r\n<p>新建一个文件“注册.bat“，内容：</p>\r\n<pre><code>@echo 开始注册\r\ncopy pthreadgc2.dll %windir%\\system32\\\r\nregsvr32 %windir%\\system32\\pthreadgc2.dll /s\r\n@echo pthreadgc2.dll注册成功\r\n@pause\r\n</code></pre><p>双击注册.bat，就会自动完成pthreadgc2.dll注册（如果64位的系统安装32位的dll文件，请将system32替换为SysWOW64）。完了就可以将这个文件删了。</p>\r\n<p>接下里将下载下来的xxfpm目录copy到nginx下：<br><img src=\"https://www.goozp.com/uploads/2018/01/xxfpm2.png\" alt=\"\"></p>\r\n<p>为了方便修改一下当初安装nginx时的RunHiddenConsole启动关闭文件（如果你是在windows手动搭建Nginx环境这样安装的话）：<br>修改start_nginx.bat为：</p>\r\n<pre><code>@echo off\r\nREM Windows 下无效\r\nREM set PHP_FCGI_CHILDREN=5\r\nREM 每个进程处理的最大请求数，或设置为 Windows 环境变量\r\nset PHP_FCGI_MAX_REQUESTS=1000\r\necho Starting PHP FastCGI…\r\nRunHiddenConsole D:/wnmp/nginx-1.10.2/xxfpm/bin/xxfpm.exe “D:/wnmp/php-5.6/php-cgi.exe -c D:/wnmp/php-5.6/php.ini” -n 5 -i 127.0.0.1 -p 9000\r\necho Starting nginx…\r\nRunHiddenConsole D:/wnmp/nginx-1.10.2/nginx.exe -p D:/wnmp/nginx-1.10.2\r\nexit\r\n</code></pre><p>修改stop_nginx.bat为：</p>\r\n<pre><code>@echo off\r\necho Stopping nginx…\r\ntaskkill /F /IM nginx.exe &gt; nul\r\necho Stopping PHP FastCGI…\r\ntaskkill /F /IM xxfpm.exe &gt; nul\r\nexit\r\n</code></pre><p>现在在开启nginx时，我们就同时开启了5个php-cgi进程，因为我们传了参数 -n 为5。<br><img src=\"https://www.goozp.com/uploads/2018/01/xxfpm3.png\" alt=\"\"><br>如果我们手动断掉一个，会发现又多出来一个，还是5个。xxfpm将会管理php-cgi，将其维持在5个php-cgi进程，防止cgi进程崩溃关闭。还有一点注意，监听端口注意与nginx的配置文件对齐。</p>\r\n', '', 0, 'publish', 1, 0, '/article/33.html', '', 0, 141, '2017-02-09 01:57:57', '2017-02-09 01:57:57', '2018-01-09 05:48:25', NULL);
INSERT INTO `pt_post` VALUES (34, 10, 'article', 'WordPress导航菜单开发', '最近做一个自己的主题，开始接触wordpress的二次开发。在导航菜单这一块，遇到一点小问题。其实网上的资料挺多，有一些也挺久远的，不过也都能用，毕竟wordpress没什么大改。但是这些资料实际上讲得不清楚，一开始误导了我。\r\n\r\n其实在主题中做导航菜单，我们只需要用到两个函数register_nav_menus()和wp_nav_menu() 。\r\n\r\n接下来看看怎么搞：\r\n# register_nav_menus()\r\n在主题的functions.php中注册菜单导航：\r\n```php\r\nregister_nav_menus( array(\r\n	\'header_menu\' => \'顶部导航菜单\',\r\n) );\r\n```\r\n\r\nheader_menu其实只是一个标志的key，对应的值为显示给用户的描述。那么，重点在于，这个注册导航菜单，并不是注册了一个导航菜单，而是打通了wordpress系统中的导航菜单与我们自制主题的导航菜单显示位置，提供给用户一个选择，实际上是这样的，在后台外观设置的菜单中，我们的菜单下面的菜单设置这里，多了一个可选项：\r\n![](https://www.goozp.com/uploads/2018/01/wp_nav_menu1.png)\r\n\r\n这个看起来不明确，我们可以看这个，在“自定义”这里：\r\n![](https://www.goozp.com/uploads/2018/01/wp_nav_menu2.png)\r\n\r\n这里是已经将菜单1设置为顶部导航菜单，因为我们已经给这个选项打了勾。\r\n![](https://www.goozp.com/uploads/2018/01/wp_nav_menu3.png)\r\n\r\n点击菜单1，最下面，有一个“显示位置”，那这下子我们可以很明确的知道register_nav_menus的作用了。然后我们发现，按理来说菜单1已可以显示到“顶部导航菜单”这个对应的位置中，但是在我们的新的主题中，我们还没有定义“顶部导航菜单”是在哪里的。这个时候就用到wp_nav_menu()。\r\n\r\n# wp_nav_menu()\r\n我们只需要在我们要输出菜单的位置直接引用这个函数就可以，同时这个函数提供了很多的参数可以选择：\r\nwp_nav_menu( $args );\r\n其中$args的默认值为：\r\n```php\r\n$args = array(\r\n	\'theme_location\' => \'\',\r\n	\'menu\' => \'\',\r\n	\'container\' => \'div\',\r\n	\'container_class\' => \'\',\r\n	\'container_id\' => \'\',\r\n	\'menu_class\' => \'menu\',\r\n	\'menu_id\' => \'\',\r\n	\'echo\' => true,\r\n	\'fallback_cb\' => \'wp_page_menu\',\r\n	\'before\' => \'\',\r\n	\'after\' => \'\',\r\n	\'link_before\' => \'\',\r\n	\'link_after\' => \'\',\r\n	\'items_wrap\' => \'<ul id=\"%1$s\" class=\"%2$s\">%3$s</ul>\',\r\n	\'depth\' => 0,\r\n	\'walker\' => \'\'\r\n);\r\n```\r\n\r\n再用我们上面用的例子，这里我们要使用theme_location这个参数，将其值设定为header_menu；那么现在header_menu对应的也就是“顶部导航菜单”就会输出在我们wp_nav_menu( )函数输出的位置。\r\n```php\r\n$args = array(\r\n	\'theme_location\' => \'header_menu\',\r\n);\r\nwp_nav_menu($args);\r\n```\r\n\r\n当然我们也可以用menu指定显示某个菜单：\r\n```\r\n$args = array(\r\n	\'menu\' => \'菜单1\',\r\n);\r\nwp_nav_menu($args);\r\n```\r\n\r\n不过这种做法不灵活，还是推荐使用theme_location参数配置。\r\n\r\n每个参数的具体描述如下：\r\n- $theme_locaton：(字符串)(可选)\r\n默认值: None\r\n用于在调用导航菜单时指定注册过的某一个导航菜单名，如果没有指定，则显示第一个。\r\n\r\n- $menu：(字符串)(可选)\r\n默认值: None\r\n使用导航菜单的名称调用菜单，可以是 id, slug, name (按顺序匹配的) 。\r\n\r\n- $container：(字符串)(可选)\r\n默认值: div\r\nul 父节点（这里指导航菜单的容器）的标签类型，只支持div 和 nav 标签, 如果是其它值, ul 父节点的标签将不会被显示。也可以用false（container => false）去掉ul父节点标签。\r\n\r\n- $container_class：(字符串)(可选)\r\n默认值: menu-{menu slug}-container\r\nul 父节点的 class 属性值。\r\n\r\n- $container_id：(字符串)(可选)\r\n默认值: None\r\nul 父节点的 id 属性值。\r\n\r\n- $menu_class：(字符串)(可选)\r\n默认值: menu\r\nul 节点的 class 属性值。\r\n\r\n- $menu_id：(字符串)(可选)\r\n默认值: menu slug, 自增长的\r\nul 节点的 id 属性值。\r\n\r\n- $echo：(布尔型)(可选)\r\n默认值: true (直接显示)\r\n确定直接显示导航菜单还是返回 HTML 片段，如果想将导航的代码作为赋值使用，可设置为false。\r\n\r\n- $fallback_cb：(字符串)(可选)\r\n默认值: wp_page_menu (显示页面列表作为菜单)\r\n用于没有在后台设置导航时调的回调函数。\r\n\r\n- $before：(字符串)(可选)\r\n默认值: None\r\n显示在每个菜单链接前的文本。\r\n\r\n- $after：(字符串)(可选)\r\n默认值: None\r\n显示在每个菜单链接后的文本。\r\n\r\n- $link_before：(字符串)(可选)\r\n默认值: None\r\n显示在每个菜单链接文本前的文本。\r\n\r\n- $link_after：(字符串)(可选)\r\n默认值: None\r\n显示在每个菜单链接文本后的文本。\r\n\r\n- $items_wrap：(字符串)(可选)\r\n默认值: None\r\n使用字符串替换修改ul的class。\r\n\r\n- $depth：(整型)(可选)\r\n默认值: 0\r\n显示菜单的深度, 当数值为 0 时显示所有深度的菜单。\r\n\r\n- $walker：(对象型)(可选)\r\n默认值: new Walker_Nav_Menu\r\n\r\n# 定制自己的导航样式\r\n通过定义container_id，container_class等参数，可以获取我们想要的html结构，根据这个结构，写css样式美化菜单。\r\n\r\n# 总结\r\n基本上这两个函数就是这样配合使用，需要注意的就是，不是注册菜单，而是注册了“菜单插槽的引用接口”，差不多这个意思。\r\n', '<p>最近做一个自己的主题，开始接触wordpress的二次开发。在导航菜单这一块，遇到一点小问题。其实网上的资料挺多，有一些也挺久远的，不过也都能用，毕竟wordpress没什么大改。但是这些资料实际上讲得不清楚，一开始误导了我。</p>\r\n<p>其实在主题中做导航菜单，我们只需要用到两个函数register_nav_menus()和wp_nav_menu() 。</p>\r\n<p>接下来看看怎么搞：</p>\r\n<h1 id=\"h1-register_nav_menus-\"><a name=\"register_nav_menus()\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>register_nav_menus()</h1><p>在主题的functions.php中注册菜单导航：</p>\r\n<pre><code class=\"lang-php\">register_nav_menus( array(\r\n    &#39;header_menu&#39; =&gt; &#39;顶部导航菜单&#39;,\r\n) );\r\n</code></pre>\r\n<p>header_menu其实只是一个标志的key，对应的值为显示给用户的描述。那么，重点在于，这个注册导航菜单，并不是注册了一个导航菜单，而是打通了wordpress系统中的导航菜单与我们自制主题的导航菜单显示位置，提供给用户一个选择，实际上是这样的，在后台外观设置的菜单中，我们的菜单下面的菜单设置这里，多了一个可选项：<br><img src=\"https://www.goozp.com/uploads/2018/01/wp_nav_menu1.png\" alt=\"\"></p>\r\n<p>这个看起来不明确，我们可以看这个，在“自定义”这里：<br><img src=\"https://www.goozp.com/uploads/2018/01/wp_nav_menu2.png\" alt=\"\"></p>\r\n<p>这里是已经将菜单1设置为顶部导航菜单，因为我们已经给这个选项打了勾。<br><img src=\"https://www.goozp.com/uploads/2018/01/wp_nav_menu3.png\" alt=\"\"></p>\r\n<p>点击菜单1，最下面，有一个“显示位置”，那这下子我们可以很明确的知道register_nav_menus的作用了。然后我们发现，按理来说菜单1已可以显示到“顶部导航菜单”这个对应的位置中，但是在我们的新的主题中，我们还没有定义“顶部导航菜单”是在哪里的。这个时候就用到wp_nav_menu()。</p>\r\n<h1 id=\"h1-wp_nav_menu-\"><a name=\"wp_nav_menu()\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>wp_nav_menu()</h1><p>我们只需要在我们要输出菜单的位置直接引用这个函数就可以，同时这个函数提供了很多的参数可以选择：<br>wp_nav_menu( $args );<br>其中$args的默认值为：</p>\r\n<pre><code class=\"lang-php\">$args = array(\r\n    &#39;theme_location&#39; =&gt; &#39;&#39;,\r\n    &#39;menu&#39; =&gt; &#39;&#39;,\r\n    &#39;container&#39; =&gt; &#39;div&#39;,\r\n    &#39;container_class&#39; =&gt; &#39;&#39;,\r\n    &#39;container_id&#39; =&gt; &#39;&#39;,\r\n    &#39;menu_class&#39; =&gt; &#39;menu&#39;,\r\n    &#39;menu_id&#39; =&gt; &#39;&#39;,\r\n    &#39;echo&#39; =&gt; true,\r\n    &#39;fallback_cb&#39; =&gt; &#39;wp_page_menu&#39;,\r\n    &#39;before&#39; =&gt; &#39;&#39;,\r\n    &#39;after&#39; =&gt; &#39;&#39;,\r\n    &#39;link_before&#39; =&gt; &#39;&#39;,\r\n    &#39;link_after&#39; =&gt; &#39;&#39;,\r\n    &#39;items_wrap&#39; =&gt; &#39;&lt;ul id=&quot;%1$s&quot; class=&quot;%2$s&quot;&gt;%3$s&lt;/ul&gt;&#39;,\r\n    &#39;depth&#39; =&gt; 0,\r\n    &#39;walker&#39; =&gt; &#39;&#39;\r\n);\r\n</code></pre>\r\n<p>再用我们上面用的例子，这里我们要使用theme_location这个参数，将其值设定为header_menu；那么现在header_menu对应的也就是“顶部导航菜单”就会输出在我们wp_nav_menu( )函数输出的位置。</p>\r\n<pre><code class=\"lang-php\">$args = array(\r\n    &#39;theme_location&#39; =&gt; &#39;header_menu&#39;,\r\n);\r\nwp_nav_menu($args);\r\n</code></pre>\r\n<p>当然我们也可以用menu指定显示某个菜单：</p>\r\n<pre><code>$args = array(\r\n    &#39;menu&#39; =&gt; &#39;菜单1&#39;,\r\n);\r\nwp_nav_menu($args);\r\n</code></pre><p>不过这种做法不灵活，还是推荐使用theme_location参数配置。</p>\r\n<p>每个参数的具体描述如下：</p>\r\n<ul>\r\n<li><p>$theme_locaton：(字符串)(可选)<br>默认值: None<br>用于在调用导航菜单时指定注册过的某一个导航菜单名，如果没有指定，则显示第一个。</p>\r\n</li><li><p>$menu：(字符串)(可选)<br>默认值: None<br>使用导航菜单的名称调用菜单，可以是 id, slug, name (按顺序匹配的) 。</p>\r\n</li><li><p>$container：(字符串)(可选)<br>默认值: div<br>ul 父节点（这里指导航菜单的容器）的标签类型，只支持div 和 nav 标签, 如果是其它值, ul 父节点的标签将不会被显示。也可以用false（container =&gt; false）去掉ul父节点标签。</p>\r\n</li><li><p>$container_class：(字符串)(可选)<br>默认值: menu-{menu slug}-container<br>ul 父节点的 class 属性值。</p>\r\n</li><li><p>$container_id：(字符串)(可选)<br>默认值: None<br>ul 父节点的 id 属性值。</p>\r\n</li><li><p>$menu_class：(字符串)(可选)<br>默认值: menu<br>ul 节点的 class 属性值。</p>\r\n</li><li><p>$menu_id：(字符串)(可选)<br>默认值: menu slug, 自增长的<br>ul 节点的 id 属性值。</p>\r\n</li><li><p>$echo：(布尔型)(可选)<br>默认值: true (直接显示)<br>确定直接显示导航菜单还是返回 HTML 片段，如果想将导航的代码作为赋值使用，可设置为false。</p>\r\n</li><li><p>$fallback_cb：(字符串)(可选)<br>默认值: wp_page_menu (显示页面列表作为菜单)<br>用于没有在后台设置导航时调的回调函数。</p>\r\n</li><li><p>$before：(字符串)(可选)<br>默认值: None<br>显示在每个菜单链接前的文本。</p>\r\n</li><li><p>$after：(字符串)(可选)<br>默认值: None<br>显示在每个菜单链接后的文本。</p>\r\n</li><li><p>$link_before：(字符串)(可选)<br>默认值: None<br>显示在每个菜单链接文本前的文本。</p>\r\n</li><li><p>$link_after：(字符串)(可选)<br>默认值: None<br>显示在每个菜单链接文本后的文本。</p>\r\n</li><li><p>$items_wrap：(字符串)(可选)<br>默认值: None<br>使用字符串替换修改ul的class。</p>\r\n</li><li><p>$depth：(整型)(可选)<br>默认值: 0<br>显示菜单的深度, 当数值为 0 时显示所有深度的菜单。</p>\r\n</li><li><p>$walker：(对象型)(可选)<br>默认值: new Walker_Nav_Menu</p>\r\n</li></ul>\r\n<h1 id=\"h1-u5B9Au5236u81EAu5DF1u7684u5BFCu822Au6837u5F0F\"><a name=\"定制自己的导航样式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>定制自己的导航样式</h1><p>通过定义container_id，container_class等参数，可以获取我们想要的html结构，根据这个结构，写css样式美化菜单。</p>\r\n<h1 id=\"h1-u603Bu7ED3\"><a name=\"总结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>总结</h1><p>基本上这两个函数就是这样配合使用，需要注意的就是，不是注册菜单，而是注册了“菜单插槽的引用接口”，差不多这个意思。</p>\r\n', '', 0, 'publish', 1, 0, '/article/34.html', '', 0, 88, '2017-02-13 02:18:48', '2017-02-13 02:18:48', '2018-01-09 06:03:14', NULL);
INSERT INTO `pt_post` VALUES (35, 10, 'article', '基于Bootstrap开发的自适应WordPress主题（自用）', '这是一个基于Bootstrap开发的自适应Wordpress主题，是我自己用的，所以是根据我自己的需求与想法做的。考虑到主题的效率，流畅性，没有用太多JS，能用css就用css解决（包括顶部的三级导航菜单），所以并没有太多的酷炫效果，某些设计也比较古老（自用的嘛）。而且，作为一个后端程序猿，前端目前真心不熟啊！！！不过，还是分享出来。\r\n\r\n先上一张效果图：\r\n![](https://www.goozp.com/uploads/2018/01/jumping_1.png)\r\n\r\n移动端中的展现：\r\n![](https://www.goozp.com/uploads/2018/01/jumping_2.png)![](https://www.goozp.com/uploads/2018/01/jumping_3.png)\r\n可能在pad中的展示会比较差，但是问题不大。\r\n\r\n# V1.0.0版本说明：\r\n## 主题特色\r\n- 采用bootstrap构建\r\n- 支持自适应，适配移动端设备\r\n- 目前提供五个已有样式的侧边栏小工具：热门文章，最新文章，标签云，最新评论，归档\r\n- 模板页面提供archives归档页，treeTime时间轴页面，myJob时间轴页面\r\n- 底部footer提供普通和微信二维码两种方案\r\n- 去除了加载Google Fonts，emoji表情等以优化速度\r\n- 优化了Wordpress默认输出的 head 加载\r\n- 暂时不支持后台更新\r\n\r\n## 主题说明\r\n- 依赖插件：WP-PostViews（文章浏览量统计插件）\r\n- 小图标：采用Font Awesome v4.7.0，具体图标对应class请前往官网查看。\r\n- 发送邮件：评论回复邮件提醒功能采用了PHPMailer，发送邮件的设置可在主题设置中进行设置。\r\n\r\n## 部分功能使用说明\r\n- 开始使用主题后请先在主题设置页面设置网站信息，非常重要，description和keywords一经设置最好少修改；并选择一款footer样式\r\n- 右侧边栏的头像请直接替换public/images/jumbotron_self.png图片，并保持原来名字（未来开放设置中心修改）\r\n- 微信公众号二维码图片同上（未来开放设置中心修改）\r\n- archives归档页使用：直接新建一个独立页面，模板选择Archive归档页面即可。\r\n- treeTime时间轴页使用：新建一个选择treeTime的归档页面，开放评论，但是内容需要在treeTime.php中自行修改，这可能需要你有一些html，css的基础。\r\n- myJob时间轴页使用：新建一个选择myJob的归档页面，内容需要自行到myJob.php中修改，这可能需要你有一些html，css的基础。\r\n\r\n## 待完善\r\n- 微信公众号模式底部左侧空旷\r\n- 侧边栏个人板块整合进主题设置\r\n- 顶部导航一级栏目过多时样式会出现混乱，且目前只支持3级导航\r\n- Gravatar头像的优化\r\n- 楼中楼评论时的用户体验\r\n\r\n## 下载地址\r\n目前第一个版本基本上就是这样了，放一下地址：\r\n- 百度网盘地址：[Jumping -v1.0.0](https://pan.baidu.com/s/1qYVS328 \"Jumping -v1.0.0\") ，下载密码：hiqp\r\n- Github地址：[Jumping主题master](https://github.com/ZpGuo/Jumping/tree/master \"Jumping主题master\")，点击Clone or download，下载Zip，到wordpress后台安装就行。\r\n\r\n其实能完善的地方还有很多，以后有时间再弄吧，上班也忙。同时，欢迎在github上提issue或者直接fork。', '<p>这是一个基于Bootstrap开发的自适应Wordpress主题，是我自己用的，所以是根据我自己的需求与想法做的。考虑到主题的效率，流畅性，没有用太多JS，能用css就用css解决（包括顶部的三级导航菜单），所以并没有太多的酷炫效果，某些设计也比较古老（自用的嘛）。而且，作为一个后端程序猿，前端目前真心不熟啊！！！不过，还是分享出来。</p>\r\n<p>先上一张效果图：<br><img src=\"https://www.goozp.com/uploads/2018/01/jumping_1.png\" alt=\"\"></p>\r\n<p>移动端中的展现：<br><img src=\"https://www.goozp.com/uploads/2018/01/jumping_2.png\" alt=\"\"><img src=\"https://www.goozp.com/uploads/2018/01/jumping_3.png\" alt=\"\"><br>可能在pad中的展示会比较差，但是问题不大。</p>\r\n<h1 id=\"h1-v1-0-0-\"><a name=\"V1.0.0版本说明：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>V1.0.0版本说明：</h1><h2 id=\"h2-u4E3Bu9898u7279u8272\"><a name=\"主题特色\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>主题特色</h2><ul>\r\n<li>采用bootstrap构建</li><li>支持自适应，适配移动端设备</li><li>目前提供五个已有样式的侧边栏小工具：热门文章，最新文章，标签云，最新评论，归档</li><li>模板页面提供archives归档页，treeTime时间轴页面，myJob时间轴页面</li><li>底部footer提供普通和微信二维码两种方案</li><li>去除了加载Google Fonts，emoji表情等以优化速度</li><li>优化了Wordpress默认输出的 head 加载</li><li>暂时不支持后台更新</li></ul>\r\n<h2 id=\"h2-u4E3Bu9898u8BF4u660E\"><a name=\"主题说明\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>主题说明</h2><ul>\r\n<li>依赖插件：WP-PostViews（文章浏览量统计插件）</li><li>小图标：采用Font Awesome v4.7.0，具体图标对应class请前往官网查看。</li><li>发送邮件：评论回复邮件提醒功能采用了PHPMailer，发送邮件的设置可在主题设置中进行设置。</li></ul>\r\n<h2 id=\"h2-u90E8u5206u529Fu80FDu4F7Fu7528u8BF4u660E\"><a name=\"部分功能使用说明\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>部分功能使用说明</h2><ul>\r\n<li>开始使用主题后请先在主题设置页面设置网站信息，非常重要，description和keywords一经设置最好少修改；并选择一款footer样式</li><li>右侧边栏的头像请直接替换public/images/jumbotron_self.png图片，并保持原来名字（未来开放设置中心修改）</li><li>微信公众号二维码图片同上（未来开放设置中心修改）</li><li>archives归档页使用：直接新建一个独立页面，模板选择Archive归档页面即可。</li><li>treeTime时间轴页使用：新建一个选择treeTime的归档页面，开放评论，但是内容需要在treeTime.php中自行修改，这可能需要你有一些html，css的基础。</li><li>myJob时间轴页使用：新建一个选择myJob的归档页面，内容需要自行到myJob.php中修改，这可能需要你有一些html，css的基础。</li></ul>\r\n<h2 id=\"h2-u5F85u5B8Cu5584\"><a name=\"待完善\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>待完善</h2><ul>\r\n<li>微信公众号模式底部左侧空旷</li><li>侧边栏个人板块整合进主题设置</li><li>顶部导航一级栏目过多时样式会出现混乱，且目前只支持3级导航</li><li>Gravatar头像的优化</li><li>楼中楼评论时的用户体验</li></ul>\r\n<h2 id=\"h2-u4E0Bu8F7Du5730u5740\"><a name=\"下载地址\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>下载地址</h2><p>目前第一个版本基本上就是这样了，放一下地址：</p>\r\n<ul>\r\n<li>百度网盘地址：<a href=\"https://pan.baidu.com/s/1qYVS328\" title=\"Jumping -v1.0.0\">Jumping -v1.0.0</a> ，下载密码：hiqp</li><li>Github地址：<a href=\"https://github.com/ZpGuo/Jumping/tree/master\" title=\"Jumping主题master\">Jumping主题master</a>，点击Clone or download，下载Zip，到wordpress后台安装就行。</li></ul>\r\n<p>其实能完善的地方还有很多，以后有时间再弄吧，上班也忙。同时，欢迎在github上提issue或者直接fork。</p>\r\n', '', 0, 'publish', 1, 0, '/article/35.html', '', 0, 95, '2017-02-13 18:43:16', '2017-02-13 18:43:16', '2018-01-09 06:38:40', NULL);
INSERT INTO `pt_post` VALUES (36, 10, 'article', '理解单页面应用（SPA）', '# 什么是单页面应用？\r\n单页面应用（Single Page Application，SPA），就是只有一张Web页面的应用。单页应用程序 (SPA) 是加载单个HTML 页面并在用户与应用程序交互时动态更新该页面的Web应用程序。\r\n\r\n对于我来说，这个概念对于我来说还算是比较新的，之前还没接触过，是在学习vue的时候接触的。我看了一下，这个东西的应用还是很广泛的。\r\n\r\n比如，拿微博做个例子：\r\n\r\n我们到首页是这样的：\r\n![](https://www.goozp.com/uploads/2018/01/spa1.png)\r\n\r\n通过点击“明星”，有一个加载的提示：\r\n![](https://www.goozp.com/uploads/2018/01/spa2.png)\r\n\r\n然后在局部显示出新的内容：\r\n![](https://www.goozp.com/uploads/2018/01/spa3.png)\r\n\r\n而变动的只是这个div的内容，没有url上的跳转：\r\n![](https://www.goozp.com/uploads/2018/01/spa4.png)\r\n这就是一个单页面的模式，用户体验效果非常好。\r\n\r\n# 单页面应用的优点\r\n- 最大的好处是用户体验，对于内容的改动不需要加载整个页面。\r\n- 数据层和UI的分离，可以重新编写一个原生的移动设备应用程序而不用大动干戈（同一套后端程序代码，不用修改就可以用于Web界面、手机、平板等多种客户端；）。\r\n- 高效。它对服务器压力很小，消耗更少的带宽，能够与面向服务的架构更好地结合。\r\n\r\n# 单页面应用的缺点\r\n- 不利于SEO\r\n- 初次加载耗时增多\r\n- 导航不可用；前进、后退、地址栏等，需要程序进行管理；\r\n- 书签，需要程序来提供支持；\r\n\r\n# 应用场景\r\n那么单页应用的应用如何呢？看了一些资料，总觉出来单页面应用有两个硬伤：\r\n- 首屏加载（大量js导致首屏加载慢）\r\n-  seo不友好\r\n\r\n如何应用SPA或者是否应用SPA，大概需要考虑以下这几点：\r\n1. 交互体验\r\n不同的应用面对不同人群，会有不同的交互体验需求。\r\n2. 工程代价\r\n大型网站转spa会有很大的代价。\r\n3. 容错问题\r\nSPA所有脚本都加进来，如果出现一个JS错误，那很可能整个网站就挂掉了，风险很大。\r\n4. 是否必要\r\n简单呈现内容的网站，没有必要用spa。增加了开发和调试的复杂性，但是除了效果更酷炫点，没有多少实用价值。\r\n5. 是否需要兼容低版本的ie浏览器\r\n这个真的是……\r\n\r\n# 想法\r\n综合了解了这种SPA单页应用和传统的多页面应用，在以后的开发中，我可能会采取单页和多页相结合的方式，该跳转的地方还是跳转，结合单页模式的用户体验优点，将用户体验发挥到极致，因为我觉得用户体验是最重要的东西之一。', '<h1 id=\"h1--\"><a name=\"什么是单页面应用？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>什么是单页面应用？</h1><p>单页面应用（Single Page Application，SPA），就是只有一张Web页面的应用。单页应用程序 (SPA) 是加载单个HTML 页面并在用户与应用程序交互时动态更新该页面的Web应用程序。</p>\r\n<p>对于我来说，这个概念对于我来说还算是比较新的，之前还没接触过，是在学习vue的时候接触的。我看了一下，这个东西的应用还是很广泛的。</p>\r\n<p>比如，拿微博做个例子：</p>\r\n<p>我们到首页是这样的：<br><img src=\"https://www.goozp.com/uploads/2018/01/spa1.png\" alt=\"\"></p>\r\n<p>通过点击“明星”，有一个加载的提示：<br><img src=\"https://www.goozp.com/uploads/2018/01/spa2.png\" alt=\"\"></p>\r\n<p>然后在局部显示出新的内容：<br><img src=\"https://www.goozp.com/uploads/2018/01/spa3.png\" alt=\"\"></p>\r\n<p>而变动的只是这个div的内容，没有url上的跳转：<br><img src=\"https://www.goozp.com/uploads/2018/01/spa4.png\" alt=\"\"><br>这就是一个单页面的模式，用户体验效果非常好。</p>\r\n<h1 id=\"h1-u5355u9875u9762u5E94u7528u7684u4F18u70B9\"><a name=\"单页面应用的优点\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>单页面应用的优点</h1><ul>\r\n<li>最大的好处是用户体验，对于内容的改动不需要加载整个页面。</li><li>数据层和UI的分离，可以重新编写一个原生的移动设备应用程序而不用大动干戈（同一套后端程序代码，不用修改就可以用于Web界面、手机、平板等多种客户端；）。</li><li>高效。它对服务器压力很小，消耗更少的带宽，能够与面向服务的架构更好地结合。</li></ul>\r\n<h1 id=\"h1-u5355u9875u9762u5E94u7528u7684u7F3Au70B9\"><a name=\"单页面应用的缺点\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>单页面应用的缺点</h1><ul>\r\n<li>不利于SEO</li><li>初次加载耗时增多</li><li>导航不可用；前进、后退、地址栏等，需要程序进行管理；</li><li>书签，需要程序来提供支持；</li></ul>\r\n<h1 id=\"h1-u5E94u7528u573Au666F\"><a name=\"应用场景\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>应用场景</h1><p>那么单页应用的应用如何呢？看了一些资料，总觉出来单页面应用有两个硬伤：</p>\r\n<ul>\r\n<li>首屏加载（大量js导致首屏加载慢）</li><li>seo不友好</li></ul>\r\n<p>如何应用SPA或者是否应用SPA，大概需要考虑以下这几点：</p>\r\n<ol>\r\n<li>交互体验<br>不同的应用面对不同人群，会有不同的交互体验需求。</li><li>工程代价<br>大型网站转spa会有很大的代价。</li><li>容错问题<br>SPA所有脚本都加进来，如果出现一个JS错误，那很可能整个网站就挂掉了，风险很大。</li><li>是否必要<br>简单呈现内容的网站，没有必要用spa。增加了开发和调试的复杂性，但是除了效果更酷炫点，没有多少实用价值。</li><li>是否需要兼容低版本的ie浏览器<br>这个真的是……</li></ol>\r\n<h1 id=\"h1-u60F3u6CD5\"><a name=\"想法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>想法</h1><p>综合了解了这种SPA单页应用和传统的多页面应用，在以后的开发中，我可能会采取单页和多页相结合的方式，该跳转的地方还是跳转，结合单页模式的用户体验优点，将用户体验发挥到极致，因为我觉得用户体验是最重要的东西之一。</p>\r\n', '', 0, 'publish', 1, 0, '/article/36.html', '', 0, 84, '2017-02-15 03:25:03', '2017-02-15 03:25:03', '2018-01-09 07:02:34', NULL);
INSERT INTO `pt_post` VALUES (37, 10, 'article', 'Centos6.8编译安装LNMP环境（Nginx+MySQL+PHP）', '最近研究了Linux系统下的PHP环境搭建，个人感觉最好最好不要用yum默认的程序包安装，因为版本都比较低，下载最新的稳定版自行安装比较好。现在网上教程很多，之所以还记这篇，原因有一点，当你重复网上的教程自行安装时，90%还是会出现各种各样的问题，因为你可能linux的系统版本不同，你想装的软件版本不同，安装的方法不同，你下错了安装包的版本，还有其它乱七八糟的。举个例，比如你看着5.6的mysql安装教程，装5.7的，你感觉没问题，但是事实就是，5.7的不一样了！而且网上还没有新的这方面内容，不好找，这就需要你去摸索了，亲身经历啊。这里面，Niginx感觉最好配，MySQL最坑。\r\n\r\n本篇安装的软件版本为：\r\n- Linux：Centos6.8\r\n- Nginx：1.10.3\r\n- MySQL：5.7.17\r\n- PHP：7.0.16\r\n------------\r\n\r\n# 一 准备工作\r\n## 1. 关闭SELINUX\r\n修改配置文件，重启服务后永久生效。\r\n`# sed -i ‘s/SELINUX=.*/SELINUX=disabled/g’ /etc/selinux/config`\r\n命令行设置立即生效。\r\n`# setenforce 0`\r\n\r\n## 2. 如果是阿里云ECS用户，安全组设置中开启80端口方便调试。\r\n\r\n# 二 安装Nginx\r\n## 1. 下载源码包\r\n上Nginx官网，复制最新稳定版的下载地址过来，然后用wget下载（接下来需要下载安装包的都可以用wget）：\r\n```\r\n# cd /usr/local/src\r\n# wget http://nginx.org/download/nginx-1.10.3.tar.gz\r\n```\r\n![](https://www.goozp.com/uploads/2018/01/LNMP2.png)\r\n下载完成的状态基本都是以下这样的：\r\n![](https://www.goozp.com/uploads/2018/01/LNMP3.png)\r\n\r\n## 2. 进行解压编译\r\n```\r\n# tar xvf nginx-1.10.3.tar.gz\r\n# yum groupinstall “Development tools”\r\n# yum -y install gcc wget gcc-c++ automake autoconf libtool libxml2-devel libxslt-devel perl-devel perl-ExtUtils-Embed pcre-devel openssl-devel\r\n```\r\n![](https://www.goozp.com/uploads/2018/01/LNMP4.png)\r\n\r\n执行完成。\r\n\r\n进入解压后的nginx-1.10.3文件夹：\r\n`cd /usr/local/src/nginx-1.10.3`\r\n执行以下语句：\r\n```\r\n./configure \\\r\n--prefix=/usr/local/nginx \\\r\n--sbin-path=/usr/sbin/nginx \\\r\n--conf-path=/etc/nginx/nginx.conf \\\r\n--error-log-path=/var/log/nginx/error.log \\\r\n--http-log-path=/var/log/nginx/access.log \\\r\n--pid-path=/var/run/nginx.pid \\\r\n--lock-path=/var/run/nginx.lock \\\r\n--http-client-body-temp-path=/var/tmp/nginx/client \\\r\n--http-proxy-temp-path=/var/tmp/nginx/proxy \\\r\n--http-fastcgi-temp-path=/var/tmp/nginx/fcgi \\\r\n--http-uwsgi-temp-path=/var/tmp/nginx/uwsgi \\\r\n--http-scgi-temp-path=/var/tmp/nginx/scgi \\\r\n--user=nginx \\\r\n--group=nginx \\\r\n--with-pcre \\\r\n--with-http_v2_module \\\r\n--with-http_ssl_module \\\r\n--with-http_realip_module \\\r\n--with-http_addition_module \\\r\n--with-http_sub_module \\\r\n--with-http_dav_module \\\r\n--with-http_flv_module \\\r\n--with-http_mp4_module \\\r\n--with-http_gunzip_module \\\r\n--with-http_gzip_static_module \\\r\n--with-http_random_index_module \\\r\n--with-http_secure_link_module \\\r\n--with-http_stub_status_module \\\r\n--with-http_auth_request_module \\\r\n--with-mail \\\r\n--with-mail_ssl_module \\\r\n--with-file-aio \\\r\n--with-ipv6 \\\r\n--with-http_v2_module \\\r\n--with-threads \\\r\n--with-stream \\\r\n--with-stream_ssl_module \\\r\n--with-openssl\r\n```\r\n\r\n完成后执行编译：\r\n```\r\n# make && make install\r\n# mkdir -pv /var/tmp/nginx/client\r\n```\r\n\r\n## 3. 添加SysV启动脚本。\r\n\r\n用vim编辑脚本：\r\n`# vim /etc/init.d/nginx`\r\n写入以下内容：\r\n```\r\n#!/bin/sh\r\n#\r\n# nginx - this script starts and stops the nginx daemon\r\n#\r\n# chkconfig:   - 85 15 \r\n# description: Nginx is an HTTP(S) server, HTTP(S) reverse \\\r\n#               proxy and IMAP/POP3 proxy server\r\n# processname: nginx\r\n# config:      /etc/nginx/nginx.conf\r\n# config:      /etc/sysconfig/nginx\r\n# pidfile:     /var/run/nginx.pid\r\n# Source function library.\r\n. /etc/rc.d/init.d/functions\r\n# Source networking configuration.\r\n. /etc/sysconfig/network\r\n# Check that networking is up.\r\n[ \"$NETWORKING\" = \"no\" ] &amp;amp;amp;amp;&amp;amp;amp;amp; exit 0\r\nnginx=\"/usr/sbin/nginx\"\r\nprog=$(basename $nginx)\r\nNGINX_CONF_FILE=\"/etc/nginx/nginx.conf\"\r\n[ -f /etc/sysconfig/nginx ] &amp;amp;amp;amp;&amp;amp;amp;amp; . /etc/sysconfig/nginx\r\nlockfile=/var/lock/subsys/nginx\r\nstart() {\r\n    [ -x $nginx ] || exit 5\r\n    [ -f $NGINX_CONF_FILE ] || exit 6\r\n    echo -n $\"Starting $prog: \"\r\n    daemon $nginx -c $NGINX_CONF_FILE\r\n    retval=$?\r\n    echo \r\n    [ $retval -eq 0 ] &amp;amp;amp;amp;&amp;amp;amp;amp; touch $lockfile\r\n    return $retval\r\n}\r\nstop() {\r\n    echo -n $\"Stopping $prog: \"\r\n    killproc $prog -QUIT\r\n    retval=$?\r\n    echo\r\n    [ $retval -eq 0 ] &amp;amp;amp;amp;&amp;amp;amp;amp; rm -f $lockfile\r\n    return $retval\r\nkillall -9 nginx\r\n}\r\nrestart() {\r\n    configtest || return $?\r\n    stop\r\n    sleep 1\r\n    start\r\n}\r\nreload() {\r\n    configtest || return $?\r\n    echo -n $\"Reloading $prog: \"\r\n    killproc $nginx -HUP\r\nRETVAL=$?\r\n    echo\r\n}\r\nforce_reload() {\r\n    restart\r\n}\r\nconfigtest() {\r\n$nginx -t -c $NGINX_CONF_FILE\r\n}\r\nrh_status() {\r\n    status $prog\r\n}\r\nrh_status_q() {\r\n    rh_status &amp;amp;amp;gt;/dev/null 2&amp;amp;amp;gt;&amp;amp;amp;amp;1\r\n}\r\ncase \"$1\" in\r\n    start)\r\n        rh_status_q &amp;amp;amp;amp;&amp;amp;amp;amp; exit 0\r\n    $1\r\n        ;;\r\n    stop)\r\n        rh_status_q || exit 0\r\n        $1\r\n        ;;\r\n    restart|configtest)\r\n        $1\r\n        ;;\r\n    reload)\r\n        rh_status_q || exit 7\r\n        $1\r\n        ;;\r\n    force-reload)\r\n        force_reload\r\n        ;;\r\n    status)\r\n        rh_status\r\n        ;;\r\n    condrestart|try-restart)\r\n        rh_status_q || exit 0\r\n            ;;\r\n    *)\r\n      echo $\"Usage: $0 {start|stop|status|restart|condrestart|try-restart|reload|force-reload|configtest}\"\r\n        exit 2\r\nesac\r\n```\r\n\r\n保存退出（按:wq!）；可能你得稍微查一下vim的一些命令，不然操作时可能会出现一点小问题。\r\n赋予脚本执行权限：\r\n`# chmod +x /etc/init.d/nginx`\r\n\r\n添加至服务管理列表，设置开机自启：\r\n```\r\n# chkconfig –add nginx\r\n# chkconfig nginx on\r\n```\r\n\r\n## 4. 启动服务。\r\n`# service nginx start`\r\n![](https://www.goozp.com/uploads/2018/01/LNMP6.png)\r\n出现这玩意说明成功了！\r\n\r\n> 注：如果报错 [emerg]: getpwnam(“nginx”) failed ；\r\n  解决方法：`# useradd -s /sbin/nologin -M nginx` `# id nginx`\r\n\r\n# 三 安装mysql\r\n## 1. 版本选择\r\n在安装之前必须明白一件事情，mysql有很多种安装方式，每种不一样，不要弄混了。\r\n比如源码编译安装（mysql-5.7.17.tar.gz），二进制安装（mysql-5.7.17-linux-glibc2.5-i686.tar），nmp安装（最简单的）。这里我们用源码自己编译安装。\r\n\r\n## 2. 准备编译环境\r\n```\r\n# yum groupinstall “Server Platform Development” “Development tools” -y\r\n# yum install cmake -y\r\n```\r\ncmake在现在的版本是必须要安装的，你可以下载camke之后编译，也可以直接yum安装。接下来的编译过程如果报错缺少什么就补什么。\r\n\r\n## 3. 准备mysql数据库存放目录\r\n```\r\n# mkdir /mnt/data\r\n# groupadd -r mysql\r\n# useradd -r -g mysql -s /sbin/nologin mysql\r\n# id mysql\r\n```\r\n\r\n## 4. 更改数据目录权限。\r\n`# chown -R mysql:mysql /mnt/data`\r\n\r\n## 5. 下载并解压编译官网下载的稳定版的源码包。\r\n在下载的时候注意一下版本，下载对应的版本。我们源码编译，要下载长这样的安装包：mysql-5.7.17.tar.gz，同时在安装的时候我们需要boost库，5.7需要1.59版本的库；你可以下载boost库然后编译boost库，或者像我一样，下载带有boost库的mysql版本。\r\n\r\n开始解压编译：\r\n```\r\n# tar xvf mysql-boost-5.7.17.tar.gz -C /usr/local/src\r\n# cd /usr/local/src/mysql-5.7.17\r\n# cmake . -DCMAKE_INSTALL_PREFIX=/usr/local/mysql \\\r\n-DMYSQL_DATADIR=/mnt/data \\\r\n-DSYSCONFDIR=/etc \\\r\n-DWITH_INNOBASE_STORAGE_ENGINE=1 \\\r\n-DWITH_ARCHIVE_STORAGE_ENGINE=1 \\\r\n-DWITH_BLACKHOLE_STORAGE_ENGINE=1 \\\r\n-DWITH_READLINE=1 \\\r\n-DWITH_SSL=system \\\r\n-DWITH_ZLIB=system \\\r\n-DWITH_LIBWRAP=0 \\\r\n-DMYSQL_TCP_PORT=3306 \\\r\n-DMYSQL_UNIX_ADDR=/tmp/mysql.sock \\\r\n-DDEFAULT_CHARSET=utf8 \\\r\n-DDEFAULT_COLLATION=utf8_general_ci\r\n-DDOWNLOAD_BOOST=1 \\\r\n-DWITH_BOOST=/usr/local/mysql/boost/boost_1_59_0 \\\r\n# make && make install\r\n```\r\n\r\n## 6. 修改安装目录的权限属组\r\n`# chown -R mysql:mysql /usr/local/mysql/`\r\n\r\n## 7. 初始化数据库。\r\n`# /usr/local/mysql/bin/mysqld –initialize –user=mysql –basedir=/usr/local/mysql –datadir=/mnt/data/`\r\n需要注意这里是mysql5.7的初始化命令，而5.7以下的都是用：\r\n`# /usr/local/mysql/scripts/mysql_install_db –user=mysql –datadir=/mnt/data/`\r\n在初始化成功之后，5.7的initial命令会产生一个随机的root登录密码，你要用这个密码登录，然后修改（必须修改生成的随机密码不然无法后续操作）。在最后有一个类似这样的密码：\r\n![](https://www.goozp.com/uploads/2018/01/LNMP7.png)\r\n\r\n## 8. 复制配置文件\r\n`# cp support-files/my-default.cnf /etc/my.cnf`\r\n这里又有一点要注意：mysql5.7配置文件需要修改my.cnf关键配置， mysql5.7之前默认配置文件中是有配置项的，不用手动修改。以下为配置，根据实际情况修改：\r\n```\r\n[mysqld]\r\nbasedir = /usr/local/mysql\r\ndatadir = /mnt/data\r\nport = 3306\r\nsocket = /Ultrapower/test/mysql/tmp/mysql.sock\r\n\r\nsql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES\r\n[client]\r\nsocket = /Ultrapower/test/mysql/tmp/mysql.sock\r\n```\r\n如果添加[client]下 的内容，注意`sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES`要放在[mysqld]下。\r\n如果报错tmp目录不错在，到对应的地方去创建目录，然后创建后要赋予mysql权限，`chown -R mysql:mysql tmp`。\r\n\r\n## 9. 设置开机启动\r\n```\r\n# cp /usr/local/mysql/support-files/mysql.server /etc/init.d/mysqld\r\n# chmod +x /etc/init.d/mysql\r\n```\r\n注册为开机启动服务：\r\n```\r\n# chkconfig mysqld on\r\n# chkconfig –add mysqld\r\n```\r\n查看是否设置成功：\r\n`# chkconfig –list mysql`\r\n\r\n## 10. 设置PATH环境变量。\r\n```\r\n# echo “export PATH=$PATH:/usr/local/mysql/bin” > /etc/profile.d/mysql.sh\r\n# source /etc/profile.d/mysql.sh\r\n```\r\n\r\n## 11. 启动服务\r\n`# service mysqld start`\r\n\r\n![](https://www.goozp.com/uploads/2018/01/LNMP8.png)\r\n这样基本上，这个mysql就装好了。\r\n\r\n## 12. 登录mysql并修改密码\r\n命令：`mysql -uroot -p生成的密码`\r\n执行修改密码：`alter user ‘root’@’localhost’ identified by ‘newpassword’;`\r\n\r\n# 四 安装php-fpm\r\n## 1. 安装依赖包:\r\n```\r\nyum install libmcrypt libmcrypt-devel mhash mhash-devel libxml2 libxml2-devel bzip2 bzip2-devel\r\n```\r\n这里还漏了几个，如果报错了提示缺少了什么就yum补上。\r\n\r\n## 2. 到官网下载源码包后，开始编译安装：\r\n```\r\n# tar xvf php-7.0.16.tar.bz2 -C /usr/local/src\r\n# cd /usr/local/src/php-7.0.16\r\n```\r\n执行下面的配置文件：\r\n```\r\n# ./configure --prefix=/usr/local/php \\\r\n--with-config-file-scan-dir=/etc/php.d \\\r\n--with-config-file-path=/etc \\\r\n--with-mysql=/usr/local/mysql \\\r\n--with-mysqli=/usr/local/mysql/bin/mysql_config \\\r\n--enable-fpm \\\r\n--enable-opcache \\\r\n--disable-fileinfo \\\r\n--with-jpeg-dir \\\r\n--with-iconv-dir=/usr/local \\\r\n--with-freetype-dir \\\r\n--with-png-dir \\\r\n--with-zlib \\\r\n--with-libxml-dir=/usr \\\r\n--enable-xml \\\r\n--enable-bcmath \\\r\n--enable-shmop \\\r\n--enable-exif \\\r\n--with-curl \\\r\n--enable-sysvsem \\\r\n--enable-inline-optimization \\\r\n--enable-mbregex \\\r\n--enable-inline-optimization \\\r\n--enable-mbstring \\\r\n--with-mcrypt \\\r\n--with-gd \\\r\n--enable-gd-native-ttf \\\r\n--with-openssl \\\r\n--with-mhash \\\r\n--enable-pcntl \\\r\n--enable-sockets \\\r\n--with-xmlrpc \\\r\n--enable-ftp \\\r\n--with-gettext \\\r\n--enable-zip \\\r\n--enable-soap \\\r\n--with-bz2\r\n```\r\n执行以上的配置，如果出现下面这样的license，才是正确的，才可以开始编译，如果出问题，就解决，一般是少了什么库。（注意将来可能会用到的一些库，先正确地编译好以免以后再来编就麻烦了，比如openssl, gd, mbstring, sockets, opcache等等）\r\n![](https://www.goozp.com/uploads/2018/01/LNMP9.png)\r\n执行编译：\r\n`# make && make install`\r\n\r\n## 3. 添加php和php-fpm配置文件。\r\n```\r\n# cp /usr/local/src/php-7.0.16/php.ini-production /etc/php.ini\r\n# cd /usr/local/php/etc/\r\n# cp php-fpm.conf.default php-fpm.conf\r\n# sed -i ‘s@;pid = run/php-fpm.pid@pid = /usr/local/php/var/run/php-fpm.pid@’ php-fpm.conf\r\n```\r\n\r\n## 4. 添加php-fpm启动脚本。\r\n```\r\n# cp /usr/local/src/php-7.0.16/sapi/fpm/init.d.php-fpm /etc/init.d/php-fpm\r\n# chmod +x /etc/init.d/php-fpm\r\n```\r\n\r\n## 5. 添加php-fpm至服务列表并设置开机自启。\r\n```\r\n# chkconfig –add php-fpm\r\n# chkconfig –list php-fpm\r\n# chkconfig php-fpm on\r\n```\r\n\r\n## 6. 启动服务。\r\n`# service php-fpm start`\r\n\r\n注：启动时如出现错误：WARNING: Nothing matches the include pattern ‘/usr/local/etc/php-fpm.d/*.conf’ from /usr/local/etc/php-fpm.conf at line 125.\r\nERROR:. No pool defined at least one pool section must be specified in config file\r\nERROR: failed to post process the configuration\r\nERROR: FPM initialization failed\r\n解决：到指定目录执行cp www.conf.default www.conf\r\n\r\n## 7. 添加nginx对fastcgi的支持，\r\n首先备份默认的配置文件。\r\n```\r\n# cp /etc/nginx/nginx.conf /etc/nginx/nginx.confbak\r\n# cp /etc/nginx/nginx.conf.default /etc/nginx/nginx.conf\r\n```\r\n\r\n编辑/etc/nginx/nginx.conf，在所支持的主页面格式中添加php格式的主页，类似如下：\r\n```\r\nlocation / {\r\n    root /usr/local/nginx/html;\r\n    index index.php index.html index.htm;\r\n}\r\n```\r\n取消以下内容前面的注释：\r\n```\r\nlocation ~ \\.php$ {\r\n    root /usr/local/nginx/html;\r\n    fastcgi_pass 127.0.0.1:9000;\r\n    fastcgi_index index.php;\r\n    fastcgi_param SCRIPT_FILENAME /usr/local/nginx/html/$fastcgi_script_name;\r\n    include fastcgi_params;\r\n}\r\n```\r\n\r\n## 8. 重启nginx\r\n`# service nginx reload`\r\n\r\n## 9. 测试是否成功\r\n在/usr/local/nginx/html/新建index.php的测试页面，内容如下：\r\n```php\r\n<?php\r\nphpinfo();\r\n?>\r\n```\r\n![](https://www.goozp.com/uploads/2018/01/LNMP10.png)\r\n如果出现这个熟悉的界面，说明就大功告成了！Linux下一个基本的LNMP就搭建完毕了。', '<p>最近研究了Linux系统下的PHP环境搭建，个人感觉最好最好不要用yum默认的程序包安装，因为版本都比较低，下载最新的稳定版自行安装比较好。现在网上教程很多，之所以还记这篇，原因有一点，当你重复网上的教程自行安装时，90%还是会出现各种各样的问题，因为你可能linux的系统版本不同，你想装的软件版本不同，安装的方法不同，你下错了安装包的版本，还有其它乱七八糟的。举个例，比如你看着5.6的mysql安装教程，装5.7的，你感觉没问题，但是事实就是，5.7的不一样了！而且网上还没有新的这方面内容，不好找，这就需要你去摸索了，亲身经历啊。这里面，Niginx感觉最好配，MySQL最坑。</p>\r\n<p>本篇安装的软件版本为：</p>\r\n<ul>\r\n<li>Linux：Centos6.8</li><li>Nginx：1.10.3</li><li>MySQL：5.7.17</li><li>PHP：7.0.16</li></ul>\r\n<hr>\r\n<h1 id=\"h1--\"><a name=\"一 准备工作\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一 准备工作</h1><h2 id=\"h2-1-selinux\"><a name=\"1. 关闭SELINUX\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1. 关闭SELINUX</h2><p>修改配置文件，重启服务后永久生效。<br><code># sed -i ‘s/SELINUX=.*/SELINUX=disabled/g’ /etc/selinux/config</code><br>命令行设置立即生效。<br><code># setenforce 0</code></p>\r\n<h2 id=\"h2-2-ecs-80-\"><a name=\"2. 如果是阿里云ECS用户，安全组设置中开启80端口方便调试。\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2. 如果是阿里云ECS用户，安全组设置中开启80端口方便调试。</h2><h1 id=\"h1--nginx\"><a name=\"二 安装Nginx\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二 安装Nginx</h1><h2 id=\"h2-1-\"><a name=\"1. 下载源码包\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1. 下载源码包</h2><p>上Nginx官网，复制最新稳定版的下载地址过来，然后用wget下载（接下来需要下载安装包的都可以用wget）：</p>\r\n<pre><code># cd /usr/local/src\r\n# wget http://nginx.org/download/nginx-1.10.3.tar.gz\r\n</code></pre><p><img src=\"https://www.goozp.com/uploads/2018/01/LNMP2.png\" alt=\"\"><br>下载完成的状态基本都是以下这样的：<br><img src=\"https://www.goozp.com/uploads/2018/01/LNMP3.png\" alt=\"\"></p>\r\n<h2 id=\"h2-2-\"><a name=\"2. 进行解压编译\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2. 进行解压编译</h2><pre><code># tar xvf nginx-1.10.3.tar.gz\r\n# yum groupinstall “Development tools”\r\n# yum -y install gcc wget gcc-c++ automake autoconf libtool libxml2-devel libxslt-devel perl-devel perl-ExtUtils-Embed pcre-devel openssl-devel\r\n</code></pre><p><img src=\"https://www.goozp.com/uploads/2018/01/LNMP4.png\" alt=\"\"></p>\r\n<p>执行完成。</p>\r\n<p>进入解压后的nginx-1.10.3文件夹：<br><code>cd /usr/local/src/nginx-1.10.3</code><br>执行以下语句：</p>\r\n<pre><code>./configure \\\r\n--prefix=/usr/local/nginx \\\r\n--sbin-path=/usr/sbin/nginx \\\r\n--conf-path=/etc/nginx/nginx.conf \\\r\n--error-log-path=/var/log/nginx/error.log \\\r\n--http-log-path=/var/log/nginx/access.log \\\r\n--pid-path=/var/run/nginx.pid \\\r\n--lock-path=/var/run/nginx.lock \\\r\n--http-client-body-temp-path=/var/tmp/nginx/client \\\r\n--http-proxy-temp-path=/var/tmp/nginx/proxy \\\r\n--http-fastcgi-temp-path=/var/tmp/nginx/fcgi \\\r\n--http-uwsgi-temp-path=/var/tmp/nginx/uwsgi \\\r\n--http-scgi-temp-path=/var/tmp/nginx/scgi \\\r\n--user=nginx \\\r\n--group=nginx \\\r\n--with-pcre \\\r\n--with-http_v2_module \\\r\n--with-http_ssl_module \\\r\n--with-http_realip_module \\\r\n--with-http_addition_module \\\r\n--with-http_sub_module \\\r\n--with-http_dav_module \\\r\n--with-http_flv_module \\\r\n--with-http_mp4_module \\\r\n--with-http_gunzip_module \\\r\n--with-http_gzip_static_module \\\r\n--with-http_random_index_module \\\r\n--with-http_secure_link_module \\\r\n--with-http_stub_status_module \\\r\n--with-http_auth_request_module \\\r\n--with-mail \\\r\n--with-mail_ssl_module \\\r\n--with-file-aio \\\r\n--with-ipv6 \\\r\n--with-http_v2_module \\\r\n--with-threads \\\r\n--with-stream \\\r\n--with-stream_ssl_module \\\r\n--with-openssl\r\n</code></pre><p>完成后执行编译：</p>\r\n<pre><code># make &amp;&amp; make install\r\n# mkdir -pv /var/tmp/nginx/client\r\n</code></pre><h2 id=\"h2-3-sysv-\"><a name=\"3. 添加SysV启动脚本。\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3. 添加SysV启动脚本。</h2><p>用vim编辑脚本：<br><code># vim /etc/init.d/nginx</code><br>写入以下内容：</p>\r\n<pre><code>#!/bin/sh\r\n#\r\n# nginx - this script starts and stops the nginx daemon\r\n#\r\n# chkconfig:   - 85 15 \r\n# description: Nginx is an HTTP(S) server, HTTP(S) reverse \\\r\n#               proxy and IMAP/POP3 proxy server\r\n# processname: nginx\r\n# config:      /etc/nginx/nginx.conf\r\n# config:      /etc/sysconfig/nginx\r\n# pidfile:     /var/run/nginx.pid\r\n# Source function library.\r\n. /etc/rc.d/init.d/functions\r\n# Source networking configuration.\r\n. /etc/sysconfig/network\r\n# Check that networking is up.\r\n[ &quot;$NETWORKING&quot; = &quot;no&quot; ] &amp;amp;amp;amp;amp;&amp;amp;amp;amp;amp; exit 0\r\nnginx=&quot;/usr/sbin/nginx&quot;\r\nprog=$(basename $nginx)\r\nNGINX_CONF_FILE=&quot;/etc/nginx/nginx.conf&quot;\r\n[ -f /etc/sysconfig/nginx ] &amp;amp;amp;amp;amp;&amp;amp;amp;amp;amp; . /etc/sysconfig/nginx\r\nlockfile=/var/lock/subsys/nginx\r\nstart() {\r\n    [ -x $nginx ] || exit 5\r\n    [ -f $NGINX_CONF_FILE ] || exit 6\r\n    echo -n $&quot;Starting $prog: &quot;\r\n    daemon $nginx -c $NGINX_CONF_FILE\r\n    retval=$?\r\n    echo \r\n    [ $retval -eq 0 ] &amp;amp;amp;amp;amp;&amp;amp;amp;amp;amp; touch $lockfile\r\n    return $retval\r\n}\r\nstop() {\r\n    echo -n $&quot;Stopping $prog: &quot;\r\n    killproc $prog -QUIT\r\n    retval=$?\r\n    echo\r\n    [ $retval -eq 0 ] &amp;amp;amp;amp;amp;&amp;amp;amp;amp;amp; rm -f $lockfile\r\n    return $retval\r\nkillall -9 nginx\r\n}\r\nrestart() {\r\n    configtest || return $?\r\n    stop\r\n    sleep 1\r\n    start\r\n}\r\nreload() {\r\n    configtest || return $?\r\n    echo -n $&quot;Reloading $prog: &quot;\r\n    killproc $nginx -HUP\r\nRETVAL=$?\r\n    echo\r\n}\r\nforce_reload() {\r\n    restart\r\n}\r\nconfigtest() {\r\n$nginx -t -c $NGINX_CONF_FILE\r\n}\r\nrh_status() {\r\n    status $prog\r\n}\r\nrh_status_q() {\r\n    rh_status &amp;amp;amp;amp;gt;/dev/null 2&amp;amp;amp;amp;gt;&amp;amp;amp;amp;amp;1\r\n}\r\ncase &quot;$1&quot; in\r\n    start)\r\n        rh_status_q &amp;amp;amp;amp;amp;&amp;amp;amp;amp;amp; exit 0\r\n    $1\r\n        ;;\r\n    stop)\r\n        rh_status_q || exit 0\r\n        $1\r\n        ;;\r\n    restart|configtest)\r\n        $1\r\n        ;;\r\n    reload)\r\n        rh_status_q || exit 7\r\n        $1\r\n        ;;\r\n    force-reload)\r\n        force_reload\r\n        ;;\r\n    status)\r\n        rh_status\r\n        ;;\r\n    condrestart|try-restart)\r\n        rh_status_q || exit 0\r\n            ;;\r\n    *)\r\n      echo $&quot;Usage: $0 {start|stop|status|restart|condrestart|try-restart|reload|force-reload|configtest}&quot;\r\n        exit 2\r\nesac\r\n</code></pre><p>保存退出（按:wq!）；可能你得稍微查一下vim的一些命令，不然操作时可能会出现一点小问题。<br>赋予脚本执行权限：<br><code># chmod +x /etc/init.d/nginx</code></p>\r\n<p>添加至服务管理列表，设置开机自启：</p>\r\n<pre><code># chkconfig –add nginx\r\n# chkconfig nginx on\r\n</code></pre><h2 id=\"h2-4-\"><a name=\"4. 启动服务。\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4. 启动服务。</h2><p><code># service nginx start</code><br><img src=\"https://www.goozp.com/uploads/2018/01/LNMP6.png\" alt=\"\"><br>出现这玩意说明成功了！</p>\r\n<blockquote>\r\n<p>注：如果报错 [emerg]: getpwnam(“nginx”) failed ；<br>  解决方法：<code># useradd -s /sbin/nologin -M nginx</code> <code># id nginx</code></p>\r\n</blockquote>\r\n<h1 id=\"h1--mysql\"><a name=\"三 安装mysql\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>三 安装mysql</h1><h2 id=\"h2-1-\"><a name=\"1. 版本选择\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1. 版本选择</h2><p>在安装之前必须明白一件事情，mysql有很多种安装方式，每种不一样，不要弄混了。<br>比如源码编译安装（mysql-5.7.17.tar.gz），二进制安装（mysql-5.7.17-linux-glibc2.5-i686.tar），nmp安装（最简单的）。这里我们用源码自己编译安装。</p>\r\n<h2 id=\"h2-2-\"><a name=\"2. 准备编译环境\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2. 准备编译环境</h2><pre><code># yum groupinstall “Server Platform Development” “Development tools” -y\r\n# yum install cmake -y\r\n</code></pre><p>cmake在现在的版本是必须要安装的，你可以下载camke之后编译，也可以直接yum安装。接下来的编译过程如果报错缺少什么就补什么。</p>\r\n<h2 id=\"h2-3-mysql-\"><a name=\"3. 准备mysql数据库存放目录\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3. 准备mysql数据库存放目录</h2><pre><code># mkdir /mnt/data\r\n# groupadd -r mysql\r\n# useradd -r -g mysql -s /sbin/nologin mysql\r\n# id mysql\r\n</code></pre><h2 id=\"h2-4-\"><a name=\"4. 更改数据目录权限。\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4. 更改数据目录权限。</h2><p><code># chown -R mysql:mysql /mnt/data</code></p>\r\n<h2 id=\"h2-5-\"><a name=\"5. 下载并解压编译官网下载的稳定版的源码包。\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5. 下载并解压编译官网下载的稳定版的源码包。</h2><p>在下载的时候注意一下版本，下载对应的版本。我们源码编译，要下载长这样的安装包：mysql-5.7.17.tar.gz，同时在安装的时候我们需要boost库，5.7需要1.59版本的库；你可以下载boost库然后编译boost库，或者像我一样，下载带有boost库的mysql版本。</p>\r\n<p>开始解压编译：</p>\r\n<pre><code># tar xvf mysql-boost-5.7.17.tar.gz -C /usr/local/src\r\n# cd /usr/local/src/mysql-5.7.17\r\n# cmake . -DCMAKE_INSTALL_PREFIX=/usr/local/mysql \\\r\n-DMYSQL_DATADIR=/mnt/data \\\r\n-DSYSCONFDIR=/etc \\\r\n-DWITH_INNOBASE_STORAGE_ENGINE=1 \\\r\n-DWITH_ARCHIVE_STORAGE_ENGINE=1 \\\r\n-DWITH_BLACKHOLE_STORAGE_ENGINE=1 \\\r\n-DWITH_READLINE=1 \\\r\n-DWITH_SSL=system \\\r\n-DWITH_ZLIB=system \\\r\n-DWITH_LIBWRAP=0 \\\r\n-DMYSQL_TCP_PORT=3306 \\\r\n-DMYSQL_UNIX_ADDR=/tmp/mysql.sock \\\r\n-DDEFAULT_CHARSET=utf8 \\\r\n-DDEFAULT_COLLATION=utf8_general_ci\r\n-DDOWNLOAD_BOOST=1 \\\r\n-DWITH_BOOST=/usr/local/mysql/boost/boost_1_59_0 \\\r\n# make &amp;&amp; make install\r\n</code></pre><h2 id=\"h2-6-\"><a name=\"6. 修改安装目录的权限属组\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>6. 修改安装目录的权限属组</h2><p><code># chown -R mysql:mysql /usr/local/mysql/</code></p>\r\n<h2 id=\"h2-7-\"><a name=\"7. 初始化数据库。\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>7. 初始化数据库。</h2><p><code># /usr/local/mysql/bin/mysqld –initialize –user=mysql –basedir=/usr/local/mysql –datadir=/mnt/data/</code><br>需要注意这里是mysql5.7的初始化命令，而5.7以下的都是用：<br><code># /usr/local/mysql/scripts/mysql_install_db –user=mysql –datadir=/mnt/data/</code><br>在初始化成功之后，5.7的initial命令会产生一个随机的root登录密码，你要用这个密码登录，然后修改（必须修改生成的随机密码不然无法后续操作）。在最后有一个类似这样的密码：<br><img src=\"https://www.goozp.com/uploads/2018/01/LNMP7.png\" alt=\"\"></p>\r\n<h2 id=\"h2-8-\"><a name=\"8. 复制配置文件\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>8. 复制配置文件</h2><p><code># cp support-files/my-default.cnf /etc/my.cnf</code><br>这里又有一点要注意：mysql5.7配置文件需要修改my.cnf关键配置， mysql5.7之前默认配置文件中是有配置项的，不用手动修改。以下为配置，根据实际情况修改：</p>\r\n<pre><code>[mysqld]\r\nbasedir = /usr/local/mysql\r\ndatadir = /mnt/data\r\nport = 3306\r\nsocket = /Ultrapower/test/mysql/tmp/mysql.sock\r\n\r\nsql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES\r\n[client]\r\nsocket = /Ultrapower/test/mysql/tmp/mysql.sock\r\n</code></pre><p>如果添加[client]下 的内容，注意<code>sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES</code>要放在[mysqld]下。<br>如果报错tmp目录不错在，到对应的地方去创建目录，然后创建后要赋予mysql权限，<code>chown -R mysql:mysql tmp</code>。</p>\r\n<h2 id=\"h2-9-\"><a name=\"9. 设置开机启动\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>9. 设置开机启动</h2><pre><code># cp /usr/local/mysql/support-files/mysql.server /etc/init.d/mysqld\r\n# chmod +x /etc/init.d/mysql\r\n</code></pre><p>注册为开机启动服务：</p>\r\n<pre><code># chkconfig mysqld on\r\n# chkconfig –add mysqld\r\n</code></pre><p>查看是否设置成功：<br><code># chkconfig –list mysql</code></p>\r\n<h2 id=\"h2-10-path-\"><a name=\"10. 设置PATH环境变量。\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>10. 设置PATH环境变量。</h2><pre><code># echo “export PATH=$PATH:/usr/local/mysql/bin” &gt; /etc/profile.d/mysql.sh\r\n# source /etc/profile.d/mysql.sh\r\n</code></pre><h2 id=\"h2-11-\"><a name=\"11. 启动服务\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>11. 启动服务</h2><p><code># service mysqld start</code></p>\r\n<p><img src=\"https://www.goozp.com/uploads/2018/01/LNMP8.png\" alt=\"\"><br>这样基本上，这个mysql就装好了。</p>\r\n<h2 id=\"h2-12-mysql-\"><a name=\"12. 登录mysql并修改密码\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>12. 登录mysql并修改密码</h2><p>命令：<code>mysql -uroot -p生成的密码</code><br>执行修改密码：<code>alter user ‘root’@’localhost’ identified by ‘newpassword’;</code></p>\r\n<h1 id=\"h1--php-fpm\"><a name=\"四 安装php-fpm\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>四 安装php-fpm</h1><h2 id=\"h2-1-\"><a name=\"1. 安装依赖包:\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1. 安装依赖包:</h2><pre><code>yum install libmcrypt libmcrypt-devel mhash mhash-devel libxml2 libxml2-devel bzip2 bzip2-devel\r\n</code></pre><p>这里还漏了几个，如果报错了提示缺少了什么就yum补上。</p>\r\n<h2 id=\"h2-2-\"><a name=\"2. 到官网下载源码包后，开始编译安装：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2. 到官网下载源码包后，开始编译安装：</h2><pre><code># tar xvf php-7.0.16.tar.bz2 -C /usr/local/src\r\n# cd /usr/local/src/php-7.0.16\r\n</code></pre><p>执行下面的配置文件：</p>\r\n<pre><code># ./configure --prefix=/usr/local/php \\\r\n--with-config-file-scan-dir=/etc/php.d \\\r\n--with-config-file-path=/etc \\\r\n--with-mysql=/usr/local/mysql \\\r\n--with-mysqli=/usr/local/mysql/bin/mysql_config \\\r\n--enable-fpm \\\r\n--enable-opcache \\\r\n--disable-fileinfo \\\r\n--with-jpeg-dir \\\r\n--with-iconv-dir=/usr/local \\\r\n--with-freetype-dir \\\r\n--with-png-dir \\\r\n--with-zlib \\\r\n--with-libxml-dir=/usr \\\r\n--enable-xml \\\r\n--enable-bcmath \\\r\n--enable-shmop \\\r\n--enable-exif \\\r\n--with-curl \\\r\n--enable-sysvsem \\\r\n--enable-inline-optimization \\\r\n--enable-mbregex \\\r\n--enable-inline-optimization \\\r\n--enable-mbstring \\\r\n--with-mcrypt \\\r\n--with-gd \\\r\n--enable-gd-native-ttf \\\r\n--with-openssl \\\r\n--with-mhash \\\r\n--enable-pcntl \\\r\n--enable-sockets \\\r\n--with-xmlrpc \\\r\n--enable-ftp \\\r\n--with-gettext \\\r\n--enable-zip \\\r\n--enable-soap \\\r\n--with-bz2\r\n</code></pre><p>执行以上的配置，如果出现下面这样的license，才是正确的，才可以开始编译，如果出问题，就解决，一般是少了什么库。（注意将来可能会用到的一些库，先正确地编译好以免以后再来编就麻烦了，比如openssl, gd, mbstring, sockets, opcache等等）<br><img src=\"https://www.goozp.com/uploads/2018/01/LNMP9.png\" alt=\"\"><br>执行编译：<br><code># make &amp;&amp; make install</code></p>\r\n<h2 id=\"h2-3-php-php-fpm-\"><a name=\"3. 添加php和php-fpm配置文件。\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3. 添加php和php-fpm配置文件。</h2><pre><code># cp /usr/local/src/php-7.0.16/php.ini-production /etc/php.ini\r\n# cd /usr/local/php/etc/\r\n# cp php-fpm.conf.default php-fpm.conf\r\n# sed -i ‘s@;pid = run/php-fpm.pid@pid = /usr/local/php/var/run/php-fpm.pid@’ php-fpm.conf\r\n</code></pre><h2 id=\"h2-4-php-fpm-\"><a name=\"4. 添加php-fpm启动脚本。\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4. 添加php-fpm启动脚本。</h2><pre><code># cp /usr/local/src/php-7.0.16/sapi/fpm/init.d.php-fpm /etc/init.d/php-fpm\r\n# chmod +x /etc/init.d/php-fpm\r\n</code></pre><h2 id=\"h2-5-php-fpm-\"><a name=\"5. 添加php-fpm至服务列表并设置开机自启。\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5. 添加php-fpm至服务列表并设置开机自启。</h2><pre><code># chkconfig –add php-fpm\r\n# chkconfig –list php-fpm\r\n# chkconfig php-fpm on\r\n</code></pre><h2 id=\"h2-6-\"><a name=\"6. 启动服务。\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>6. 启动服务。</h2><p><code># service php-fpm start</code></p>\r\n<p>注：启动时如出现错误：WARNING: Nothing matches the include pattern ‘/usr/local/etc/php-fpm.d/*.conf’ from /usr/local/etc/php-fpm.conf at line 125.<br>ERROR:. No pool defined at least one pool section must be specified in config file<br>ERROR: failed to post process the configuration<br>ERROR: FPM initialization failed<br>解决：到指定目录执行cp www.conf.default www.conf</p>\r\n<h2 id=\"h2-7-nginx-fastcgi-\"><a name=\"7. 添加nginx对fastcgi的支持，\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>7. 添加nginx对fastcgi的支持，</h2><p>首先备份默认的配置文件。</p>\r\n<pre><code># cp /etc/nginx/nginx.conf /etc/nginx/nginx.confbak\r\n# cp /etc/nginx/nginx.conf.default /etc/nginx/nginx.conf\r\n</code></pre><p>编辑/etc/nginx/nginx.conf，在所支持的主页面格式中添加php格式的主页，类似如下：</p>\r\n<pre><code>location / {\r\n    root /usr/local/nginx/html;\r\n    index index.php index.html index.htm;\r\n}\r\n</code></pre><p>取消以下内容前面的注释：</p>\r\n<pre><code>location ~ \\.php$ {\r\n    root /usr/local/nginx/html;\r\n    fastcgi_pass 127.0.0.1:9000;\r\n    fastcgi_index index.php;\r\n    fastcgi_param SCRIPT_FILENAME /usr/local/nginx/html/$fastcgi_script_name;\r\n    include fastcgi_params;\r\n}\r\n</code></pre><h2 id=\"h2-8-nginx\"><a name=\"8. 重启nginx\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>8. 重启nginx</h2><p><code># service nginx reload</code></p>\r\n<h2 id=\"h2-9-\"><a name=\"9. 测试是否成功\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>9. 测试是否成功</h2><p>在/usr/local/nginx/html/新建index.php的测试页面，内容如下：</p>\r\n<pre><code class=\"lang-php\">&lt;?php\r\nphpinfo();\r\n?&gt;\r\n</code></pre>\r\n<p><img src=\"https://www.goozp.com/uploads/2018/01/LNMP10.png\" alt=\"\"><br>如果出现这个熟悉的界面，说明就大功告成了！Linux下一个基本的LNMP就搭建完毕了。</p>\r\n', '', 0, 'publish', 1, 0, '/article/37.html', '', 0, 105, '2017-03-02 17:48:51', '2017-03-02 17:48:51', '2018-01-09 07:48:49', NULL);
INSERT INTO `pt_post` VALUES (38, 10, 'article', 'WordPress全站HTTP转HTTPS实践（WordPress+阿里云）', '> 首先，讲一下我对于HTTP转HTTPS的想法和做法。\r\n现在有一些站长是采用保守的策略，考虑到一些其它的因素，保留了HTTP，即HTTP和HTTPS共存。作为一个IT行业的人，我个人的想法是，这种做法，那你转HTTPS就失去了本身的意义了。所以本站转HTTPS，将把HTTP强制转HTTPS，既然要做，那就做彻底，HTTPS是大势所趋，与时俱进。现代浏览器基本都是支持的。\r\n是的，就是这么简单粗暴。当然啦，这是我个人的做法。\r\n\r\n# 什么是HTTPS\r\n其实就是HTTP的安全版。就是在HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。\r\n\r\n# HTTPS对于站点加载速度的影响\r\n很多站长不想升级HTTPS，是因为都觉得HTTPS慢！确实，是有这个原因的，HTTPS因为对数据进行加密，所有要处理一些加解密废了些时间。不过，有一点要知道，那就是，HTTPS只有在第一次访问的时候才会慢一点，进入站点后第二次开始就跟HTTP没区别了。举个例子，两个人初次会面，先握个手，然后开始聊天，聊天过程中不会再握手；第二天再见面时，再握个手，然后接下来聊天又不会握手了。HTTPS的缓存期过了之后，才会重新进行一次加密验证，所以对于速度的影响，其实不大。\r\n\r\n如果实在担心速度问题，可以对服务器做一些优化。\r\n\r\n# 申请SSL证书\r\n现在很多平台，比如阿里云，腾讯云，七牛都可以申请证书了，而且有免费的证书可以申请。像我们这样的个人用户，其实申请免费的就可以了。这里拿阿里云做例子，因为本人是阿里云用户。\r\n在控制台的“安全（云盾）”板块找到“证书服务”，进去之后就是你证书的列表，直接点击购买证书。\r\n![](https://www.goozp.com/uploads/2018/01/tohttps2.png)\r\n选择免费型DV SSL。直接购买即可。\r\n\r\n买了之后回到证书服务的页面，把该填的信息填了，提交审核就可以。阿里云很方便，我们可以选择自动生成证书的pem和key。如果是万网的域名，还可以选择自动解析。如果是阿里云一站式用户，基本上就是填一些资料提交就行了。\r\n\r\n# 安装证书\r\n证书下来之后，点击下载。就进入到证书的下载页面，把证书下载下来。阿里云已经提供了各种服务器类型的安装方法。这里我用的是Nginx，以下是我弃用http（80端口）的做法：\r\n找到listen 80要升级为https的server{}配置，修改为：\r\n```\r\nserver {\r\n        listen 443 ssl;\r\n        server_name www.gzpblog.com;\r\n        ssl_certificate   /usr/local/nginx/cert/ggg.pem;\r\n        ssl_certificate_key  /usr/local/nginx/cert/ggg.key;\r\n        ssl_session_timeout 5m;\r\n        ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;\r\n        ssl_protocols TLSv1 TLSv1.1 TLSv1.2;\r\n        ssl_prefer_server_ciphers on;\r\n\r\n#其它配置省略\r\n        location / {\r\n           ……\r\n        }\r\n           ……\r\n}\r\n```\r\n这些内容阿里云有提供的。如果你想仔细研究一下配置也可以。注意一下证书引入的路径，你需要将你下载下来的证书上传到那里，并且引入。配置完这个，重启Nginx，基本上就可以通过Https来访问你的站点了。\r\n\r\n# HSTS的启用\r\nHSTS是一种新的Web安全协议，它的作用，是强制客户端（如浏览器）使用HTTPS与服务器创建连接。在启用前先确定一下这是你需要的，本站全站HTTPS了，所以开启此功能。\r\n\r\n在我们刚才安装证书的配置下面，加上下面这一条：\r\n```\r\nadd_header Strict-Transport-Security \"max-age=63072000; includeSubdomains; preload\";\r\n```\r\n重启Nginx就可以了。开启HSTS之后，只要用户通过HTTPS访问了你的站点，下次再访问时，就会自动通过HTTPS来访问。\r\n\r\n那么就有一个问题，当有人从来没访问过你的站点时，那他第一次访问，肯定还是通过http，因为此时HSTS还没有通过HTTPS生效。当然，这个问题是有解决办法的，谷歌维护了一个[预载入列表](https://hstspreload.org/ \"预载入列表\")，一开始是Chrome使用的，后来大部分浏览器都加入了。这个列表直接告诉浏览器，这个站点支持HTTPS，你得用HTTPS的方式来访问。不过，如果你并不能确定你的网站从此以后一直使用 HTTPS，那还是不要加入这个列表。因为，加入后很难撤销，你可以要求撤销，但是这个数据重新更新到稳定版的 Chrome 同样需要几个月，而别的浏览器是如何处理这个撤销数据的，则无法保证。\r\n\r\n# 301跳转\r\n转HTTPS之后，还有一些站长比较担心搜索引擎收录。谷歌的支持是比较好的，而国内的好像还不太行。\r\n不过，百度是有发过公告支持HTTPS的：\r\n![](https://www.goozp.com/uploads/2018/01/tohttps3.png)\r\n具体百度做得怎么样，我们就不深究了，但是既然人家都发话了，那我也就不怂了，毕竟我这个博客，对收录还不至于很致命。所以，我干脆直接301跳转，就是这么刚！\r\n\r\n除了以上配置，我还有一些301跳转的配置以强制使用HTTPS：\r\n80端口全部跳转到443：\r\n```\r\nserver {\r\n    listen       80;\r\n    server_name  www.gzpblog.com gzpblog.com;\r\n    return       301 https://www.gzpblog.com$request_uri;\r\n}\r\n```\r\n443端口主域名跳转到www域名：\r\n```\r\nserver {\r\n    listen 443 ssl;\r\n    server_name gzpblog.com;\r\n    return      301 https://www.gzpblog.com$request_uri;\r\n}\r\n```\r\n\r\n# 看一下启用HTTPS后的速度\r\n现在我们的站点已经是启用HTTPS了，可以看到舒服的小绿锁：\r\n![](https://www.goozp.com/uploads/2018/01/tohttps4.png)\r\n\r\n来看一下启用后网站加载速度的影响，首先这个是启用之前：\r\n![](https://www.goozp.com/uploads/2018/01/tohttps5.png)\r\n然后启用之后是这样的，首次握手的表现：\r\n![](https://www.goozp.com/uploads/2018/01/tohttps6.png)\r\n可以看到，传输数据爆增，加载速度确实慢下来了，但是当我们再次刷新网页时：\r\n![](https://www.goozp.com/uploads/2018/01/tohttps7.png)\r\n速度又回到之前的水平，只有第一次才收到影响。而实际上在第一次时，从用户体验上来看，差距也不大，并没有太大的页面呈现拖后（是有一点点，但是问题不大啊）。\r\n\r\n# 全站HTTPS\r\n接下来，如果我们点进文章页，会发现这种情况，比如在谷歌下，小绿锁变成了感叹号：\r\n![](https://www.goozp.com/uploads/2018/01/tohttps8.png)\r\n\r\n在火狐下，出现了黄色感叹号标志：\r\n![](https://www.goozp.com/uploads/2018/01/tohttps9.png)\r\n\r\n既然全站HTTPS，这种情况我们是要解决的。这说明我们的文章中的图片，还是http的。接下来处理这个问题。我们先到后台改一下这个链接为https的：\r\n![](https://www.goozp.com/uploads/2018/01/tohttps10.png)\r\n\r\n处理图片这个问题，分两种情况，图片存在本服务器，和图片来自于比如阿里云OSS的服务器。我是存在阿里云的OSS的，接下来是存在OSS的解决方法。\r\n我们先直接在wordpress的主题中的functions.php中加上：\r\n```\r\nfunction replacehttp($content){\r\n    if( is_ssl() ){\r\n        $content = str_replace(\'https://files.gzpblog.com/wp/\', \'https://files.gzpblog.com/wp/\', $content);\r\n    }\r\n    return $content;\r\n}\r\nadd_filter(\'the_content\', \'replacehttp\');\r\n```\r\n\r\n修改后，我们文章中的图片地址就变成了https：\r\n![](https://www.goozp.com/uploads/2018/01/tohttps11.png)\r\n\r\n地址这个问题就解决了。但是这些图片链接点进去是这样的：\r\n![](https://www.goozp.com/uploads/2018/01/tohttps12_300x109.png)\r\n说明files.gzpblog.com域名还不支持HTTPS。这是接下来要做的。\r\n\r\n# 阿里云OSS服务器支持HTTPS\r\n首先阿里云OSS是支持https的，如果你是调用类似于bucket.oss-cn-shenzhen.aliyuncs.com域名图片地址时，本身就已经是https了。但是很多时候，我们并不这样做，比如本站就将该域名绑定到了二级域名files.gzpblog.com，用这个域名专门做图片链接。但是，我们的证书是免费证书，就是说不支持泛域名（比如*.gzpblog.com），那么这个时候files.gzpblog.com域名是不支持https的。oss的自定义绑定域名cname，不能https。\r\n\r\n处理这个问题，我们可以配合CDN加速来解决，开启HTTPS加速之后，要收费，其实这个不贵，1G的流量2毛线，个人觉得还行，因为我的流量不会很大；如果不使用这种方法，可以采用反向代理来解决，那就是Nginx改一下配置的事了。\r\n\r\n那现在我们需要为该域名再申请一张证书，申请的方法是一样的，但是这次我们不需要再自己安装证书了。使用云产品推送，直接推送到CDN（如果你是用了CDN加速图片并且是阿里云的OSS服务器，那就可以直接推过去，否则先设置一下加速域名，注意是加速类似files.gzpblog.com这个域名而不是主域名）。\r\n\r\n推送过去之后，我们到CDN的域名列表，点击“管理”，编辑“HTTPS安全加速”：\r\n![](https://www.goozp.com/uploads/2018/01/tohttps13.png)\r\n\r\n将这个开启，并且选择证书，注意不要选错选到www的证书去了。\r\n![](https://www.goozp.com/uploads/2018/01/tohttps14.png)\r\n\r\n配置完成后，这个域名就支持HTTPS了。到了这一步，基本上全站就支持HTTPS了，点进去基本都是小绿锁，可能你引入http链接的文章会没有。\r\n\r\n# 测试结果\r\n其实到目前为止，本站的HTTPS化并不完全，像什么IE6啊XP啊之类的老古董可能会不支持的。抱着与时俱进的心态，那些就先不考虑了，以后再做优化吧。来测试一下HTTPS的支持得如何，这是一个测试网站：[SSL Server Test](https://www.ssllabs.com/ssltest/index.html \"SSL Server Test\")\r\n', '<blockquote>\r\n<p>首先，讲一下我对于HTTP转HTTPS的想法和做法。<br>现在有一些站长是采用保守的策略，考虑到一些其它的因素，保留了HTTP，即HTTP和HTTPS共存。作为一个IT行业的人，我个人的想法是，这种做法，那你转HTTPS就失去了本身的意义了。所以本站转HTTPS，将把HTTP强制转HTTPS，既然要做，那就做彻底，HTTPS是大势所趋，与时俱进。现代浏览器基本都是支持的。<br>是的，就是这么简单粗暴。当然啦，这是我个人的做法。</p>\r\n</blockquote>\r\n<h1 id=\"h1--https\"><a name=\"什么是HTTPS\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>什么是HTTPS</h1><p>其实就是HTTP的安全版。就是在HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。</p>\r\n<h1 id=\"h1-https-\"><a name=\"HTTPS对于站点加载速度的影响\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>HTTPS对于站点加载速度的影响</h1><p>很多站长不想升级HTTPS，是因为都觉得HTTPS慢！确实，是有这个原因的，HTTPS因为对数据进行加密，所有要处理一些加解密废了些时间。不过，有一点要知道，那就是，HTTPS只有在第一次访问的时候才会慢一点，进入站点后第二次开始就跟HTTP没区别了。举个例子，两个人初次会面，先握个手，然后开始聊天，聊天过程中不会再握手；第二天再见面时，再握个手，然后接下来聊天又不会握手了。HTTPS的缓存期过了之后，才会重新进行一次加密验证，所以对于速度的影响，其实不大。</p>\r\n<p>如果实在担心速度问题，可以对服务器做一些优化。</p>\r\n<h1 id=\"h1--ssl-\"><a name=\"申请SSL证书\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>申请SSL证书</h1><p>现在很多平台，比如阿里云，腾讯云，七牛都可以申请证书了，而且有免费的证书可以申请。像我们这样的个人用户，其实申请免费的就可以了。这里拿阿里云做例子，因为本人是阿里云用户。<br>在控制台的“安全（云盾）”板块找到“证书服务”，进去之后就是你证书的列表，直接点击购买证书。<br><img src=\"https://www.goozp.com/uploads/2018/01/tohttps2.png\" alt=\"\"><br>选择免费型DV SSL。直接购买即可。</p>\r\n<p>买了之后回到证书服务的页面，把该填的信息填了，提交审核就可以。阿里云很方便，我们可以选择自动生成证书的pem和key。如果是万网的域名，还可以选择自动解析。如果是阿里云一站式用户，基本上就是填一些资料提交就行了。</p>\r\n<h1 id=\"h1-u5B89u88C5u8BC1u4E66\"><a name=\"安装证书\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>安装证书</h1><p>证书下来之后，点击下载。就进入到证书的下载页面，把证书下载下来。阿里云已经提供了各种服务器类型的安装方法。这里我用的是Nginx，以下是我弃用http（80端口）的做法：<br>找到listen 80要升级为https的server{}配置，修改为：</p>\r\n<pre><code>server {\r\n        listen 443 ssl;\r\n        server_name www.gzpblog.com;\r\n        ssl_certificate   /usr/local/nginx/cert/ggg.pem;\r\n        ssl_certificate_key  /usr/local/nginx/cert/ggg.key;\r\n        ssl_session_timeout 5m;\r\n        ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;\r\n        ssl_protocols TLSv1 TLSv1.1 TLSv1.2;\r\n        ssl_prefer_server_ciphers on;\r\n\r\n#其它配置省略\r\n        location / {\r\n           ……\r\n        }\r\n           ……\r\n}\r\n</code></pre><p>这些内容阿里云有提供的。如果你想仔细研究一下配置也可以。注意一下证书引入的路径，你需要将你下载下来的证书上传到那里，并且引入。配置完这个，重启Nginx，基本上就可以通过Https来访问你的站点了。</p>\r\n<h1 id=\"h1-hsts-\"><a name=\"HSTS的启用\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>HSTS的启用</h1><p>HSTS是一种新的Web安全协议，它的作用，是强制客户端（如浏览器）使用HTTPS与服务器创建连接。在启用前先确定一下这是你需要的，本站全站HTTPS了，所以开启此功能。</p>\r\n<p>在我们刚才安装证书的配置下面，加上下面这一条：</p>\r\n<pre><code>add_header Strict-Transport-Security &quot;max-age=63072000; includeSubdomains; preload&quot;;\r\n</code></pre><p>重启Nginx就可以了。开启HSTS之后，只要用户通过HTTPS访问了你的站点，下次再访问时，就会自动通过HTTPS来访问。</p>\r\n<p>那么就有一个问题，当有人从来没访问过你的站点时，那他第一次访问，肯定还是通过http，因为此时HSTS还没有通过HTTPS生效。当然，这个问题是有解决办法的，谷歌维护了一个<a href=\"https://hstspreload.org/\" title=\"预载入列表\">预载入列表</a>，一开始是Chrome使用的，后来大部分浏览器都加入了。这个列表直接告诉浏览器，这个站点支持HTTPS，你得用HTTPS的方式来访问。不过，如果你并不能确定你的网站从此以后一直使用 HTTPS，那还是不要加入这个列表。因为，加入后很难撤销，你可以要求撤销，但是这个数据重新更新到稳定版的 Chrome 同样需要几个月，而别的浏览器是如何处理这个撤销数据的，则无法保证。</p>\r\n<h1 id=\"h1-301-\"><a name=\"301跳转\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>301跳转</h1><p>转HTTPS之后，还有一些站长比较担心搜索引擎收录。谷歌的支持是比较好的，而国内的好像还不太行。<br>不过，百度是有发过公告支持HTTPS的：<br><img src=\"https://www.goozp.com/uploads/2018/01/tohttps3.png\" alt=\"\"><br>具体百度做得怎么样，我们就不深究了，但是既然人家都发话了，那我也就不怂了，毕竟我这个博客，对收录还不至于很致命。所以，我干脆直接301跳转，就是这么刚！</p>\r\n<p>除了以上配置，我还有一些301跳转的配置以强制使用HTTPS：<br>80端口全部跳转到443：</p>\r\n<pre><code>server {\r\n    listen       80;\r\n    server_name  www.gzpblog.com gzpblog.com;\r\n    return       301 https://www.gzpblog.com$request_uri;\r\n}\r\n</code></pre><p>443端口主域名跳转到www域名：</p>\r\n<pre><code>server {\r\n    listen 443 ssl;\r\n    server_name gzpblog.com;\r\n    return      301 https://www.gzpblog.com$request_uri;\r\n}\r\n</code></pre><h1 id=\"h1--https-\"><a name=\"看一下启用HTTPS后的速度\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>看一下启用HTTPS后的速度</h1><p>现在我们的站点已经是启用HTTPS了，可以看到舒服的小绿锁：<br><img src=\"https://www.goozp.com/uploads/2018/01/tohttps4.png\" alt=\"\"></p>\r\n<p>来看一下启用后网站加载速度的影响，首先这个是启用之前：<br><img src=\"https://www.goozp.com/uploads/2018/01/tohttps5.png\" alt=\"\"><br>然后启用之后是这样的，首次握手的表现：<br><img src=\"https://www.goozp.com/uploads/2018/01/tohttps6.png\" alt=\"\"><br>可以看到，传输数据爆增，加载速度确实慢下来了，但是当我们再次刷新网页时：<br><img src=\"https://www.goozp.com/uploads/2018/01/tohttps7.png\" alt=\"\"><br>速度又回到之前的水平，只有第一次才收到影响。而实际上在第一次时，从用户体验上来看，差距也不大，并没有太大的页面呈现拖后（是有一点点，但是问题不大啊）。</p>\r\n<h1 id=\"h1--https\"><a name=\"全站HTTPS\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>全站HTTPS</h1><p>接下来，如果我们点进文章页，会发现这种情况，比如在谷歌下，小绿锁变成了感叹号：<br><img src=\"https://www.goozp.com/uploads/2018/01/tohttps8.png\" alt=\"\"></p>\r\n<p>在火狐下，出现了黄色感叹号标志：<br><img src=\"https://www.goozp.com/uploads/2018/01/tohttps9.png\" alt=\"\"></p>\r\n<p>既然全站HTTPS，这种情况我们是要解决的。这说明我们的文章中的图片，还是http的。接下来处理这个问题。我们先到后台改一下这个链接为https的：<br><img src=\"https://www.goozp.com/uploads/2018/01/tohttps10.png\" alt=\"\"></p>\r\n<p>处理图片这个问题，分两种情况，图片存在本服务器，和图片来自于比如阿里云OSS的服务器。我是存在阿里云的OSS的，接下来是存在OSS的解决方法。<br>我们先直接在wordpress的主题中的functions.php中加上：</p>\r\n<pre><code>function replacehttp($content){\r\n    if( is_ssl() ){\r\n        $content = str_replace(&#39;https://files.gzpblog.com/wp/&#39;, &#39;https://files.gzpblog.com/wp/&#39;, $content);\r\n    }\r\n    return $content;\r\n}\r\nadd_filter(&#39;the_content&#39;, &#39;replacehttp&#39;);\r\n</code></pre><p>修改后，我们文章中的图片地址就变成了https：<br><img src=\"https://www.goozp.com/uploads/2018/01/tohttps11.png\" alt=\"\"></p>\r\n<p>地址这个问题就解决了。但是这些图片链接点进去是这样的：<br><img src=\"https://www.goozp.com/uploads/2018/01/tohttps12_300x109.png\" alt=\"\"><br>说明files.gzpblog.com域名还不支持HTTPS。这是接下来要做的。</p>\r\n<h1 id=\"h1--oss-https\"><a name=\"阿里云OSS服务器支持HTTPS\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>阿里云OSS服务器支持HTTPS</h1><p>首先阿里云OSS是支持https的，如果你是调用类似于bucket.oss-cn-shenzhen.aliyuncs.com域名图片地址时，本身就已经是https了。但是很多时候，我们并不这样做，比如本站就将该域名绑定到了二级域名files.gzpblog.com，用这个域名专门做图片链接。但是，我们的证书是免费证书，就是说不支持泛域名（比如*.gzpblog.com），那么这个时候files.gzpblog.com域名是不支持https的。oss的自定义绑定域名cname，不能https。</p>\r\n<p>处理这个问题，我们可以配合CDN加速来解决，开启HTTPS加速之后，要收费，其实这个不贵，1G的流量2毛线，个人觉得还行，因为我的流量不会很大；如果不使用这种方法，可以采用反向代理来解决，那就是Nginx改一下配置的事了。</p>\r\n<p>那现在我们需要为该域名再申请一张证书，申请的方法是一样的，但是这次我们不需要再自己安装证书了。使用云产品推送，直接推送到CDN（如果你是用了CDN加速图片并且是阿里云的OSS服务器，那就可以直接推过去，否则先设置一下加速域名，注意是加速类似files.gzpblog.com这个域名而不是主域名）。</p>\r\n<p>推送过去之后，我们到CDN的域名列表，点击“管理”，编辑“HTTPS安全加速”：<br><img src=\"https://www.goozp.com/uploads/2018/01/tohttps13.png\" alt=\"\"></p>\r\n<p>将这个开启，并且选择证书，注意不要选错选到www的证书去了。<br><img src=\"https://www.goozp.com/uploads/2018/01/tohttps14.png\" alt=\"\"></p>\r\n<p>配置完成后，这个域名就支持HTTPS了。到了这一步，基本上全站就支持HTTPS了，点进去基本都是小绿锁，可能你引入http链接的文章会没有。</p>\r\n<h1 id=\"h1-u6D4Bu8BD5u7ED3u679C\"><a name=\"测试结果\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>测试结果</h1><p>其实到目前为止，本站的HTTPS化并不完全，像什么IE6啊XP啊之类的老古董可能会不支持的。抱着与时俱进的心态，那些就先不考虑了，以后再做优化吧。来测试一下HTTPS的支持得如何，这是一个测试网站：<a href=\"https://www.ssllabs.com/ssltest/index.html\" title=\"SSL Server Test\">SSL Server Test</a></p>\r\n', '', 0, 'publish', 1, 0, '/article/38.html', '', 0, 89, '2017-03-04 18:24:47', '2017-03-04 18:24:47', '2018-01-09 09:05:22', NULL);
INSERT INTO `pt_post` VALUES (39, 10, 'article', 'Apache间歇性500服务器错误探究', '# 问题描述\r\n之前在搭建环境的时候出现了一个问题，搭建好了的LAMP环境，程序跑起来之后，总是会出现突然一下子500服务器错误，然后马上又好了的状况；就是间歇性Apache服务端500崩溃。\r\n\r\n# 排查错误\r\n首先我们可以排除的问题是程序出错，我跑的wordpress，一切是正常的，只是会突然出现这个情况，wordpress没有已知的这种bug，所以不会是程序问题。那么我们来看一下错误日志吧。\r\n\r\n查找Apache的Log记录，出现得最多的记录是：`PHP Fatal error: Out of memory (allocated 2097152) (tried to allocate 8192 bytes) in 。。。 on line 390`\r\n\r\n是内存不足导致的！我们来看一下这个服务器是不是连个网站都跑不起来了，这有点尴尬。首先我查看一下php.ini的内存配置：\r\n![](https://www.goozp.com/uploads/2018/01/Apache500_1.png)\r\n这个数字没问题，这样配是可以的。\r\n\r\n查看一下Apache的内存占用：\r\n![](https://www.goozp.com/uploads/2018/01/Apache500_2.png)\r\n单个的httpd进程竟然有200多M，因为之前并没有研究过Apache的内存占用问题，在我看来这有点夸张了，一个小PHP程序不应该这样。于是再仔细查看一下问题所在。\r\n\r\n使用top命令，然后shift+M命令看一下CPU和内存占用情况：\r\n![](https://www.goozp.com/uploads/2018/01/Apache500_3.png)\r\n最高的那个进程，占掉了26.8%，看来已经找到了原因，就是Apache占用内存太高了，我的服务器只有1G内存。查了一下资料:\r\n\r\nApache中，影响apache性能的几个重要参数有：\r\n> - KeepAlive　是否允许持续连接\r\n- MaxKeepAliveRequests　允许的持续连接的最大数\r\n- KeepAliveTimeout　持续连接在没有请求多少秒后切断\r\n- StartServers 最初启动时启动多少个服务器进程\r\n- MinSpareServers 空闲服务器进程的最小数\r\n- MaxSpareServers 空闲服务器进程的最大数\r\n- MaxClients 同时处理的请求数（最重要的参数，要少于ServerLimit)\r\n- MaxRequestsPerChild 每个子进程处理的最大请求数\r\n\r\n网上的资料都说锅在MaxRequestsPerChild这个配置上，于是我尝试了一下修改这项配置：\r\n```\r\n<IfModule mpm_prefork_module>\r\nMaxRequestsPerChild 0\r\n</IfModule>\r\n```\r\n改为\r\n```\r\n<IfModule mpm_prefork_module>\r\nMaxRequestsPerChild 500\r\n</IfModule>\r\n```\r\n重新启动Apache服务，来看一下：\r\n![](https://www.goozp.com/uploads/2018/01/Apache500_4.png)\r\n\r\n内存占用明显降低。但是过了一段时间之后我们再来看：\r\n![](https://www.goozp.com/uploads/2018/01/Apache500_5.png)\r\n\r\n**pache进程在使用内存时，是“渐长”的。也就是说，直到这个进程死掉，使用内存的数量是一直增长而不会减少的。**\r\n\r\n所以重点在于，**什么时候杀死堆积到一定内存占用的Apache进程？**\r\n\r\n在上一张图的的最大内存占用的进程由26%到30%多的时候。当我再次刷新页面时，报500错误了！这时候我就想，是不是最上面的那个进程，被杀掉了，然后报了500错误。看一下占用，果然，最大的那个没了，在下面产生了一个新的：\r\n![](https://www.goozp.com/uploads/2018/01/Apache500_6.png)\r\n所以，报500的原因其实是，进程突然被杀掉了！\r\n\r\n> **MaxRequestsPerChild 参数详解**\r\n这个参数是说，apache进程在处理了多少个请求之后，必须退出，重新开始，以免在处理中的内存问题。\r\n对于php脚本来说，把这个参数设置的小一些是有好处的，可以避免程序使用的内存持续增长对apache带来的压力：让这个参数定期释放内存，因为php是在脚本执行完毕后，自动释放只用的资源（内存）的。\r\n比如设置为50？如果太小的话，重新产生一个apache进程也是要消耗资源的，这是一个平衡问题。\r\n最好的设置方法是根据服务器内存情况设置一个合理的值。\r\n\r\n那这样来看的话，MaxRequestsPerChild参数其实越大越好（如果服务器够强），甚至是原先的0（不限制），这样就不会无端端被杀掉进程；而服务器内存比较低的情况下，设置一个比较低的值是可以防止总内存值溢出；最好的做法是根据服务器情况设置一个合理的值。\r\n\r\n很明显MaxRequestsPerChild并不是我们现在所需要的，那么这个问题该怎么解决呢？\r\n\r\n接下来发现了 KeepAliveTimeout 这个参数：\r\n> **KeepAliveTimeout** 这个参数决定了，在什么都不做之前，一个http进程能够等待多长时间？设想一下，如果keepalive设置为on，而 keepalivetimeout设置为一个比较大的数字，apache占用内存会很快的增长。这是因为，一个apache进程完成了一个任务（并达到了一定的内存占用，想一下“渐进”模式），并不会马上退出，而是等待一个keepalivetimeout时间。假设用户的链接请求持续不断的到来，则积累起来的无用的apache进程就会相当多，直到timeout，这些进程才会被杀死。\r\n但是，keepalive的确对于静态的文件，比如图像文件的传送是很有效的，因此，keepalive要设置为on，（off）但是keepalvietimeout要设置的小些。\r\n\r\n这似乎正是我们所要的。根据这个描述，我再次修改了一下配置文件，这次情况好多了，虽然有所改善，但是还是会存在500错误的问题。\r\n\r\n目前不知道是不是哪一步配置出了问题，还是服务器的内存的确太少，这个间歇性错误似乎无可避免，只能降低其频率。\r\n\r\n我最终的解决方案，其实很简单，换Nginx，看一下nginx的表现：\r\n![](https://www.goozp.com/uploads/2018/01/Apache500_7.png)\r\nphp-fpm监控php-cgi的方式，非常高效，占用内存非常的少，而且很稳定！突然明白了为什么Nginx越来越受欢迎了。\r\n', '<h1 id=\"h1-u95EEu9898u63CFu8FF0\"><a name=\"问题描述\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>问题描述</h1><p>之前在搭建环境的时候出现了一个问题，搭建好了的LAMP环境，程序跑起来之后，总是会出现突然一下子500服务器错误，然后马上又好了的状况；就是间歇性Apache服务端500崩溃。</p>\r\n<h1 id=\"h1-u6392u67E5u9519u8BEF\"><a name=\"排查错误\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>排查错误</h1><p>首先我们可以排除的问题是程序出错，我跑的wordpress，一切是正常的，只是会突然出现这个情况，wordpress没有已知的这种bug，所以不会是程序问题。那么我们来看一下错误日志吧。</p>\r\n<p>查找Apache的Log记录，出现得最多的记录是：<code>PHP Fatal error: Out of memory (allocated 2097152) (tried to allocate 8192 bytes) in 。。。 on line 390</code></p>\r\n<p>是内存不足导致的！我们来看一下这个服务器是不是连个网站都跑不起来了，这有点尴尬。首先我查看一下php.ini的内存配置：<br><img src=\"https://www.goozp.com/uploads/2018/01/Apache500_1.png\" alt=\"\"><br>这个数字没问题，这样配是可以的。</p>\r\n<p>查看一下Apache的内存占用：<br><img src=\"https://www.goozp.com/uploads/2018/01/Apache500_2.png\" alt=\"\"><br>单个的httpd进程竟然有200多M，因为之前并没有研究过Apache的内存占用问题，在我看来这有点夸张了，一个小PHP程序不应该这样。于是再仔细查看一下问题所在。</p>\r\n<p>使用top命令，然后shift+M命令看一下CPU和内存占用情况：<br><img src=\"https://www.goozp.com/uploads/2018/01/Apache500_3.png\" alt=\"\"><br>最高的那个进程，占掉了26.8%，看来已经找到了原因，就是Apache占用内存太高了，我的服务器只有1G内存。查了一下资料:</p>\r\n<p>Apache中，影响apache性能的几个重要参数有：</p>\r\n<blockquote>\r\n<ul>\r\n<li>KeepAlive　是否允许持续连接</li><li>MaxKeepAliveRequests　允许的持续连接的最大数</li><li>KeepAliveTimeout　持续连接在没有请求多少秒后切断</li><li>StartServers 最初启动时启动多少个服务器进程</li><li>MinSpareServers 空闲服务器进程的最小数</li><li>MaxSpareServers 空闲服务器进程的最大数</li><li>MaxClients 同时处理的请求数（最重要的参数，要少于ServerLimit)</li><li>MaxRequestsPerChild 每个子进程处理的最大请求数</li></ul>\r\n</blockquote>\r\n<p>网上的资料都说锅在MaxRequestsPerChild这个配置上，于是我尝试了一下修改这项配置：</p>\r\n<pre><code>&lt;IfModule mpm_prefork_module&gt;\r\nMaxRequestsPerChild 0\r\n&lt;/IfModule&gt;\r\n</code></pre><p>改为</p>\r\n<pre><code>&lt;IfModule mpm_prefork_module&gt;\r\nMaxRequestsPerChild 500\r\n&lt;/IfModule&gt;\r\n</code></pre><p>重新启动Apache服务，来看一下：<br><img src=\"https://www.goozp.com/uploads/2018/01/Apache500_4.png\" alt=\"\"></p>\r\n<p>内存占用明显降低。但是过了一段时间之后我们再来看：<br><img src=\"https://www.goozp.com/uploads/2018/01/Apache500_5.png\" alt=\"\"></p>\r\n<p><strong>pache进程在使用内存时，是“渐长”的。也就是说，直到这个进程死掉，使用内存的数量是一直增长而不会减少的。</strong></p>\r\n<p>所以重点在于，<strong>什么时候杀死堆积到一定内存占用的Apache进程？</strong></p>\r\n<p>在上一张图的的最大内存占用的进程由26%到30%多的时候。当我再次刷新页面时，报500错误了！这时候我就想，是不是最上面的那个进程，被杀掉了，然后报了500错误。看一下占用，果然，最大的那个没了，在下面产生了一个新的：<br><img src=\"https://www.goozp.com/uploads/2018/01/Apache500_6.png\" alt=\"\"><br>所以，报500的原因其实是，进程突然被杀掉了！</p>\r\n<blockquote>\r\n<p><strong>MaxRequestsPerChild 参数详解</strong><br>这个参数是说，apache进程在处理了多少个请求之后，必须退出，重新开始，以免在处理中的内存问题。<br>对于php脚本来说，把这个参数设置的小一些是有好处的，可以避免程序使用的内存持续增长对apache带来的压力：让这个参数定期释放内存，因为php是在脚本执行完毕后，自动释放只用的资源（内存）的。<br>比如设置为50？如果太小的话，重新产生一个apache进程也是要消耗资源的，这是一个平衡问题。<br>最好的设置方法是根据服务器内存情况设置一个合理的值。</p>\r\n</blockquote>\r\n<p>那这样来看的话，MaxRequestsPerChild参数其实越大越好（如果服务器够强），甚至是原先的0（不限制），这样就不会无端端被杀掉进程；而服务器内存比较低的情况下，设置一个比较低的值是可以防止总内存值溢出；最好的做法是根据服务器情况设置一个合理的值。</p>\r\n<p>很明显MaxRequestsPerChild并不是我们现在所需要的，那么这个问题该怎么解决呢？</p>\r\n<p>接下来发现了 KeepAliveTimeout 这个参数：</p>\r\n<blockquote>\r\n<p><strong>KeepAliveTimeout</strong> 这个参数决定了，在什么都不做之前，一个http进程能够等待多长时间？设想一下，如果keepalive设置为on，而 keepalivetimeout设置为一个比较大的数字，apache占用内存会很快的增长。这是因为，一个apache进程完成了一个任务（并达到了一定的内存占用，想一下“渐进”模式），并不会马上退出，而是等待一个keepalivetimeout时间。假设用户的链接请求持续不断的到来，则积累起来的无用的apache进程就会相当多，直到timeout，这些进程才会被杀死。<br>但是，keepalive的确对于静态的文件，比如图像文件的传送是很有效的，因此，keepalive要设置为on，（off）但是keepalvietimeout要设置的小些。</p>\r\n</blockquote>\r\n<p>这似乎正是我们所要的。根据这个描述，我再次修改了一下配置文件，这次情况好多了，虽然有所改善，但是还是会存在500错误的问题。</p>\r\n<p>目前不知道是不是哪一步配置出了问题，还是服务器的内存的确太少，这个间歇性错误似乎无可避免，只能降低其频率。</p>\r\n<p>我最终的解决方案，其实很简单，换Nginx，看一下nginx的表现：<br><img src=\"https://www.goozp.com/uploads/2018/01/Apache500_7.png\" alt=\"\"><br>php-fpm监控php-cgi的方式，非常高效，占用内存非常的少，而且很稳定！突然明白了为什么Nginx越来越受欢迎了。</p>\r\n', '', 0, 'publish', 1, 0, '/article/39.html', '', 0, 87, '2017-03-10 18:44:24', '2017-03-10 18:44:24', '2018-01-09 09:23:44', NULL);
INSERT INTO `pt_post` VALUES (40, 10, 'article', '升级到HTTP/2，性能大提升', '既然上了HTTPS，就肯定得上HTTP2了，HTTP2的速度上升了不止一个档次，让网站飞起来吧。\r\n\r\n# 如何升级到HTTP2\r\n升级到HTTP/2其实很简单，我们只需要注意这几点：\r\n- HTTP2现在需要HTTPS\r\n- HTTP2要求Nginx版本是1.9.5以上\r\n- openssl版本要求1.0.2\r\n\r\n然后，修改Nginx的配置：在`listen 443 ssl` 后面加上`http2 default_server`就行了\r\n\r\n理论上，这样就可以了。\r\n\r\n但是我配置之后通过浏览器请求头看到http的请求还是http1.1的，于是开启了我的HTTP2折腾之旅。\r\n\r\n------------\r\n\r\n> 注：以下为开启失败后的折腾\r\n\r\n# 什么是NPN和ALPN?\r\n通过测试发现ALPN没开启。NPN开启了，但是ALPN没开启。\r\n\r\nNPN，是一个 TLS 扩展，由 Google 在开发 SPDY 协议时提出。随着 SPDY 被 HTTP/2 取代，NPN 也被修订为 ALPN。NPN 是服务端发送所支持的 HTTP 协议列表，由客户端选择；而 ALPN 是客户端发送所支持的 HTTP 协议列表，由服务端选择；是否支持 NPN 或 ALPN 完全取决于使用的 OpenSSL 版本。在Chrome51之后必须ALPN访问http2。\r\n理论上没有支持ALPN，我们还是可以通过其它浏览器支持http2，但是我发现现在还是不行的。为了排除某些不知道的因素，还是先看一下怎么支持ALPN。\r\n\r\n# 是否支持ALPN\r\n执行命令：\r\n`openssl s_client -alpn h2 -servername www.gzpblog.com -connect www.gzpblog.com:443 < /dev/null | grep \'ALPN\'`\r\n显示：`No ALPN negotiated`\r\n显然不支持。查了资料发现需要开启OCSP Stapling。\r\n\r\n查看OCSP Stapling是否开启\r\n执行命令：`openssl s_client -connect www.gzpblog.com:443 -status -tlsextdebug < /dev/null 2>&1 | grep -i \"OCSP response\"`\r\n获得的信息是：OCSP response: no response sent\r\n就是 OCSP Stapling 还没开启。接下来开启，我们需要获取证书 OCSP Response。\r\n\r\n# 获取证书 OCSP Response\r\n这部分参考自取屈大神的一篇：[从无法开启 OCSP Stapling](https://imququ.com/post/why-can-not-turn-on-ocsp-stapling.html \"从无法开启 OCSP Stapling\") 说起，所以我们要做的就是准备好待验证网站证书链上的所有证书。证书链一般由根证书、一个或多个中间证书、站点证书组成。整理好这三个证书。\r\n\r\n## 获取根证书\r\n根证书因为SSL证书提供商的不同而不同，我的是Symantec的证书。\r\n可以直接通过google浏览器F12->Security->View certificate看到根证书：\r\n![](https://www.goozp.com/uploads/2018/01/http2_1_768x650.png)\r\n\r\n查到根证书是哪张了，可以通过火狐浏览器导出这张证书：\r\n![](https://www.goozp.com/uploads/2018/01/http2_2_1024x516.png)\r\n将导出的证书重命名为：root.pem\r\n\r\n## 获取中间证书和站点证书\r\n有两种情况吧：第一种如果你是通过阿里云等第三方帮你直接生成的证书，比如阿里云的免费证书，下载的证书中public.pem是站点证书，chain.pem是中间证书。第二种情况，就是不管怎么样，你就是找不到你的证书了，那，我们可以这样来弄：\r\n通过命令：`openssl s_client -connect www.gzpblog.com:443 -showcerts < /dev/null 2>&1`\r\n\r\n获取到的内容中 Certificate Chain 这一节，编号为 0 的证书是站点证书；编号为 1 的证书是中间证书。比如我的证书链一共是三级，服务端只需要发送两个证书；四级证书链服务端发送三个证书，根证书无需发送。\r\n将站点证书保存为 site.pem；中间证书保存为 intermediate.pem（如果有多个中间证书，按照子证书在上的顺序保存）\r\n验证一下每个证书的 Common Name：\r\n```\r\n# openssl x509 -in /usr/local/nginx/cert/site.pem -noout -subject\r\nsubject= /CN=www.gzpblog.com\r\n# openssl x509 -in /usr/local/nginx/cert/intermediate.pem -noout -subject\r\nsubject= /C=US/O=Symantec Corporation/OU=Symantec Trust Network/OU=Domain Validated SSL/CN=Symantec Basic DV SSL CA - G1\r\n# openssl x509 -in /usr/local/nginx/cert/root.pem -noout -subject\r\nsubject= /C=US/O=VeriSign, Inc./OU=VeriSign Trust Network/OU=(c) 2006 VeriSign, Inc. - For authorized use only/CN=VeriSign Class 3 Public Primary Certification Authority - G5\r\n```\r\n\r\n获取站点证书的 OCSP 服务地址：\r\n```\r\n# openssl x509 -in /usr/local/nginx/cert/site.pem -noout -ocsp_uri\r\nhttp://hc.symcd.com\r\n```\r\n\r\n使用以下命令获得站点证书的 OCSP Response：\r\n```\r\nopenssl ocsp -issuer /usr/local/nginx/cert/intermediate.pem -cert /usr/local/nginx/cert/site.pem -no_nonce -text -url http://hc.symcd.com\r\n```\r\n![](https://www.goozp.com/uploads/2018/01/http2_3_1024x96.png)\r\n可以看到site.pem:good；说明证书合法。出现一个Response Verify Failure，这是因为我们没有告诉 openssl应该信任哪些证书，openssl 无法验证 OCSP Response 内容而报的错。这个错误可以通过加上 -noverify 参数屏蔽，但更好的做法是通过 -CAfile 指定信任证书，我们可以这样做：\r\n将根证书、全部中间证书按照子证书在上的顺序，保存为 chain.pem。再次执行：\r\n```\r\nopenssl ocsp -CAfile /usr/local/nginx/cert/chain.pem -issuer /usr/local/nginx/cert/intermediate.pem -cert /usr/local/nginx/cert/site.pem -no_nonce -text -url http://hc.symcd.com\r\n```\r\n![](https://www.goozp.com/uploads/2018/01/http2_4.png)\r\nVerify OK！搞定了。\r\n\r\n## 配置Nginx\r\nNginx中加上配置：\r\n```\r\nssl_stapling               on;\r\nssl_stapling_verify        on;\r\nssl_trusted_certificate    /usr/local/nginx/cert/chain.pem;\r\n```\r\n重启Nginx\r\n再次使用以下命令查看OCSP Stapling是否开启\r\n```\r\nopenssl s_client -connect www.gzpblog.com:443 -status -tlsextdebug < /dev/null 2>&1 | grep -i \"OCSP response\"\r\n```\r\n这时可以看到;\r\n```\r\nOCSP response:\r\nOCSP Response Data:\r\nOCSP Response Status: successful (0x0)\r\nResponse Type: Basic OCSP Response\r\n```\r\n说明我们已经成功获取了OCSP Response，OSCP Stapling开启成功。\r\n\r\n> 如果出现：`verify error:num=20:unable to get local issuer certificate`\r\n以上的命令，chain.pem等证书部分我都加了路径，这主要是当时不是自己生成证书，openssl的工作路径什么的没有设置。所以我会报错verify error:num=20:unable to get local issuer certificate，这个错误没什么问题，你也可以在命令中加上你的证书： `-CAfile /usr/local/nginx/cert/chain.pem`\r\n\r\n# 重新编译Nginx\r\n按理来说，开启了nginx中的配置中的http2就能生效了。但是我的一直不生效，而且ALPN也没有开启。一直纠结在这里，因为我编译没有设定openssl路径，服务器装的openssl版本是1.1.0的；Nginx版本升级到了1.11.10；然后还是不行。\r\n\r\n最后我发现，问题在于，我虽然没有配置openssl源码路径编译nginx，但是我连–with-openssl都没写，这就导致直接不支持openssl了！犯浑了，于是乎我重新编译了nginx，而且指定了源码进行编译。\r\n\r\n惊讶的发现还是不行。最后发现了原因，是我操作linux系统时的失误，也让我学到一点：\r\n\r\n之前编译过的nginx，加了service的，通过：\r\n```\r\nservice nignx reload\r\n```\r\n重新启动，新版本不会生效，php-fpm一直监听老版本；然后我通过：\r\n```\r\n/usr/sbin/nginx stop\r\n```\r\n再\r\n```\r\n/usr/sbin/nginx\r\n```\r\n然后php-fpm才监听到新版本，之后service nignx reload 就正常了。这个机制我还不太理解是为什么，不过这样操作才可以。\r\n\r\n现在确定Nginx是正常的版本之后，重新查看是否支持ALPN，可以看到已经支持h2：\r\n![](https://www.goozp.com/uploads/2018/01/http2_5_1024x77.png)\r\n同时网站已经支持http2，确定一开始不行就是因为Nginx没编译好。通过浏览器的请求头我们已经可以看到HTTP/2.0的请求：\r\n![](https://www.goozp.com/uploads/2018/01/http2_6.png)\r\n\r\n同时再看一下google是否已经支持：\r\n可以通过HTTP/2 and SPDY indicator（科学上网获取）这个拓展插件方便查看是否已经启用http2，右上角蓝色闪电标志，说明已启用；或者直接打开`chrome://net-internals/#http2`查看：\r\n\r\n![](https://www.goozp.com/uploads/2018/01/http2_7.png)\r\n\r\n# 完成\r\nHTTP/2升级完毕。其实就是各软件版本要对得上，Nginx编译正确就可以。在完成HTTP/2的升级之后，发现在 SSL Labs 上的评分也由B变成了A+：\r\n![](https://www.goozp.com/uploads/2018/01/http2_8_300x126.png)', '<p>既然上了HTTPS，就肯定得上HTTP2了，HTTP2的速度上升了不止一个档次，让网站飞起来吧。</p>\r\n<h1 id=\"h1--http2\"><a name=\"如何升级到HTTP2\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>如何升级到HTTP2</h1><p>升级到HTTP/2其实很简单，我们只需要注意这几点：</p>\r\n<ul>\r\n<li>HTTP2现在需要HTTPS</li><li>HTTP2要求Nginx版本是1.9.5以上</li><li>openssl版本要求1.0.2</li></ul>\r\n<p>然后，修改Nginx的配置：在<code>listen 443 ssl</code> 后面加上<code>http2 default_server</code>就行了</p>\r\n<p>理论上，这样就可以了。</p>\r\n<p>但是我配置之后通过浏览器请求头看到http的请求还是http1.1的，于是开启了我的HTTP2折腾之旅。</p>\r\n<hr>\r\n<blockquote>\r\n<p>注：以下为开启失败后的折腾</p>\r\n</blockquote>\r\n<h1 id=\"h1--npn-alpn-\"><a name=\"什么是NPN和ALPN?\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>什么是NPN和ALPN?</h1><p>通过测试发现ALPN没开启。NPN开启了，但是ALPN没开启。</p>\r\n<p>NPN，是一个 TLS 扩展，由 Google 在开发 SPDY 协议时提出。随着 SPDY 被 HTTP/2 取代，NPN 也被修订为 ALPN。NPN 是服务端发送所支持的 HTTP 协议列表，由客户端选择；而 ALPN 是客户端发送所支持的 HTTP 协议列表，由服务端选择；是否支持 NPN 或 ALPN 完全取决于使用的 OpenSSL 版本。在Chrome51之后必须ALPN访问http2。<br>理论上没有支持ALPN，我们还是可以通过其它浏览器支持http2，但是我发现现在还是不行的。为了排除某些不知道的因素，还是先看一下怎么支持ALPN。</p>\r\n<h1 id=\"h1--alpn\"><a name=\"是否支持ALPN\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>是否支持ALPN</h1><p>执行命令：<br><code>openssl s_client -alpn h2 -servername www.gzpblog.com -connect www.gzpblog.com:443 &lt; /dev/null | grep &#39;ALPN&#39;</code><br>显示：<code>No ALPN negotiated</code><br>显然不支持。查了资料发现需要开启OCSP Stapling。</p>\r\n<p>查看OCSP Stapling是否开启<br>执行命令：<code>openssl s_client -connect www.gzpblog.com:443 -status -tlsextdebug &lt; /dev/null 2&gt;&amp;1 | grep -i &quot;OCSP response&quot;</code><br>获得的信息是：OCSP response: no response sent<br>就是 OCSP Stapling 还没开启。接下来开启，我们需要获取证书 OCSP Response。</p>\r\n<h1 id=\"h1--ocsp-response\"><a name=\"获取证书 OCSP Response\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>获取证书 OCSP Response</h1><p>这部分参考自取屈大神的一篇：<a href=\"https://imququ.com/post/why-can-not-turn-on-ocsp-stapling.html\" title=\"从无法开启 OCSP Stapling\">从无法开启 OCSP Stapling</a> 说起，所以我们要做的就是准备好待验证网站证书链上的所有证书。证书链一般由根证书、一个或多个中间证书、站点证书组成。整理好这三个证书。</p>\r\n<h2 id=\"h2-u83B7u53D6u6839u8BC1u4E66\"><a name=\"获取根证书\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>获取根证书</h2><p>根证书因为SSL证书提供商的不同而不同，我的是Symantec的证书。<br>可以直接通过google浏览器F12-&gt;Security-&gt;View certificate看到根证书：<br><img src=\"https://www.goozp.com/uploads/2018/01/http2_1_768x650.png\" alt=\"\"></p>\r\n<p>查到根证书是哪张了，可以通过火狐浏览器导出这张证书：<br><img src=\"https://www.goozp.com/uploads/2018/01/http2_2_1024x516.png\" alt=\"\"><br>将导出的证书重命名为：root.pem</p>\r\n<h2 id=\"h2-u83B7u53D6u4E2Du95F4u8BC1u4E66u548Cu7AD9u70B9u8BC1u4E66\"><a name=\"获取中间证书和站点证书\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>获取中间证书和站点证书</h2><p>有两种情况吧：第一种如果你是通过阿里云等第三方帮你直接生成的证书，比如阿里云的免费证书，下载的证书中public.pem是站点证书，chain.pem是中间证书。第二种情况，就是不管怎么样，你就是找不到你的证书了，那，我们可以这样来弄：<br>通过命令：<code>openssl s_client -connect www.gzpblog.com:443 -showcerts &lt; /dev/null 2&gt;&amp;1</code></p>\r\n<p>获取到的内容中 Certificate Chain 这一节，编号为 0 的证书是站点证书；编号为 1 的证书是中间证书。比如我的证书链一共是三级，服务端只需要发送两个证书；四级证书链服务端发送三个证书，根证书无需发送。<br>将站点证书保存为 site.pem；中间证书保存为 intermediate.pem（如果有多个中间证书，按照子证书在上的顺序保存）<br>验证一下每个证书的 Common Name：</p>\r\n<pre><code># openssl x509 -in /usr/local/nginx/cert/site.pem -noout -subject\r\nsubject= /CN=www.gzpblog.com\r\n# openssl x509 -in /usr/local/nginx/cert/intermediate.pem -noout -subject\r\nsubject= /C=US/O=Symantec Corporation/OU=Symantec Trust Network/OU=Domain Validated SSL/CN=Symantec Basic DV SSL CA - G1\r\n# openssl x509 -in /usr/local/nginx/cert/root.pem -noout -subject\r\nsubject= /C=US/O=VeriSign, Inc./OU=VeriSign Trust Network/OU=(c) 2006 VeriSign, Inc. - For authorized use only/CN=VeriSign Class 3 Public Primary Certification Authority - G5\r\n</code></pre><p>获取站点证书的 OCSP 服务地址：</p>\r\n<pre><code># openssl x509 -in /usr/local/nginx/cert/site.pem -noout -ocsp_uri\r\nhttp://hc.symcd.com\r\n</code></pre><p>使用以下命令获得站点证书的 OCSP Response：</p>\r\n<pre><code>openssl ocsp -issuer /usr/local/nginx/cert/intermediate.pem -cert /usr/local/nginx/cert/site.pem -no_nonce -text -url http://hc.symcd.com\r\n</code></pre><p><img src=\"https://www.goozp.com/uploads/2018/01/http2_3_1024x96.png\" alt=\"\"><br>可以看到site.pem:good；说明证书合法。出现一个Response Verify Failure，这是因为我们没有告诉 openssl应该信任哪些证书，openssl 无法验证 OCSP Response 内容而报的错。这个错误可以通过加上 -noverify 参数屏蔽，但更好的做法是通过 -CAfile 指定信任证书，我们可以这样做：<br>将根证书、全部中间证书按照子证书在上的顺序，保存为 chain.pem。再次执行：</p>\r\n<pre><code>openssl ocsp -CAfile /usr/local/nginx/cert/chain.pem -issuer /usr/local/nginx/cert/intermediate.pem -cert /usr/local/nginx/cert/site.pem -no_nonce -text -url http://hc.symcd.com\r\n</code></pre><p><img src=\"https://www.goozp.com/uploads/2018/01/http2_4.png\" alt=\"\"><br>Verify OK！搞定了。</p>\r\n<h2 id=\"h2--nginx\"><a name=\"配置Nginx\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>配置Nginx</h2><p>Nginx中加上配置：</p>\r\n<pre><code>ssl_stapling               on;\r\nssl_stapling_verify        on;\r\nssl_trusted_certificate    /usr/local/nginx/cert/chain.pem;\r\n</code></pre><p>重启Nginx<br>再次使用以下命令查看OCSP Stapling是否开启</p>\r\n<pre><code>openssl s_client -connect www.gzpblog.com:443 -status -tlsextdebug &lt; /dev/null 2&gt;&amp;1 | grep -i &quot;OCSP response&quot;\r\n</code></pre><p>这时可以看到;</p>\r\n<pre><code>OCSP response:\r\nOCSP Response Data:\r\nOCSP Response Status: successful (0x0)\r\nResponse Type: Basic OCSP Response\r\n</code></pre><p>说明我们已经成功获取了OCSP Response，OSCP Stapling开启成功。</p>\r\n<blockquote>\r\n<p>如果出现：<code>verify error:num=20:unable to get local issuer certificate</code><br>以上的命令，chain.pem等证书部分我都加了路径，这主要是当时不是自己生成证书，openssl的工作路径什么的没有设置。所以我会报错verify error:num=20:unable to get local issuer certificate，这个错误没什么问题，你也可以在命令中加上你的证书： <code>-CAfile /usr/local/nginx/cert/chain.pem</code></p>\r\n</blockquote>\r\n<h1 id=\"h1--nginx\"><a name=\"重新编译Nginx\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>重新编译Nginx</h1><p>按理来说，开启了nginx中的配置中的http2就能生效了。但是我的一直不生效，而且ALPN也没有开启。一直纠结在这里，因为我编译没有设定openssl路径，服务器装的openssl版本是1.1.0的；Nginx版本升级到了1.11.10；然后还是不行。</p>\r\n<p>最后我发现，问题在于，我虽然没有配置openssl源码路径编译nginx，但是我连–with-openssl都没写，这就导致直接不支持openssl了！犯浑了，于是乎我重新编译了nginx，而且指定了源码进行编译。</p>\r\n<p>惊讶的发现还是不行。最后发现了原因，是我操作linux系统时的失误，也让我学到一点：</p>\r\n<p>之前编译过的nginx，加了service的，通过：</p>\r\n<pre><code>service nignx reload\r\n</code></pre><p>重新启动，新版本不会生效，php-fpm一直监听老版本；然后我通过：</p>\r\n<pre><code>/usr/sbin/nginx stop\r\n</code></pre><p>再</p>\r\n<pre><code>/usr/sbin/nginx\r\n</code></pre><p>然后php-fpm才监听到新版本，之后service nignx reload 就正常了。这个机制我还不太理解是为什么，不过这样操作才可以。</p>\r\n<p>现在确定Nginx是正常的版本之后，重新查看是否支持ALPN，可以看到已经支持h2：<br><img src=\"https://www.goozp.com/uploads/2018/01/http2_5_1024x77.png\" alt=\"\"><br>同时网站已经支持http2，确定一开始不行就是因为Nginx没编译好。通过浏览器的请求头我们已经可以看到HTTP/2.0的请求：<br><img src=\"https://www.goozp.com/uploads/2018/01/http2_6.png\" alt=\"\"></p>\r\n<p>同时再看一下google是否已经支持：<br>可以通过HTTP/2 and SPDY indicator（科学上网获取）这个拓展插件方便查看是否已经启用http2，右上角蓝色闪电标志，说明已启用；或者直接打开<code>chrome://net-internals/#http2</code>查看：</p>\r\n<p><img src=\"https://www.goozp.com/uploads/2018/01/http2_7.png\" alt=\"\"></p>\r\n<h1 id=\"h1-u5B8Cu6210\"><a name=\"完成\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>完成</h1><p>HTTP/2升级完毕。其实就是各软件版本要对得上，Nginx编译正确就可以。在完成HTTP/2的升级之后，发现在 SSL Labs 上的评分也由B变成了A+：<br><img src=\"https://www.goozp.com/uploads/2018/01/http2_8_300x126.png\" alt=\"\"></p>\r\n', '', 0, 'publish', 1, 0, '/article/40.html', '', 0, 99, '2017-03-16 07:24:01', '2017-03-16 07:24:01', '2018-01-09 09:55:18', NULL);
INSERT INTO `pt_post` VALUES (41, 10, 'article', 'HTTPS进阶优化（一）', '# 前言\r\n又拍云有一篇文章 [突破这5个技术难点，HTTPS会好用到飞起来~](https://mp.weixin.qq.com/s/s-se0oeiuiF9UM7PiF-QCw \"突破这5个技术难点，HTTPS会好用到飞起来~\") ，总结的五个技术难点，HSTS、HTTP/2、OSCP stapling、Session ID、SNI技术。现在基本我都解决了。\r\n\r\n目前在 [ssllabs](https://www.ssllabs.com/ssltest/ \"ssllabs\") 上的评分：\r\n![](https://www.goozp.com/uploads/2018/01/http2_8_300x126.png)\r\nsslbals上的评分已经达到A+，不过还有一点东西需要处理。\r\n\r\n然而在HTTP Security Report上测出来，问题还很多：\r\n![](https://www.goozp.com/uploads/2018/01/https_youhua2_768x546.png)\r\n现在开始一块块地优化细节。\r\n\r\n# DNS CAA\r\nsslbals测试出来Server Key and Certificate这一块DNS CAA是NO。\r\n关于CAA的介绍这里有个链接[https://sslmate.com/labs/caa/](https://sslmate.com/labs/caa/ \"https://sslmate.com/labs/caa/\")；大概就是说CAA是一种DNS记录类型，可以让你控制哪些证书颁发机构可以为您的域颁发证书。这个应该是跟CA方的支持有关系的：\r\n![](https://www.goozp.com/uploads/2018/01/https_youhua3_768x584.png)\r\n我的证书CA是Symantec，从这里看确实是不支持，而且还是unknown policy。那这个可以不管了。\r\n\r\n# Session resumption\r\nsslbals测试出来Protocol Details这里，Session resumption (caching)是No (IDs assigned but not accepted)。\r\n这个是ssl_session配置的问题，主要是这两个配置：\r\n- ssl_session_cache 设置储存SSL会话的缓存类型和大小。\r\n默认值：ssl_session_cache off\r\noff为关闭，还有一些其它的缓存类型，不过这里建议使用shared共享缓存类型，这种方法更为有效。\r\n\r\n- ssl_session_timeout 客户端能够反复使用储存在缓存中的会话参数时间\r\n\r\n看了一下session这一部分我的配置：\r\n```\r\nssl_session_timeout 5m;\r\n```\r\n我把它改为：\r\n```\r\nssl_session_cache shared:SSL:50m;\r\nssl_session_timeout 1d;\r\n```\r\n共享缓存，缓存大小为50m，缓存时间1天。\r\n\r\n修改后这一项就没问题了。现在ssllabs上测试出来，该绿的都绿了。剩下一些SNI，比如XP系统下的IE6IE8什么的，可能无法支持ssl，不过我觉得这个可以忽略了。现在用xp的ie的估计不多了，然后用这玩意访问我的博客的，估计可以忽略了。\r\n\r\n# X-Frame-Options 响应头\r\nX-Frame-Options HTTP 响应头是用来给浏览器指示允许一个页面可否在 <frame>, <iframe> 或者 <object> 中展现的标记。网站可以使用此功能，来确保自己网站的内容没有被嵌到别人的网站中去，也从而避免了点击劫持 (clickjacking) 的攻击。\r\nX-Frame-Options 有三个值:\r\n\r\n- DENY\r\n表示该页面不允许在 frame 中展示，即便是在相同域名的页面中嵌套也不允许。\r\n\r\n- SAMEORIGIN\r\n表示该页面可以在相同域名页面的 frame 中展示。\r\n\r\n- ALLOW-FROM uri\r\n表示该页面可以在指定来源的 frame 中展示。\r\n就是说，如果设置为 DENY，不光在别人的网站 frame 嵌入时会无法加载，在同域名页面中同样会无法加载；如果设置为 SAMEORIGIN，那么页面就可以在同域名页面的 frame 中嵌套。我们只需要设置为 SAMEORIGIN 就好。\r\n\r\n## 配置 Apache\r\n配置 Apache 在所有页面上发送 X-Frame-Options 响应头，需要把下面这行添加到 ‘site’ 的配置中：`Header always append X-Frame-Options SAMEORIGIN`\r\n\r\n## 配置 nginx\r\n配置 nginx 发送 X-Frame-Options 响应头，把下面这行添加到 ‘http’, ‘server’ 或者 ‘location’ 的配置中：`add_header X-Frame-Options SAMEORIGIN;`\r\n\r\nCSP Level 2 规范中的 frame-ancestors 指令会替代这个非标准的 header。CSP 的 frame-ancestors 会在 Gecko 4.0 中支持，但是并不会被所有浏览器支持。然而 X-Frame-Options 是个已广泛支持的非官方标准，可以和 CSP 结合使用。\r\n\r\n# X-Content-Type-Options\r\nX-Content-Type-Options响应HTTP头是服务器用来指示MIME类型Content-type头部不能被改变的标记。这允许不参加MIME类型探查法，换句话说就是网站管理员知道他们在说什么。\r\nNginx中配置：\r\n```\r\nadd_header X-Content-Type-Options nosniff;\r\n```\r\n\r\n# Public Key Pins\r\n公钥固定（Public Key Pinning）是指一个证书链中必须包含一个白名单中的公钥，也就是说只有被列入白名单的证书签发机构（CA）才能为某个域名*.example.com签发证书，而不是你的浏览器中所存储的任何 CA 都可以为之签发。\r\n\r\n**从已知的密钥对（*.key）生成 pin-sha256**：\r\n```\r\nopenssl rsa -in /usr/local/nginx/cert/gzpblog.key -outform der -pubout | openssl dgst -sha256 -binary | openssl enc -base64\r\n```\r\n\r\n**从EC 私钥文件生成 pin-sha256**：\r\n```\r\nopenssl ec -in my-ecc-key-file.key -outform der -pubout | openssl dgst -sha256 -binary | openssl enc -base64\r\n```\r\n\r\n**从已知的证书申请文件（*.csr）生成 pin-sha256**：\r\n```\r\nopenssl req -in my-signing-request.csr -pubkey -noout | openssl rsa -pubin -outform der | openssl dgst -sha256 -binary | openssl enc -base64\r\n```\r\n\r\n**从已知的证书（*.crt）生成 pin-sha256**：\r\n```\r\nopenssl x509 -in my-certificate.crt -pubkey -noout | openssl rsa -pubin -outform der | openssl dgst -sha256 -binary | openssl enc -base64\r\n```\r\n\r\n**生成域名的 pin-sha256**：\r\n```\r\nopenssl s_client -servername www.gzpblog.com -connect www.gzpblog.com:443 | openssl x509 -pubkey -noout | openssl rsa -pubin -outform der | openssl dgst -sha256 -binary | openssl enc -base64\r\n```\r\n\r\n**nginx配置**：\r\n```\r\nadd_header Public-Key-Pins ‘pin-sha256=”第一个base64″; pin-sha256=”备用base64″; max-age=时长; includeSubDomains’;\r\n```\r\n\r\n# Server Banner\r\n服务器版本号不应该存在在响应头中。\r\nNginx增加以下配置\r\n```\r\nserver_tokens off;\r\n```\r\n就会去除版本号，比如nginx/1.10.3就变成了ningx\r\n\r\n# Web framework Information头部框架信息\r\n移除一些头部信息，比如X-Powered-By, X-Runtime, X-Version and X-AspNet-Version等。\r\n\r\nNginx中加配置：\r\n```\r\nproxy_hide_header X-Powered-By;\r\n```\r\nPHP移除版本号，php.ini中设置expose_php：\r\n```\r\nexpose_php = off\r\n```\r\n\r\n# 加入HSTS preload列表\r\n[HSTS preload预加载列表](https://hstspreload.org/ \"HSTS preload预加载列表\")，这个列表之前也提过了，需要科学上网才能访问。\r\n\r\n需要提交根域名：\r\n![](https://www.goozp.com/uploads/2018/01/https_youhua4.png)\r\n\r\n注意一下提交之后,所有的子域名都会生效：\r\n![](https://www.goozp.com/uploads/2018/01/https_youhua5.png)\r\n\r\n如果不符合要求会提示你，按提示修改就行；提交成功：\r\n![](https://www.goozp.com/uploads/2018/01/https_youhua6.png)\r\n\r\n# 优化完成\r\nHTTP Security Report上的评分：\r\n![](https://www.goozp.com/uploads/2018/01/https_youhua7_768x512.png)\r\n现在就差HSTS预加载列表生效了，这个一般不会那么快，我们需要等一断时间。其它的基本都搞定了。', '<h1 id=\"h1-u524Du8A00\"><a name=\"前言\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>前言</h1><p>又拍云有一篇文章 <a href=\"https://mp.weixin.qq.com/s/s-se0oeiuiF9UM7PiF-QCw\" title=\"突破这5个技术难点，HTTPS会好用到飞起来~\">突破这5个技术难点，HTTPS会好用到飞起来~</a> ，总结的五个技术难点，HSTS、HTTP/2、OSCP stapling、Session ID、SNI技术。现在基本我都解决了。</p>\r\n<p>目前在 <a href=\"https://www.ssllabs.com/ssltest/\" title=\"ssllabs\">ssllabs</a> 上的评分：<br><img src=\"https://www.goozp.com/uploads/2018/01/http2_8_300x126.png\" alt=\"\"><br>sslbals上的评分已经达到A+，不过还有一点东西需要处理。</p>\r\n<p>然而在HTTP Security Report上测出来，问题还很多：<br><img src=\"https://www.goozp.com/uploads/2018/01/https_youhua2_768x546.png\" alt=\"\"><br>现在开始一块块地优化细节。</p>\r\n<h1 id=\"h1-dns-caa\"><a name=\"DNS CAA\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>DNS CAA</h1><p>sslbals测试出来Server Key and Certificate这一块DNS CAA是NO。<br>关于CAA的介绍这里有个链接<a href=\"https://sslmate.com/labs/caa/\" title=\"https://sslmate.com/labs/caa/\">https://sslmate.com/labs/caa/</a>；大概就是说CAA是一种DNS记录类型，可以让你控制哪些证书颁发机构可以为您的域颁发证书。这个应该是跟CA方的支持有关系的：<br><img src=\"https://www.goozp.com/uploads/2018/01/https_youhua3_768x584.png\" alt=\"\"><br>我的证书CA是Symantec，从这里看确实是不支持，而且还是unknown policy。那这个可以不管了。</p>\r\n<h1 id=\"h1-session-resumption\"><a name=\"Session resumption\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Session resumption</h1><p>sslbals测试出来Protocol Details这里，Session resumption (caching)是No (IDs assigned but not accepted)。<br>这个是ssl_session配置的问题，主要是这两个配置：</p>\r\n<ul>\r\n<li><p>ssl_session_cache 设置储存SSL会话的缓存类型和大小。<br>默认值：ssl_session_cache off<br>off为关闭，还有一些其它的缓存类型，不过这里建议使用shared共享缓存类型，这种方法更为有效。</p>\r\n</li><li><p>ssl_session_timeout 客户端能够反复使用储存在缓存中的会话参数时间</p>\r\n</li></ul>\r\n<p>看了一下session这一部分我的配置：</p>\r\n<pre><code>ssl_session_timeout 5m;\r\n</code></pre><p>我把它改为：</p>\r\n<pre><code>ssl_session_cache shared:SSL:50m;\r\nssl_session_timeout 1d;\r\n</code></pre><p>共享缓存，缓存大小为50m，缓存时间1天。</p>\r\n<p>修改后这一项就没问题了。现在ssllabs上测试出来，该绿的都绿了。剩下一些SNI，比如XP系统下的IE6IE8什么的，可能无法支持ssl，不过我觉得这个可以忽略了。现在用xp的ie的估计不多了，然后用这玩意访问我的博客的，估计可以忽略了。</p>\r\n<h1 id=\"h1-x-frame-options-\"><a name=\"X-Frame-Options 响应头\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>X-Frame-Options 响应头</h1><p>X-Frame-Options HTTP 响应头是用来给浏览器指示允许一个页面可否在 &lt;frame&gt;, &lt;iframe&gt; 或者 &lt;object&gt; 中展现的标记。网站可以使用此功能，来确保自己网站的内容没有被嵌到别人的网站中去，也从而避免了点击劫持 (clickjacking) 的攻击。<br>X-Frame-Options 有三个值:</p>\r\n<ul>\r\n<li><p>DENY<br>表示该页面不允许在 frame 中展示，即便是在相同域名的页面中嵌套也不允许。</p>\r\n</li><li><p>SAMEORIGIN<br>表示该页面可以在相同域名页面的 frame 中展示。</p>\r\n</li><li><p>ALLOW-FROM uri<br>表示该页面可以在指定来源的 frame 中展示。<br>就是说，如果设置为 DENY，不光在别人的网站 frame 嵌入时会无法加载，在同域名页面中同样会无法加载；如果设置为 SAMEORIGIN，那么页面就可以在同域名页面的 frame 中嵌套。我们只需要设置为 SAMEORIGIN 就好。</p>\r\n</li></ul>\r\n<h2 id=\"h2--apache\"><a name=\"配置 Apache\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>配置 Apache</h2><p>配置 Apache 在所有页面上发送 X-Frame-Options 响应头，需要把下面这行添加到 ‘site’ 的配置中：<code>Header always append X-Frame-Options SAMEORIGIN</code></p>\r\n<h2 id=\"h2--nginx\"><a name=\"配置 nginx\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>配置 nginx</h2><p>配置 nginx 发送 X-Frame-Options 响应头，把下面这行添加到 ‘http’, ‘server’ 或者 ‘location’ 的配置中：<code>add_header X-Frame-Options SAMEORIGIN;</code></p>\r\n<p>CSP Level 2 规范中的 frame-ancestors 指令会替代这个非标准的 header。CSP 的 frame-ancestors 会在 Gecko 4.0 中支持，但是并不会被所有浏览器支持。然而 X-Frame-Options 是个已广泛支持的非官方标准，可以和 CSP 结合使用。</p>\r\n<h1 id=\"h1-x-content-type-options\"><a name=\"X-Content-Type-Options\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>X-Content-Type-Options</h1><p>X-Content-Type-Options响应HTTP头是服务器用来指示MIME类型Content-type头部不能被改变的标记。这允许不参加MIME类型探查法，换句话说就是网站管理员知道他们在说什么。<br>Nginx中配置：</p>\r\n<pre><code>add_header X-Content-Type-Options nosniff;\r\n</code></pre><h1 id=\"h1-public-key-pins\"><a name=\"Public Key Pins\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Public Key Pins</h1><p>公钥固定（Public Key Pinning）是指一个证书链中必须包含一个白名单中的公钥，也就是说只有被列入白名单的证书签发机构（CA）才能为某个域名*.example.com签发证书，而不是你的浏览器中所存储的任何 CA 都可以为之签发。</p>\r\n<p><strong>从已知的密钥对（*.key）生成 pin-sha256</strong>：</p>\r\n<pre><code>openssl rsa -in /usr/local/nginx/cert/gzpblog.key -outform der -pubout | openssl dgst -sha256 -binary | openssl enc -base64\r\n</code></pre><p><strong>从EC 私钥文件生成 pin-sha256</strong>：</p>\r\n<pre><code>openssl ec -in my-ecc-key-file.key -outform der -pubout | openssl dgst -sha256 -binary | openssl enc -base64\r\n</code></pre><p><strong>从已知的证书申请文件（*.csr）生成 pin-sha256</strong>：</p>\r\n<pre><code>openssl req -in my-signing-request.csr -pubkey -noout | openssl rsa -pubin -outform der | openssl dgst -sha256 -binary | openssl enc -base64\r\n</code></pre><p><strong>从已知的证书（*.crt）生成 pin-sha256</strong>：</p>\r\n<pre><code>openssl x509 -in my-certificate.crt -pubkey -noout | openssl rsa -pubin -outform der | openssl dgst -sha256 -binary | openssl enc -base64\r\n</code></pre><p><strong>生成域名的 pin-sha256</strong>：</p>\r\n<pre><code>openssl s_client -servername www.gzpblog.com -connect www.gzpblog.com:443 | openssl x509 -pubkey -noout | openssl rsa -pubin -outform der | openssl dgst -sha256 -binary | openssl enc -base64\r\n</code></pre><p><strong>nginx配置</strong>：</p>\r\n<pre><code>add_header Public-Key-Pins ‘pin-sha256=”第一个base64″; pin-sha256=”备用base64″; max-age=时长; includeSubDomains’;\r\n</code></pre><h1 id=\"h1-server-banner\"><a name=\"Server Banner\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Server Banner</h1><p>服务器版本号不应该存在在响应头中。<br>Nginx增加以下配置</p>\r\n<pre><code>server_tokens off;\r\n</code></pre><p>就会去除版本号，比如nginx/1.10.3就变成了ningx</p>\r\n<h1 id=\"h1-web-framework-information-\"><a name=\"Web framework Information头部框架信息\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Web framework Information头部框架信息</h1><p>移除一些头部信息，比如X-Powered-By, X-Runtime, X-Version and X-AspNet-Version等。</p>\r\n<p>Nginx中加配置：</p>\r\n<pre><code>proxy_hide_header X-Powered-By;\r\n</code></pre><p>PHP移除版本号，php.ini中设置expose_php：</p>\r\n<pre><code>expose_php = off\r\n</code></pre><h1 id=\"h1--hsts-preload-\"><a name=\"加入HSTS preload列表\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>加入HSTS preload列表</h1><p><a href=\"https://hstspreload.org/\" title=\"HSTS preload预加载列表\">HSTS preload预加载列表</a>，这个列表之前也提过了，需要科学上网才能访问。</p>\r\n<p>需要提交根域名：<br><img src=\"https://www.goozp.com/uploads/2018/01/https_youhua4.png\" alt=\"\"></p>\r\n<p>注意一下提交之后,所有的子域名都会生效：<br><img src=\"https://www.goozp.com/uploads/2018/01/https_youhua5.png\" alt=\"\"></p>\r\n<p>如果不符合要求会提示你，按提示修改就行；提交成功：<br><img src=\"https://www.goozp.com/uploads/2018/01/https_youhua6.png\" alt=\"\"></p>\r\n<h1 id=\"h1-u4F18u5316u5B8Cu6210\"><a name=\"优化完成\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>优化完成</h1><p>HTTP Security Report上的评分：<br><img src=\"https://www.goozp.com/uploads/2018/01/https_youhua7_768x512.png\" alt=\"\"><br>现在就差HSTS预加载列表生效了，这个一般不会那么快，我们需要等一断时间。其它的基本都搞定了。</p>\r\n', '', 0, 'publish', 1, 0, '/article/41.html', '', 0, 101, '2017-03-21 07:15:50', '2017-03-21 07:15:50', '2018-01-09 10:14:08', NULL);
INSERT INTO `pt_post` VALUES (42, 10, 'article', '阿里云Oss+Thinkphp5，Web一站式可拓展包', '最近接触阿里云的对象存储OSS有点多，不管是个人使用，还是公司使用，使用的频率还是很高的。为了方便下次要用时直接套进去，整了一个资源包：阿里云oss-php-sdk，plupload的web直传，JqueryUI样式等的合集，扔进了Thinkphp5里。\r\n\r\ngithub地址： [ZpGuo/aliyun-oss-for-thinkphp5](https://github.com/ZpGuo/aliyun-oss-for-thinkphp5 \"ZpGuo/aliyun-oss-for-thinkphp5\")\r\n\r\n**与阿里云官方SDK的区别**：\r\n- 样式升级；阿里云Oss-Web直传最佳实践（可回调）升级版，载入Plupload提供的JqueryUI样式。\r\n- 结合引入oss-php-sdk，可以直接拓展使用oss-php-sdk功能。\r\n- 修改config.php中的配置就可以使用。\r\n\r\n**版本说明**：\r\n- JQuery 版本1.12.4\r\n- JQuery UI版本1.12.1，主题Cupertino\r\n- Thinkphp 版本5.0.2\r\n- Plupload.js 版本2.1.X\r\n- 阿里云Oss官方SDK 版本2.2.2\r\n\r\n**预览**：\r\nweb直传的界面：\r\n![](https://www.goozp.com/uploads/2018/01/aliyun_tp5_look_like.png)\r\n\r\n**其它说明**：\r\n- 保留了引入拓展的后续升级的可能\r\n- 可以更换JqueryUI的样式主题，前往官网Jquery UI定制下载：[Jquery UI](http://jqueryui.com/download/ \"Jquery UI\")\r\n- 目前就是一个打包，功能不多，之后看看公司项目需求，完善一下功能，或者把Controller功能补完\r\n- 跨域时记得在阿里云OSS跨域设置中设置Cors规则\r\n\r\n**更多文档**：\r\n- Plupload官网：[Plupload: Multi-runtime File-Uploader](http://www.plupload.com/ \"Plupload: Multi-runtime File-Uploader\")\r\n- 阿里云Oss：[PHP-SDK](https://help.aliyun.com/document_detail/32099.html?spm=5176.product31815.6.744.SAFZWk \"PHP-SDK\")\r\n- 阿里云Oss最佳实践Web端直传：[服务端签名直传并设置上传回调](https://help.aliyun.com/document_detail/31927.html?spm=5176.doc32099.6.625.la8OMv \"服务端签名直传并设置上传回调\")\r\n', '<p>最近接触阿里云的对象存储OSS有点多，不管是个人使用，还是公司使用，使用的频率还是很高的。为了方便下次要用时直接套进去，整了一个资源包：阿里云oss-php-sdk，plupload的web直传，JqueryUI样式等的合集，扔进了Thinkphp5里。</p>\r\n<p>github地址： <a href=\"https://github.com/ZpGuo/aliyun-oss-for-thinkphp5\" title=\"ZpGuo/aliyun-oss-for-thinkphp5\">ZpGuo/aliyun-oss-for-thinkphp5</a></p>\r\n<p><strong>与阿里云官方SDK的区别</strong>：</p>\r\n<ul>\r\n<li>样式升级；阿里云Oss-Web直传最佳实践（可回调）升级版，载入Plupload提供的JqueryUI样式。</li><li>结合引入oss-php-sdk，可以直接拓展使用oss-php-sdk功能。</li><li>修改config.php中的配置就可以使用。</li></ul>\r\n<p><strong>版本说明</strong>：</p>\r\n<ul>\r\n<li>JQuery 版本1.12.4</li><li>JQuery UI版本1.12.1，主题Cupertino</li><li>Thinkphp 版本5.0.2</li><li>Plupload.js 版本2.1.X</li><li>阿里云Oss官方SDK 版本2.2.2</li></ul>\r\n<p><strong>预览</strong>：<br>web直传的界面：<br><img src=\"https://www.goozp.com/uploads/2018/01/aliyun_tp5_look_like.png\" alt=\"\"></p>\r\n<p><strong>其它说明</strong>：</p>\r\n<ul>\r\n<li>保留了引入拓展的后续升级的可能</li><li>可以更换JqueryUI的样式主题，前往官网Jquery UI定制下载：<a href=\"http://jqueryui.com/download/\" title=\"Jquery UI\">Jquery UI</a></li><li>目前就是一个打包，功能不多，之后看看公司项目需求，完善一下功能，或者把Controller功能补完</li><li>跨域时记得在阿里云OSS跨域设置中设置Cors规则</li></ul>\r\n<p><strong>更多文档</strong>：</p>\r\n<ul>\r\n<li>Plupload官网：<a href=\"http://www.plupload.com/\" title=\"Plupload: Multi-runtime File-Uploader\">Plupload: Multi-runtime File-Uploader</a></li><li>阿里云Oss：<a href=\"https://help.aliyun.com/document_detail/32099.html?spm=5176.product31815.6.744.SAFZWk\" title=\"PHP-SDK\">PHP-SDK</a></li><li>阿里云Oss最佳实践Web端直传：<a href=\"https://help.aliyun.com/document_detail/31927.html?spm=5176.doc32099.6.625.la8OMv\" title=\"服务端签名直传并设置上传回调\">服务端签名直传并设置上传回调</a></li></ul>\r\n', '', 0, 'publish', 1, 0, '/article/42.html', '', 0, 107, '2017-03-30 14:25:47', '2017-03-30 14:25:47', '2018-01-09 15:50:02', NULL);
INSERT INTO `pt_post` VALUES (43, 10, 'article', 'Git基础之从安装配置到开始工作', '从没有Git的环境中安装，配置，生成SSH等操作到可以开始工作，我们需要做这些就好。\r\n\r\n# 安装Git\r\n目前为止我的日常工作都是在windows下，安装：Git for windows\r\n官网下载很慢，安装比较无脑，这里就不多说了。\r\n\r\n# 修改用户信息\r\n```\r\n$ git config –global user.name “guo”\r\n$ git config –global user.email guo@example.com\r\n```\r\n![](https://www.goozp.com/uploads/2018/01/git_start1.png)\r\n（如果使用了 –global 选项，那么该命令只需要运行一次，因为之后无论你在该系统上做任何事情， Git 都会使用那些信息。 当你想针对特定项目使用不同的用户名称与邮件地址时，可以在那个项目目录下运行没有 –global 选项的命令来配置。）\r\n\r\n# 检查配置信息\r\n`git config –list`：列出所有 Git 当时能找到的配置\r\n\r\n`git config <key>`：来检查 Git 的某一项配置\r\n\r\n# 生成SSH Key\r\n## 查看是否已经有了SSH密钥\r\n```\r\ncd ~/.ssh\r\n```\r\n如果没有密钥则不会有此文件夹\r\n\r\n## 生成SSH密钥：\r\n```\r\n$ ssh-keygen -t rsa -C “abc@example.com”\r\n```\r\n![](https://www.goozp.com/uploads/2018/01/git_start2.png)\r\n\r\n## 执行查看公钥的命令\r\n```\r\ncat ~/.ssh/id_rsa.pub\r\n```\r\n获取到的那一大串密码就是公钥，在类似Github这样的线上代码托管工具的设置中（SSH），把这个公钥扔上去，就能往线上推代码了。\r\n\r\n\r\n# 获取Git仓库\r\n## 在现有目录中初始化仓库\r\n1. 进入项目目录\r\n2. 输入$ git init （初始化，该命令创建一个.git的子目录）\r\n3. 如果是已经有文件的文件夹中初始化，应该开始跟踪这些文件并提交，例：\r\n```\r\n$ git add *.c\r\n$ git add LICENSE\r\n$ git commit -m ‘initial project version’\r\n```\r\n\r\n## 克隆现有的仓库（获得一份已经存在了的 Git 仓库的拷贝）\r\n1.  克隆仓库的命令格式是 git clone [url]，执行 git clone 命令的时候，默认配置下远程 Git 仓库中的每一个文件的每一个版本都将被拉取下来。例如：`$ git clone https://github.com/libgit2/libgit2`\r\n2. 克隆后会在当前目录下创建一个名为”libgit2“的目录，并在这个目录下初始化一个 .git 文件夹，从远程仓库拉取下所有数据放入 .git 文件夹，然后从中读取最新版本的文件的拷贝。如果要自定义本地仓库名字：`$ git clone https://github.com/libgit2/libgit2 mylibgit`\r\n（Git 支持多种数据传输协议。 上面的例子使用的是 https:// 协议，不过你也可以使用 git:// 协议或者使用 SSH 传输协议，比如 `user@server:path/to/repo.git`。）\r\n\r\n\r\n', '<p>从没有Git的环境中安装，配置，生成SSH等操作到可以开始工作，我们需要做这些就好。</p>\r\n<h1 id=\"h1--git\"><a name=\"安装Git\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>安装Git</h1><p>目前为止我的日常工作都是在windows下，安装：Git for windows<br>官网下载很慢，安装比较无脑，这里就不多说了。</p>\r\n<h1 id=\"h1-u4FEEu6539u7528u6237u4FE1u606F\"><a name=\"修改用户信息\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>修改用户信息</h1><pre><code>$ git config –global user.name “guo”\r\n$ git config –global user.email guo@example.com\r\n</code></pre><p><img src=\"https://www.goozp.com/uploads/2018/01/git_start1.png\" alt=\"\"><br>（如果使用了 –global 选项，那么该命令只需要运行一次，因为之后无论你在该系统上做任何事情， Git 都会使用那些信息。 当你想针对特定项目使用不同的用户名称与邮件地址时，可以在那个项目目录下运行没有 –global 选项的命令来配置。）</p>\r\n<h1 id=\"h1-u68C0u67E5u914Du7F6Eu4FE1u606F\"><a name=\"检查配置信息\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>检查配置信息</h1><p><code>git config –list</code>：列出所有 Git 当时能找到的配置</p>\r\n<p><code>git config &lt;key&gt;</code>：来检查 Git 的某一项配置</p>\r\n<h1 id=\"h1--ssh-key\"><a name=\"生成SSH Key\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>生成SSH Key</h1><h2 id=\"h2--ssh-\"><a name=\"查看是否已经有了SSH密钥\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>查看是否已经有了SSH密钥</h2><pre><code>cd ~/.ssh\r\n</code></pre><p>如果没有密钥则不会有此文件夹</p>\r\n<h2 id=\"h2--ssh-\"><a name=\"生成SSH密钥：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>生成SSH密钥：</h2><pre><code>$ ssh-keygen -t rsa -C “abc@example.com”\r\n</code></pre><p><img src=\"https://www.goozp.com/uploads/2018/01/git_start2.png\" alt=\"\"></p>\r\n<h2 id=\"h2-u6267u884Cu67E5u770Bu516Cu94A5u7684u547Du4EE4\"><a name=\"执行查看公钥的命令\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>执行查看公钥的命令</h2><pre><code>cat ~/.ssh/id_rsa.pub\r\n</code></pre><p>获取到的那一大串密码就是公钥，在类似Github这样的线上代码托管工具的设置中（SSH），把这个公钥扔上去，就能往线上推代码了。</p>\r\n<h1 id=\"h1--git-\"><a name=\"获取Git仓库\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>获取Git仓库</h1><h2 id=\"h2-u5728u73B0u6709u76EEu5F55u4E2Du521Du59CBu5316u4ED3u5E93\"><a name=\"在现有目录中初始化仓库\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>在现有目录中初始化仓库</h2><ol>\r\n<li>进入项目目录</li><li>输入$ git init （初始化，该命令创建一个.git的子目录）</li><li>如果是已经有文件的文件夹中初始化，应该开始跟踪这些文件并提交，例：<pre><code>$ git add *.c\r\n$ git add LICENSE\r\n$ git commit -m ‘initial project version’\r\n</code></pre></li></ol>\r\n<h2 id=\"h2--git-\"><a name=\"克隆现有的仓库（获得一份已经存在了的 Git 仓库的拷贝）\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>克隆现有的仓库（获得一份已经存在了的 Git 仓库的拷贝）</h2><ol>\r\n<li>克隆仓库的命令格式是 git clone [url]，执行 git clone 命令的时候，默认配置下远程 Git 仓库中的每一个文件的每一个版本都将被拉取下来。例如：<code>$ git clone https://github.com/libgit2/libgit2</code></li><li>克隆后会在当前目录下创建一个名为”libgit2“的目录，并在这个目录下初始化一个 .git 文件夹，从远程仓库拉取下所有数据放入 .git 文件夹，然后从中读取最新版本的文件的拷贝。如果要自定义本地仓库名字：<code>$ git clone https://github.com/libgit2/libgit2 mylibgit</code><br>（Git 支持多种数据传输协议。 上面的例子使用的是 https:// 协议，不过你也可以使用 git:// 协议或者使用 SSH 传输协议，比如 <code>user<a href=\"https://github.com/server\" title=\"&#64;server\" class=\"at-link\">@server</a>:path/to/repo.git</code>。）</li></ol>\r\n', '', 0, 'publish', 1, 0, '/article/43.html', 'https://www.goozp.com/uploads/2018/01/git_square_logo.png', 0, 104, '2017-04-13 07:42:09', '2017-04-13 07:42:09', '2018-01-09 17:46:16', NULL);
INSERT INTO `pt_post` VALUES (44, 10, 'article', 'PHP实现定时任务的几种方式', '关于定时任务，之前以前认识了一种最常用的：crontab定时任务。通过linux的定时任务去实现。今天又认识了一下php实现定时方式的其它方式，总结一下。\r\n\r\n# 一 服务器定时任务\r\n服务器定时任务，其实就是unix系统下的crontab实现，具体的设置：[Linux定时任务crontab](https://www.goozp.com/article/24.html \"Linux定时任务crontab\")；不过除了直接定时读取php脚本的方式，我们还可以用定时调用接口的方式。\r\n\r\n## 运行脚本时\r\n`*/1 * * * * php /data/www/cron.php`  每分钟执行cron.php\r\n\r\n## URL方式调用\r\nlynx方式：`*/1 * * * *  lynx -dump http://www.gzpblog.com/cron.php`（-dump选项来把URL的输出转换来标准输出）\r\n\r\ncurl方式：`*/1 * * * *  /usr/bin/curl -o temp.txt http://www.gzpblog.com/cron.php`（Curl默认在标准输出显示输出。使用 “curl -o” 选项，把脚本的输出转储到临时文件temp.txt）\r\n\r\nwget方式：`*/1 * * * * /usr/bin/wget -q -O temp.txt http://www.gzpblog.com/cron.php`（q 选项表示安静模式。”-O temp.txt” 表示输出会发送到临时文件。）\r\n\r\n以上方式，是将php脚本放在可以用url访问的地址地中，比如`http://www.gzpblog.com/cron.php`，定时调用触发任务。\r\n\r\n# 二 ignore_user_abort()方式\r\nignore_user_abort() 函数设置与客户机断开是否会终止脚本的执行。\r\n\r\n先使用一个cron.php文件来控制脚本的终止，cron.php内容为：\r\n```php\r\n<?php\r\n	return 1;\r\n?>\r\n```\r\n脚本php文件为：\r\n```php\r\n<?php\r\nignore_user_abort();//关掉浏览器，PHP脚本也可以继续执行.\r\nset_time_limit(0);// 通过set_time_limit(0)可以让程序无限制的执行下去\r\n$interval=60*30;// 每隔半小时运行\r\ndo{\r\n$run = include \'config.php\';\r\nif(!$run) die(\'process abort\');  //return 0 时， 终止\r\n//TODO 该干啥干啥\r\nsleep($interval);// 等待5分钟\r\n}\r\nwhile(true);\r\n```\r\n通过改变cron.php的return 0 , 来实现停止程序。但是这种方法，不好内存管理。\r\n\r\n# 三 file_get_contents()方式\r\n```\r\n<?php\r\n$time=15;\r\n$url=\"http://\".$_SERVER[\'HTTP_HOST\'].$_SERVER[\'REQUEST_URI\'];\r\n\r\n//TODO\r\n\r\nsleep($time);\r\nfile_get_contents($url);\r\n?>\r\n```\r\nphp脚本sleep 一段时间之后通过访问自身的方式继续执行，这样就能保证每个PHP脚本执行时间不会太长，不受time_out的限制。因为每一次一次循环php文件都是独立执行，所以这种方法，避免了time_out的限制。 但是最好和上边一样 加上控制代码cron.php，以便能够终止进程。', '<p>关于定时任务，之前以前认识了一种最常用的：crontab定时任务。通过linux的定时任务去实现。今天又认识了一下php实现定时方式的其它方式，总结一下。</p>\r\n<h1 id=\"h1--\"><a name=\"一 服务器定时任务\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一 服务器定时任务</h1><p>服务器定时任务，其实就是unix系统下的crontab实现，具体的设置：<a href=\"https://www.goozp.com/article/24.html\" title=\"Linux定时任务crontab\">Linux定时任务crontab</a>；不过除了直接定时读取php脚本的方式，我们还可以用定时调用接口的方式。</p>\r\n<h2 id=\"h2-u8FD0u884Cu811Au672Cu65F6\"><a name=\"运行脚本时\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>运行脚本时</h2><p><code>*/1 * * * * php /data/www/cron.php</code>  每分钟执行cron.php</p>\r\n<h2 id=\"h2-url-\"><a name=\"URL方式调用\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>URL方式调用</h2><p>lynx方式：<code>*/1 * * * *  lynx -dump http://www.gzpblog.com/cron.php</code>（-dump选项来把URL的输出转换来标准输出）</p>\r\n<p>curl方式：<code>*/1 * * * *  /usr/bin/curl -o temp.txt http://www.gzpblog.com/cron.php</code>（Curl默认在标准输出显示输出。使用 “curl -o” 选项，把脚本的输出转储到临时文件temp.txt）</p>\r\n<p>wget方式：<code>*/1 * * * * /usr/bin/wget -q -O temp.txt http://www.gzpblog.com/cron.php</code>（q 选项表示安静模式。”-O temp.txt” 表示输出会发送到临时文件。）</p>\r\n<p>以上方式，是将php脚本放在可以用url访问的地址地中，比如<code>http://www.gzpblog.com/cron.php</code>，定时调用触发任务。</p>\r\n<h1 id=\"h1--ignore_user_abort-\"><a name=\"二 ignore_user_abort()方式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二 ignore_user_abort()方式</h1><p>ignore_user_abort() 函数设置与客户机断开是否会终止脚本的执行。</p>\r\n<p>先使用一个cron.php文件来控制脚本的终止，cron.php内容为：</p>\r\n<pre><code class=\"lang-php\">&lt;?php\r\n    return 1;\r\n?&gt;\r\n</code></pre>\r\n<p>脚本php文件为：</p>\r\n<pre><code class=\"lang-php\">&lt;?php\r\nignore_user_abort();//关掉浏览器，PHP脚本也可以继续执行.\r\nset_time_limit(0);// 通过set_time_limit(0)可以让程序无限制的执行下去\r\n$interval=60*30;// 每隔半小时运行\r\ndo{\r\n$run = include &#39;config.php&#39;;\r\nif(!$run) die(&#39;process abort&#39;);  //return 0 时， 终止\r\n//TODO 该干啥干啥\r\nsleep($interval);// 等待5分钟\r\n}\r\nwhile(true);\r\n</code></pre>\r\n<p>通过改变cron.php的return 0 , 来实现停止程序。但是这种方法，不好内存管理。</p>\r\n<h1 id=\"h1--file_get_contents-\"><a name=\"三 file_get_contents()方式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>三 file_get_contents()方式</h1><pre><code>&lt;?php\r\n$time=15;\r\n$url=&quot;http://&quot;.$_SERVER[&#39;HTTP_HOST&#39;].$_SERVER[&#39;REQUEST_URI&#39;];\r\n\r\n//TODO\r\n\r\nsleep($time);\r\nfile_get_contents($url);\r\n?&gt;\r\n</code></pre><p>php脚本sleep 一段时间之后通过访问自身的方式继续执行，这样就能保证每个PHP脚本执行时间不会太长，不受time_out的限制。因为每一次一次循环php文件都是独立执行，所以这种方法，避免了time_out的限制。 但是最好和上边一样 加上控制代码cron.php，以便能够终止进程。</p>\r\n', '', 0, 'publish', 1, 0, '/article/44.html', '', 0, 116, '2017-04-30 14:08:21', '2017-04-30 14:08:21', '2018-01-09 17:51:58', NULL);
INSERT INTO `pt_post` VALUES (45, 10, 'article', 'WordPress评论表单动态移动到回复评论下的效果', '最近折腾wordpress碰到一个问题，回复评论时，想让评论表单框动态显示到要回复的评论下，但是这个效果一直出不来。我看了其它的主题，没发现什么特别的地方。回复这里的代码看起来是对的：\r\n\r\n![](https://www.goozp.com/uploads/2018/01/wordpress_reply3.png)\r\n\r\n那问题是出在哪里呢？最后发现主要是这一段js效果，加上这段js就行：\r\n```javascript\r\nvar addComment={moveForm:function(a,b,c,d){var e,f=this,g=f.I(a),h=f.I(c),i=f.I(\"cancel-comment-reply-link\"),j=f.I(\"comment_parent\"),k=f.I(\"comment_post_ID\");if(g&&h&&i&&j){f.respondId=c,d=d||!1,f.I(\"wp-temp-form-div\")||(e=document.createElement(\"div\"),e.id=\"wp-temp-form-div\",e.style.display=\"none\",h.parentNode.insertBefore(e,h)),g.parentNode.insertBefore(h,g.nextSibling),$(\'body,html\').animate( { scrollTop: $(\'#respond\').offset().top - 150 }, 400);k&&d&&(k.value=d),j.value=b,i.style.display=\"\",i.onclick=function(){var a=addComment,b=a.I(\"wp-temp-form-div\"),c=a.I(a.respondId);if(b&&c)return a.I(\"comment_parent\").value=\"0\",b.parentNode.insertBefore(c,b),b.parentNode.removeChild(b),this.style.display=\"none\",this.onclick=null,!1};try{f.I(\"comment\").focus()}catch(l){}return!1}},I:function(a){return document.getElementById(a)}};\r\n```\r\n\r\n不过，这之中还是有一个坑要注意，就是表单的内容要完整，主要是这两个：\r\n```\r\n<?php comment_id_fields(); ?>\r\n```\r\n获取评论id，放在提交表单form标签里面，一般放在提交按钮后面。\r\n\r\n```\r\n<?php cancel_comment_reply_link(\'点击取消回复\') ?>\r\n```\r\n这个是取消回复按钮，也是必须要，没有了这个js也是没效果的。\r\n\r\n基本上，这样子，这个效果就出来了，大概是这样的：\r\n![](https://www.goozp.com/uploads/2018/01/wordpress_reply1.png)\r\n\r\n点击回复按钮：\r\n![](https://www.goozp.com/uploads/2018/01/wordpress_reply2.png)\r\n', '<p>最近折腾wordpress碰到一个问题，回复评论时，想让评论表单框动态显示到要回复的评论下，但是这个效果一直出不来。我看了其它的主题，没发现什么特别的地方。回复这里的代码看起来是对的：</p>\r\n<p><img src=\"https://www.goozp.com/uploads/2018/01/wordpress_reply3.png\" alt=\"\"></p>\r\n<p>那问题是出在哪里呢？最后发现主要是这一段js效果，加上这段js就行：</p>\r\n<pre><code class=\"lang-javascript\">var addComment={moveForm:function(a,b,c,d){var e,f=this,g=f.I(a),h=f.I(c),i=f.I(&quot;cancel-comment-reply-link&quot;),j=f.I(&quot;comment_parent&quot;),k=f.I(&quot;comment_post_ID&quot;);if(g&amp;&amp;h&amp;&amp;i&amp;&amp;j){f.respondId=c,d=d||!1,f.I(&quot;wp-temp-form-div&quot;)||(e=document.createElement(&quot;div&quot;),e.id=&quot;wp-temp-form-div&quot;,e.style.display=&quot;none&quot;,h.parentNode.insertBefore(e,h)),g.parentNode.insertBefore(h,g.nextSibling),$(&#39;body,html&#39;).animate( { scrollTop: $(&#39;#respond&#39;).offset().top - 150 }, 400);k&amp;&amp;d&amp;&amp;(k.value=d),j.value=b,i.style.display=&quot;&quot;,i.onclick=function(){var a=addComment,b=a.I(&quot;wp-temp-form-div&quot;),c=a.I(a.respondId);if(b&amp;&amp;c)return a.I(&quot;comment_parent&quot;).value=&quot;0&quot;,b.parentNode.insertBefore(c,b),b.parentNode.removeChild(b),this.style.display=&quot;none&quot;,this.onclick=null,!1};try{f.I(&quot;comment&quot;).focus()}catch(l){}return!1}},I:function(a){return document.getElementById(a)}};\r\n</code></pre>\r\n<p>不过，这之中还是有一个坑要注意，就是表单的内容要完整，主要是这两个：</p>\r\n<pre><code>&lt;?php comment_id_fields(); ?&gt;\r\n</code></pre><p>获取评论id，放在提交表单form标签里面，一般放在提交按钮后面。</p>\r\n<pre><code>&lt;?php cancel_comment_reply_link(&#39;点击取消回复&#39;) ?&gt;\r\n</code></pre><p>这个是取消回复按钮，也是必须要，没有了这个js也是没效果的。</p>\r\n<p>基本上，这样子，这个效果就出来了，大概是这样的：<br><img src=\"https://www.goozp.com/uploads/2018/01/wordpress_reply1.png\" alt=\"\"></p>\r\n<p>点击回复按钮：<br><img src=\"https://www.goozp.com/uploads/2018/01/wordpress_reply2.png\" alt=\"\"></p>\r\n', '', 0, 'publish', 1, 0, '/article/45.html', '', 0, 84, '2017-05-07 15:41:50', '2017-05-07 15:41:50', '2018-01-09 17:58:38', NULL);
INSERT INTO `pt_post` VALUES (46, 10, 'article', '用ab（ApacheBench）进行HTTP压力测试', '# 1. 什么是ab\r\nab（Apache HTTP server benchmarking tool）是Apache的HTTP服务器基准测试工具。ab命令会创建很多的并发访问线程，模拟多个访问者同时对某一URL地址进行访问。ab的测试目标是基于URL的，因此，既可以用来测试Apache的负载压力，也可以测试nginx、lighthttp、tomcat、IIS等其它Web服务器的压力。\r\n\r\n# 2. 基本使用\r\n不管是linux还是windows使用方法都差不多，简单粗暴，如下两条：\r\n1. 首先进入Apache的bin目录，然后命令行操作\r\n2. 命令行执行；例如：`ab -n 100 -c 100 http://127.0.0.1/`\r\n常用参数：“-n” 数值：总请求数。“-c” 数值：并发用户数。\r\n\r\n注：url必须在后方加上“/”，或指定相应文件，否则报错。更多参数查看ab工具文档: [http://httpd.apache.org/docs/](http://httpd.apache.org/docs/ \"http://httpd.apache.org/docs/\")\r\n\r\n# 3. 测试报告\r\n执行完命令后，如果测试完成，会有一些这样的信息：\r\n![](https://www.goozp.com/uploads/2018/01/ab%E6%B5%8B%E8%AF%95.png)\r\n\r\n大概的什么意思已经标明，在实际测试中会经常关注的指标有三个：\r\n- Requests per second\r\n平均每秒请求数，即**吞吐率**；指的是**某个并发用户数下单位时间内处理的请求数**。某个并发用户数下单位时间内能处理的最大请求数，称之为最大吞吐率。\r\n\r\n	计算公式：总请求数 / 处理完成这些请求数所花费的时间，即：\r\n	Request per second = Complete requests / Time taken for tests\r\n\r\n- Time per request\r\n每次并发请求平均耗时，即**用户平均请求等待时间**。\r\n\r\n	计算公式：处理完成所有请求数所花费的时间/ （总请求数 / 并发用户数），即：\r\n	Time per request = Time taken for tests /（ Complete requests / Concurrency Level）\r\n\r\n- Time per request（across all concurrent requests）\r\n平均每个请求的耗时，即**服务器平均请求等待时间**。\r\n\r\n	计算公式：处理完成所有请求数所花费的时间 / 总请求数，即：\r\n	Time per request（across all concurrent requests）= Time taken for tests / Complete requests\r\n可以看到，它是吞吐率的倒数；同时，它也=用户平均请求等待时间/并发用户数，即：Time per request / Concurrency Level\r\n\r\n# 4. 常见问题\r\n## 4.1 登录问题\r\n进行压力测试时URL需要登录时请求无法成功，怎么办？可以：\r\n1. 先用账户和密码登录\r\n2. 用开发者工具找到标识这个会话的Cookie值（Session ID）记下来\r\n3. 执行命令：\r\n一个Cookie情况时：`ab －n 100 －C key＝value http://test.com/`\r\n多个Cookie情况时，设置Header：`ab -n 100 -H “Cookie: Key1=Value1; Key2=Value2” http://test.com/`\r\n\r\n## 4.2 报错：“apr_pollset_poll:The timeout specified has expired (70007)”\r\n原因是响应超负荷了，从两个点解决：\r\n1. 一个是查看请求的url是否正常，还有是看看是否服务器已经扛不住这个测试；\r\n2. 加-k参数可以直接杀死卡住的进程以不报错\r\n', '<h1 id=\"h1-1-ab\"><a name=\"1. 什么是ab\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1. 什么是ab</h1><p>ab（Apache HTTP server benchmarking tool）是Apache的HTTP服务器基准测试工具。ab命令会创建很多的并发访问线程，模拟多个访问者同时对某一URL地址进行访问。ab的测试目标是基于URL的，因此，既可以用来测试Apache的负载压力，也可以测试nginx、lighthttp、tomcat、IIS等其它Web服务器的压力。</p>\r\n<h1 id=\"h1-2-\"><a name=\"2. 基本使用\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2. 基本使用</h1><p>不管是linux还是windows使用方法都差不多，简单粗暴，如下两条：</p>\r\n<ol>\r\n<li>首先进入Apache的bin目录，然后命令行操作</li><li>命令行执行；例如：<code>ab -n 100 -c 100 http://127.0.0.1/</code><br>常用参数：“-n” 数值：总请求数。“-c” 数值：并发用户数。</li></ol>\r\n<p>注：url必须在后方加上“/”，或指定相应文件，否则报错。更多参数查看ab工具文档: <a href=\"http://httpd.apache.org/docs/\" title=\"http://httpd.apache.org/docs/\">http://httpd.apache.org/docs/</a></p>\r\n<h1 id=\"h1-3-\"><a name=\"3. 测试报告\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3. 测试报告</h1><p>执行完命令后，如果测试完成，会有一些这样的信息：<br><img src=\"https://www.goozp.com/uploads/2018/01/ab%E6%B5%8B%E8%AF%95.png\" alt=\"\"></p>\r\n<p>大概的什么意思已经标明，在实际测试中会经常关注的指标有三个：</p>\r\n<ul>\r\n<li><p>Requests per second<br>平均每秒请求数，即<strong>吞吐率</strong>；指的是<strong>某个并发用户数下单位时间内处理的请求数</strong>。某个并发用户数下单位时间内能处理的最大请求数，称之为最大吞吐率。</p>\r\n<p>  计算公式：总请求数 / 处理完成这些请求数所花费的时间，即：<br>  Request per second = Complete requests / Time taken for tests</p>\r\n</li><li><p>Time per request<br>每次并发请求平均耗时，即<strong>用户平均请求等待时间</strong>。</p>\r\n<p>  计算公式：处理完成所有请求数所花费的时间/ （总请求数 / 并发用户数），即：<br>  Time per request = Time taken for tests /（ Complete requests / Concurrency Level）</p>\r\n</li><li><p>Time per request（across all concurrent requests）<br>平均每个请求的耗时，即<strong>服务器平均请求等待时间</strong>。</p>\r\n<p>  计算公式：处理完成所有请求数所花费的时间 / 总请求数，即：<br>  Time per request（across all concurrent requests）= Time taken for tests / Complete requests<br>可以看到，它是吞吐率的倒数；同时，它也=用户平均请求等待时间/并发用户数，即：Time per request / Concurrency Level</p>\r\n</li></ul>\r\n<h1 id=\"h1-4-\"><a name=\"4. 常见问题\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4. 常见问题</h1><h2 id=\"h2-4-1-\"><a name=\"4.1 登录问题\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.1 登录问题</h2><p>进行压力测试时URL需要登录时请求无法成功，怎么办？可以：</p>\r\n<ol>\r\n<li>先用账户和密码登录</li><li>用开发者工具找到标识这个会话的Cookie值（Session ID）记下来</li><li>执行命令：<br>一个Cookie情况时：<code>ab －n 100 －C key＝value http://test.com/</code><br>多个Cookie情况时，设置Header：<code>ab -n 100 -H “Cookie: Key1=Value1; Key2=Value2” http://test.com/</code></li></ol>\r\n<h2 id=\"h2-4-2-apr_pollset_poll-the-timeout-specified-has-expired-70007-\"><a name=\"4.2 报错：“apr_pollset_poll:The timeout specified has expired (70007)”\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.2 报错：“apr_pollset_poll:The timeout specified has expired (70007)”</h2><p>原因是响应超负荷了，从两个点解决：</p>\r\n<ol>\r\n<li>一个是查看请求的url是否正常，还有是看看是否服务器已经扛不住这个测试；</li><li>加-k参数可以直接杀死卡住的进程以不报错</li></ol>\r\n', '', 0, 'publish', 1, 0, '/article/46.html', 'https://www.goozp.com/uploads/2018/01/SupportApache_small.png', 0, 127, '2017-05-25 02:54:46', '2017-05-25 02:54:46', '2018-01-09 18:13:22', NULL);
INSERT INTO `pt_post` VALUES (47, 10, 'article', '扁平化风格WordPress主题SaltedFish', '最近终于把新的主题换上了，拖了很久，不过现在看来还挺满意，有一些问题需要处理一下，以及修改一下样式，不过问题不大。之前一直用的 [Jumping](https://www.goozp.com/article/35.html \"Jumping\")，在搞jumping时就想着越简洁越好，最后发现太简洁了，用着不趁手。\r\n\r\n之前太过于崇尚简洁，因为个人博客嘛，而且偏向于技术类的话，文章的展示是首要的，太花哨不好。 而之前制作的主题在使用中有一个很明显的问题，当有时候想要来查一篇曾经发表的笔记时，没有一个快速的入口，需要去把它翻出来，这个体验非常不好。 因为本人使用博客，与一些追求流量的自媒体不同，首先是为自己服务，比如记录笔记，分享技术，找到志同道合的道友等；也跟一些技术大牛的博客不同，技术大牛一般都是超节俭的风格里面满满都是干货。所以SaltedFish的理念，就是 首页的所见即所得，需要什么，快速找到，打通一切入口。于是乎，我在Jumping整体风格的基础上，在首页打通了一些专栏入口，工具入口，优化友链等。这样一来，比较方便我整理笔记，查找笔记，快速定位。\r\n\r\n现在整体看起来个人还比较满意，其实对于配色一直很纠结，不太懂色彩：\r\n![](https://www.goozp.com/uploads/2018/01/SaltedFish_1_768x589.png)\r\n\r\n![](https://www.goozp.com/uploads/2018/01/SaltedFish_2_768x615.png)\r\n\r\n同样的，**支持自适应**，移动端展示：\r\n![](https://www.goozp.com/uploads/2018/01/SaltedFish_3.png)\r\n\r\n稍微优化了一下后台设置的页面，好看一点点：\r\n![](https://www.goozp.com/uploads/2018/01/SaltedFish_4_768x426.png)\r\n\r\n这个主题还是采用bootstrap构建；支持自适应，适配移动端设备；去除了加载Google Fonts，emoji表情等以优化速度；优化了Wordpress默认输出的 head 加载等。内置了一些功能，比如：发送邮件（采用PHPMailer）；文章图片放大灯箱效果（采用了Highslide JS，版本5.0）。\r\n\r\nGithub地址：[ZpGuo/SaltedFish](https://github.com/ZpGuo/SaltedFish \"ZpGuo/SaltedFish\")\r\n\r\n ', '<p>最近终于把新的主题换上了，拖了很久，不过现在看来还挺满意，有一些问题需要处理一下，以及修改一下样式，不过问题不大。之前一直用的 <a href=\"https://www.goozp.com/article/35.html\" title=\"Jumping\">Jumping</a>，在搞jumping时就想着越简洁越好，最后发现太简洁了，用着不趁手。</p>\r\n<p>之前太过于崇尚简洁，因为个人博客嘛，而且偏向于技术类的话，文章的展示是首要的，太花哨不好。 而之前制作的主题在使用中有一个很明显的问题，当有时候想要来查一篇曾经发表的笔记时，没有一个快速的入口，需要去把它翻出来，这个体验非常不好。 因为本人使用博客，与一些追求流量的自媒体不同，首先是为自己服务，比如记录笔记，分享技术，找到志同道合的道友等；也跟一些技术大牛的博客不同，技术大牛一般都是超节俭的风格里面满满都是干货。所以SaltedFish的理念，就是 首页的所见即所得，需要什么，快速找到，打通一切入口。于是乎，我在Jumping整体风格的基础上，在首页打通了一些专栏入口，工具入口，优化友链等。这样一来，比较方便我整理笔记，查找笔记，快速定位。</p>\r\n<p>现在整体看起来个人还比较满意，其实对于配色一直很纠结，不太懂色彩：<br><img src=\"https://www.goozp.com/uploads/2018/01/SaltedFish_1_768x589.png\" alt=\"\"></p>\r\n<p><img src=\"https://www.goozp.com/uploads/2018/01/SaltedFish_2_768x615.png\" alt=\"\"></p>\r\n<p>同样的，<strong>支持自适应</strong>，移动端展示：<br><img src=\"https://www.goozp.com/uploads/2018/01/SaltedFish_3.png\" alt=\"\"></p>\r\n<p>稍微优化了一下后台设置的页面，好看一点点：<br><img src=\"https://www.goozp.com/uploads/2018/01/SaltedFish_4_768x426.png\" alt=\"\"></p>\r\n<p>这个主题还是采用bootstrap构建；支持自适应，适配移动端设备；去除了加载Google Fonts，emoji表情等以优化速度；优化了Wordpress默认输出的 head 加载等。内置了一些功能，比如：发送邮件（采用PHPMailer）；文章图片放大灯箱效果（采用了Highslide JS，版本5.0）。</p>\r\n<p>Github地址：<a href=\"https://github.com/ZpGuo/SaltedFish\" title=\"ZpGuo/SaltedFish\">ZpGuo/SaltedFish</a></p>\r\n', '', 0, 'publish', 1, 0, '/article/47.html', 'https://www.goozp.com/uploads/2018/01/timthumb.php.png', 0, 102, '2017-06-01 07:47:11', '2017-06-01 07:47:11', '2018-01-09 18:22:01', NULL);
INSERT INTO `pt_post` VALUES (48, 10, 'article', '使用Gitbook编写书籍文档', '# 一 GitBook介绍\r\nGitBook 是一个使用 Git 和 Markdown 来构建书籍的工具。它可以将你的书输出很多格式：PDF，ePub，mobi，或者输出为静态网页。\r\n\r\nGitBook工具链是开源并且完全免费的，它的源码可以在 GitHub 上获取。\r\n\r\n意思是 **GitBook其实就是一个命令行工具**。\r\n\r\n而 GitBook.com是一个 GitBook 的平台，有点类似于Github，而gitbook面向书籍。\r\n\r\n# 二 工作流程图\r\n简单地画了一个工作流程图：\r\n![](https://www.goozp.com/uploads/2018/01/Gitbook%E4%BD%BF%E7%94%A8%E6%B5%81%E7%A8%8B.png)\r\n不过这个图没有体现出多人合作，仅仅是个人工作。个人整体用下来，其实还是直接用gitbook editor最舒服，最方便，写文档还是方便为主。\r\n\r\n# 三 GitBook命令行工具的基本使用\r\n## 1. 安装gitbook和使用\r\n### 1）准备工作\r\n安装Gitbook需要安装Node.js，因为要用到npm。\r\n`node -v` 查看node的版本号\r\n`npm -v` 查看npm的版本号\r\n\r\n### 2）NPM安装gitbook cli\r\n`$ npm install gitbook-cli -g`\r\n\r\n### 3）初始化项目\r\n创建目录，切换到目录下，执行：`gitbook init`\r\n会自动创建 README.md 和 SUMMARY.md 这两个必须文件；README.md 是对书籍的简单介绍；SUMMARY.md 是书籍的目录结构。\r\n\r\n### 4） 预览电子书内容\r\n`gitbook build . ./output`\r\n根据 gitbook init 生成的 md 文件生成对应的 html 文件；output为要输出的目录，不写默认为电子书项目目录中创建一个名为“_book”的文件夹\r\n\r\n`gitbook serve`\r\n本地预览，浏览器打开`http://localhost:4000`进行预览；退出命令行结束预览\r\n\r\n### 5）常用命令\r\n```\r\ngitbook help //列出gitbook所有的命令\r\ngitbook –help //输出gitbook-cli的帮助信息\r\ngitbook build –gitbook=2.0.1 //生成时指定gitbook的版本, 本地没有会先下载\r\ngitbook ls //列出本地所有的gitbook版本\r\ngitbook ls-remote //列出远程可用的gitbook版本\r\ngitbook fetch 标签/版本号 //安装对应的gitbook版本\r\ngitbook update //更新到gitbook的最新版本\r\ngitbook uninstall 2.0.1 //卸载对应的gitbook版本\r\ngitbook build –log=debug //指定log的级别\r\ngitbook builid –debug //输出错误信息\r\n```\r\n\r\n# 四 gitbook.com平台的使用\r\n## 1. 注册Gitbook.com\r\n官网：[https://www.gitbook.com](https://www.gitbook.com \"https://www.gitbook.com\")\r\n\r\n## 2. 使用方式——远程仓库构建\r\n### 1）直接在gitbook.com上创建，撰写，发布等等\r\ngitbook官网国内打开速度有时候简直感人，不推荐在上面直接耍。\r\n- 创建普通的一些文档类型：\r\n![](https://www.goozp.com/uploads/2018/01/%E4%BD%BF%E7%94%A8gitbook.com1__768x478.png)\r\n其他操作，都很简单明了，这里不一一说了。\r\n\r\n### 2）使用Gitbook Editor\r\n类似于一个集成了Markdown编辑器的git管理软件；但是这个软件国内下载速度简直扎心。\r\n![](https://www.goozp.com/uploads/2018/01/%E4%BD%BF%E7%94%A8gitbook.com2__1024x514.png)\r\n\r\n登录后，会有gitbook远程的书籍数据，可以clone打本地进行编辑，然后保存推送等等操作。\r\n\r\ngitbook上还没创建的话会提示到gitbook.com上创建，本地创建的是本地书籍。\r\n![](https://www.goozp.com/uploads/2018/01/%E4%BD%BF%E7%94%A8gitbook.com3_.png)\r\n\r\n其它的操作也是所见即所得，比较简单明了。\r\n\r\n## 3. Gitbook + Github协同工作\r\n1. 先到Gitbook官网设置setting的Github部分；设置与Github帐号的关联，并添加github的gitbook支持。\r\n![](https://www.goozp.com/uploads/2018/01/%E4%BD%BF%E7%94%A8gitbook.com4__768x578.png)\r\n\r\n2. Github创建一个要用来关联的repository。\r\n\r\n3. 创建一个与github关联的书籍，左侧选择github，右侧选择一个github的项目（如果上一步integration设置好了就有了），填好信息Create。\r\n![](https://www.goozp.com/uploads/2018/01/%E4%BD%BF%E7%94%A8gitbook.com5_.png)\r\n\r\n4. 完成之后就创建了一个与github仓库关联的书籍，创建了关联的好处在于；可以像平时玩github一样在github来更新你的gitbook书籍，而同时也可以用gitbook/gitbook editor，git操纵gitbook来更新；两边会同步。\r\n\r\n# 五 使用Git更新书本\r\n通过 Git 命令行来推送内容更新你的书本\r\n## 1) GIT Url\r\ngit url的格式是：\r\nhttps://git.gitbook.com/{{UserName}}/{{Book}}.git\r\n（GitBook的git服务器暂时还不支持ssh协议）\r\n\r\n## 2） 在Git命令行创建一个新的仓库\r\n```\r\ntouch README.md SUMMARY.md\r\ngit init\r\ngit add README.md SUMMARY.md\r\ngit commit -m “first commit”\r\ngit remote add gitbook https://git.gitbook.com/{{UserName}}/{{Book}}.git\r\ngit push -u gitbook master\r\n```\r\n## 3. 推送一个已存在的仓库\r\n```\r\ngit remote add gitbook https://git.gitbook.com/{{UserName}}/{{Book}}.git\r\ngit push -u gitbook master\r\n```\r\n\r\n# 六 编写书籍\r\n剩下的就是好好写东西了。\r\n编写书籍的格式，markdown的语法，gitbook文件的格式等可以查看这个文档：[gitbook-documentation](https://chrisniael.gitbooks.io/gitbook-documentation/content/index.html \"gitbook-documentation\")\r\n\r\n\r\n\r\n', '<h1 id=\"h1--gitbook-\"><a name=\"一 GitBook介绍\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一 GitBook介绍</h1><p>GitBook 是一个使用 Git 和 Markdown 来构建书籍的工具。它可以将你的书输出很多格式：PDF，ePub，mobi，或者输出为静态网页。</p>\r\n<p>GitBook工具链是开源并且完全免费的，它的源码可以在 GitHub 上获取。</p>\r\n<p>意思是 <strong>GitBook其实就是一个命令行工具</strong>。</p>\r\n<p>而 GitBook.com是一个 GitBook 的平台，有点类似于Github，而gitbook面向书籍。</p>\r\n<h1 id=\"h1--\"><a name=\"二 工作流程图\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二 工作流程图</h1><p>简单地画了一个工作流程图：<br><img src=\"https://www.goozp.com/uploads/2018/01/Gitbook%E4%BD%BF%E7%94%A8%E6%B5%81%E7%A8%8B.png\" alt=\"\"><br>不过这个图没有体现出多人合作，仅仅是个人工作。个人整体用下来，其实还是直接用gitbook editor最舒服，最方便，写文档还是方便为主。</p>\r\n<h1 id=\"h1--gitbook-\"><a name=\"三 GitBook命令行工具的基本使用\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>三 GitBook命令行工具的基本使用</h1><h2 id=\"h2-1-gitbook-\"><a name=\"1. 安装gitbook和使用\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1. 安装gitbook和使用</h2><h3 id=\"h3-1-\"><a name=\"1）准备工作\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1）准备工作</h3><p>安装Gitbook需要安装Node.js，因为要用到npm。<br><code>node -v</code> 查看node的版本号<br><code>npm -v</code> 查看npm的版本号</p>\r\n<h3 id=\"h3-2-npm-gitbook-cli\"><a name=\"2）NPM安装gitbook cli\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2）NPM安装gitbook cli</h3><p><code>$ npm install gitbook-cli -g</code></p>\r\n<h3 id=\"h3-3-\"><a name=\"3）初始化项目\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3）初始化项目</h3><p>创建目录，切换到目录下，执行：<code>gitbook init</code><br>会自动创建 README.md 和 SUMMARY.md 这两个必须文件；README.md 是对书籍的简单介绍；SUMMARY.md 是书籍的目录结构。</p>\r\n<h3 id=\"h3-4-\"><a name=\"4） 预览电子书内容\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4） 预览电子书内容</h3><p><code>gitbook build . ./output</code><br>根据 gitbook init 生成的 md 文件生成对应的 html 文件；output为要输出的目录，不写默认为电子书项目目录中创建一个名为“_book”的文件夹</p>\r\n<p><code>gitbook serve</code><br>本地预览，浏览器打开<code>http://localhost:4000</code>进行预览；退出命令行结束预览</p>\r\n<h3 id=\"h3-5-\"><a name=\"5）常用命令\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5）常用命令</h3><pre><code>gitbook help //列出gitbook所有的命令\r\ngitbook –help //输出gitbook-cli的帮助信息\r\ngitbook build –gitbook=2.0.1 //生成时指定gitbook的版本, 本地没有会先下载\r\ngitbook ls //列出本地所有的gitbook版本\r\ngitbook ls-remote //列出远程可用的gitbook版本\r\ngitbook fetch 标签/版本号 //安装对应的gitbook版本\r\ngitbook update //更新到gitbook的最新版本\r\ngitbook uninstall 2.0.1 //卸载对应的gitbook版本\r\ngitbook build –log=debug //指定log的级别\r\ngitbook builid –debug //输出错误信息\r\n</code></pre><h1 id=\"h1--gitbook-com-\"><a name=\"四 gitbook.com平台的使用\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>四 gitbook.com平台的使用</h1><h2 id=\"h2-1-gitbook-com\"><a name=\"1. 注册Gitbook.com\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1. 注册Gitbook.com</h2><p>官网：<a href=\"https://www.gitbook.com\" title=\"https://www.gitbook.com\">https://www.gitbook.com</a></p>\r\n<h2 id=\"h2-2-\"><a name=\"2. 使用方式——远程仓库构建\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2. 使用方式——远程仓库构建</h2><h3 id=\"h3-1-gitbook-com-\"><a name=\"1）直接在gitbook.com上创建，撰写，发布等等\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1）直接在gitbook.com上创建，撰写，发布等等</h3><p>gitbook官网国内打开速度有时候简直感人，不推荐在上面直接耍。</p>\r\n<ul>\r\n<li>创建普通的一些文档类型：<br><img src=\"https://www.goozp.com/uploads/2018/01/%E4%BD%BF%E7%94%A8gitbook.com1__768x478.png\" alt=\"\"><br>其他操作，都很简单明了，这里不一一说了。</li></ul>\r\n<h3 id=\"h3-2-gitbook-editor\"><a name=\"2）使用Gitbook Editor\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2）使用Gitbook Editor</h3><p>类似于一个集成了Markdown编辑器的git管理软件；但是这个软件国内下载速度简直扎心。<br><img src=\"https://www.goozp.com/uploads/2018/01/%E4%BD%BF%E7%94%A8gitbook.com2__1024x514.png\" alt=\"\"></p>\r\n<p>登录后，会有gitbook远程的书籍数据，可以clone打本地进行编辑，然后保存推送等等操作。</p>\r\n<p>gitbook上还没创建的话会提示到gitbook.com上创建，本地创建的是本地书籍。<br><img src=\"https://www.goozp.com/uploads/2018/01/%E4%BD%BF%E7%94%A8gitbook.com3_.png\" alt=\"\"></p>\r\n<p>其它的操作也是所见即所得，比较简单明了。</p>\r\n<h2 id=\"h2-3-gitbook-github-\"><a name=\"3. Gitbook + Github协同工作\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3. Gitbook + Github协同工作</h2><ol>\r\n<li><p>先到Gitbook官网设置setting的Github部分；设置与Github帐号的关联，并添加github的gitbook支持。<br><img src=\"https://www.goozp.com/uploads/2018/01/%E4%BD%BF%E7%94%A8gitbook.com4__768x578.png\" alt=\"\"></p>\r\n</li><li><p>Github创建一个要用来关联的repository。</p>\r\n</li><li><p>创建一个与github关联的书籍，左侧选择github，右侧选择一个github的项目（如果上一步integration设置好了就有了），填好信息Create。<br><img src=\"https://www.goozp.com/uploads/2018/01/%E4%BD%BF%E7%94%A8gitbook.com5_.png\" alt=\"\"></p>\r\n</li><li><p>完成之后就创建了一个与github仓库关联的书籍，创建了关联的好处在于；可以像平时玩github一样在github来更新你的gitbook书籍，而同时也可以用gitbook/gitbook editor，git操纵gitbook来更新；两边会同步。</p>\r\n</li></ol>\r\n<h1 id=\"h1--git-\"><a name=\"五 使用Git更新书本\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>五 使用Git更新书本</h1><p>通过 Git 命令行来推送内容更新你的书本</p>\r\n<h2 id=\"h2-1-git-url\"><a name=\"1) GIT Url\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1) GIT Url</h2><p>git url的格式是：<br><a href=\"https://git.gitbook.com/{{UserName}}/{{Book}}.git\">https://git.gitbook.com/{{UserName}}/{{Book}}.git</a><br>（GitBook的git服务器暂时还不支持ssh协议）</p>\r\n<h2 id=\"h2-2-git-\"><a name=\"2） 在Git命令行创建一个新的仓库\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2） 在Git命令行创建一个新的仓库</h2><pre><code>touch README.md SUMMARY.md\r\ngit init\r\ngit add README.md SUMMARY.md\r\ngit commit -m “first commit”\r\ngit remote add gitbook https://git.gitbook.com/{{UserName}}/{{Book}}.git\r\ngit push -u gitbook master\r\n</code></pre><h2 id=\"h2-3-\"><a name=\"3. 推送一个已存在的仓库\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3. 推送一个已存在的仓库</h2><pre><code>git remote add gitbook https://git.gitbook.com/{{UserName}}/{{Book}}.git\r\ngit push -u gitbook master\r\n</code></pre><h1 id=\"h1--\"><a name=\"六 编写书籍\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>六 编写书籍</h1><p>剩下的就是好好写东西了。<br>编写书籍的格式，markdown的语法，gitbook文件的格式等可以查看这个文档：<a href=\"https://chrisniael.gitbooks.io/gitbook-documentation/content/index.html\" title=\"gitbook-documentation\">gitbook-documentation</a></p>\r\n', '', 0, 'publish', 1, 0, '/article/48.html', 'https://www.goozp.com/uploads/2018/01/gitbook.jpg', 0, 119, '2017-06-07 03:48:58', '2017-06-07 03:48:58', '2018-01-10 02:28:08', NULL);
INSERT INTO `pt_post` VALUES (49, 10, 'article', 'Docker第一步：认识Docker', '# 一 什么是Docker\r\n## 1. 什么是Docker？\r\nDocker是基于Go语言实现的开源容器项目。Docker的构想是要实现“Build,Ship and Run Any App, Anywhere”, 即通过对应用的封装（Packaging）、分发（Distribution）、部署（Deployment）、运行（Runtime）生命周期进行管理，达到应用组件“一次封装，到处运行”的目的。这里的应用组件，既可以是一个Web应用、一个编译环境，也可以是一套数据平台服务，甚至是一个操作系统或集群。\r\n\r\n# 二 为什么要使用Docker？\r\n## 1. Docker容器虚拟化的好处\r\n举例子，搭建一个LAMP环境：\r\n\r\n**传统的做法是**：\r\n1. 安装Apache，MySQL，PHP以及它们各自运行所依赖的环境；\r\n2. 对环境进行配置，包括创建用户，配置参数等；\r\n3. 进行功能测试，看看是否工作正常；如果不正常进行调试追踪\r\n4. ……\r\n\r\n应用越多，越难处理；一旦服务器进行迁移，就要重新部署；这些琐碎的工作极大地降低了工作效率。**究其根源，是这些应用直接运行在底层操作系统上，无法保证同一份应用在不同的环境中行为一致**。\r\n\r\n**使用Docker**：\r\n通过容器打包应用，解耦应用和运行平台。迁移的时候，**只需要在新的服务器上启动需要的容器就可以了，无论新旧服务器是否是同一类型的平台**。\r\n\r\n## 2. Docker在开发和运维中的优势\r\n在开发和运维中，具有如下几个方面的优势：\r\n- 更快速的交付和部署\r\n- 更高效的资源利用；Docker是内核级的虚拟化，可以实现更高的性能，同时对资源的额外需求很低。\r\n- 更轻松的迁移和拓展；Docker容器几乎可以在任意的平台上运行\r\n- 更简单的更新管理；使用Dockerfile。只需要小小的配置修改，就可以替代以往大量的更新工作。\r\n\r\n## 3. Docker与虚拟机\r\n与虚拟机比较，Docker的优势：\r\n- Docker容器很快，启动和停止可以在秒级实现\r\n- Docker容器对系统资源需求很少\r\n- Docker通过类似Git设计理念的操作来方便用户获取、分发和更新应用镜像，存储复用，增量更新。\r\n- Docker中的应用获得的是接近原生的运行性能\r\n\r\n# 三 核心概念\r\nDocker的大部分操作都围绕着它的三大核心概念——镜像、容器和仓库而展开\r\n## 1. Docker镜像\r\nDocker镜像类似于虚拟机镜像，可以将它理解为一个只读的模板。例如，一个镜像可以只包含一个基本的操作系统环境，里面仅安装了Apache，可以把它称为一个Apache镜像。\r\n\r\n## 2. Docker容器\r\nDocker容器类似于一个轻量级的沙箱，Docker利用容器来运行和隔离应用。容器是从镜像创建的应用运行实例。可以将其启动、开始、停止、删除，而这些容器都是彼此相互隔离、互不可见的。\r\n\r\n可以把容器看做事一个简易版的linux系统环境（包括root用户权限、进程空间、用户空间和网络空间等）以及运行在其中的应用程序打包而成的盒子。\r\n\r\n注：镜像自身是只读的。容器从镜像启动的时候，会在镜像的最上层创建一个可写层。\r\n\r\n## 3. Docker仓库\r\nDocker仓库类似于代码仓库，它是Docker集中存放镜像文件的场所。\r\n\r\nDocker仓库不是仓库注册服务器（Registry），仓库注册服务器是存放仓库的地方，其上往往存放着多个仓库。每个仓库集中存放某一类镜像，往往包括多个镜像文件，通过不同的标签（tag）来区分。\r\n\r\nDocker仓库分为空开仓库（Public）和私有仓库（Private）。目前最大的公开仓库是官方提供的Docker Hub，其中存放了数量庞大的镜像供用户下载。\r\n\r\n用户创建了自己的镜像之后就可以使用push命令将它上传到指定的公有或者私有仓库。这样用户下次再另一台机器上使用该镜像时，只需要从将其从仓库上pull下来就可以了。\r\n\r\n# 四 小结\r\n无论是系统管理员、应用开发人员、测试人员以及运维管理人员，都应该尽快掌握Docker，尽早享受其带来的巨大便利。\r\n\r\n# 五 相关链接\r\n- Docker官方主页： [https://www.docker.com](https://www.docker.com \"https://www.docker.com\")\r\n- Docker官方博客：[https://blog.docker.com](https://blog.docker.com \"https://blog.docker.com\")\r\n- Docker官方文档：[https://docs.docker.com](https://docs.docker.com \"https://docs.docker.com\")\r\n- Docker Hub：[https://hub.docker.com/](https://hub.docker.com/ \"https://hub.docker.com/\")\r\n- Dockerfile 参考：[https://docs.docker.com/engine/reference/builder/](https://docs.docker.com/engine/reference/builder/ \"https://docs.docker.com/engine/reference/builder/\")\r\n- Dockerfile 最佳实践：[https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/](https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/ \"https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/\")\r\n', '<h1 id=\"h1--docker\"><a name=\"一 什么是Docker\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一 什么是Docker</h1><h2 id=\"h2-1-docker-\"><a name=\"1. 什么是Docker？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1. 什么是Docker？</h2><p>Docker是基于Go语言实现的开源容器项目。Docker的构想是要实现“Build,Ship and Run Any App, Anywhere”, 即通过对应用的封装（Packaging）、分发（Distribution）、部署（Deployment）、运行（Runtime）生命周期进行管理，达到应用组件“一次封装，到处运行”的目的。这里的应用组件，既可以是一个Web应用、一个编译环境，也可以是一套数据平台服务，甚至是一个操作系统或集群。</p>\r\n<h1 id=\"h1--docker-\"><a name=\"二 为什么要使用Docker？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二 为什么要使用Docker？</h1><h2 id=\"h2-1-docker-\"><a name=\"1. Docker容器虚拟化的好处\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1. Docker容器虚拟化的好处</h2><p>举例子，搭建一个LAMP环境：</p>\r\n<p><strong>传统的做法是</strong>：</p>\r\n<ol>\r\n<li>安装Apache，MySQL，PHP以及它们各自运行所依赖的环境；</li><li>对环境进行配置，包括创建用户，配置参数等；</li><li>进行功能测试，看看是否工作正常；如果不正常进行调试追踪</li><li>……</li></ol>\r\n<p>应用越多，越难处理；一旦服务器进行迁移，就要重新部署；这些琐碎的工作极大地降低了工作效率。<strong>究其根源，是这些应用直接运行在底层操作系统上，无法保证同一份应用在不同的环境中行为一致</strong>。</p>\r\n<p><strong>使用Docker</strong>：<br>通过容器打包应用，解耦应用和运行平台。迁移的时候，<strong>只需要在新的服务器上启动需要的容器就可以了，无论新旧服务器是否是同一类型的平台</strong>。</p>\r\n<h2 id=\"h2-2-docker-\"><a name=\"2. Docker在开发和运维中的优势\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2. Docker在开发和运维中的优势</h2><p>在开发和运维中，具有如下几个方面的优势：</p>\r\n<ul>\r\n<li>更快速的交付和部署</li><li>更高效的资源利用；Docker是内核级的虚拟化，可以实现更高的性能，同时对资源的额外需求很低。</li><li>更轻松的迁移和拓展；Docker容器几乎可以在任意的平台上运行</li><li>更简单的更新管理；使用Dockerfile。只需要小小的配置修改，就可以替代以往大量的更新工作。</li></ul>\r\n<h2 id=\"h2-3-docker-\"><a name=\"3. Docker与虚拟机\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3. Docker与虚拟机</h2><p>与虚拟机比较，Docker的优势：</p>\r\n<ul>\r\n<li>Docker容器很快，启动和停止可以在秒级实现</li><li>Docker容器对系统资源需求很少</li><li>Docker通过类似Git设计理念的操作来方便用户获取、分发和更新应用镜像，存储复用，增量更新。</li><li>Docker中的应用获得的是接近原生的运行性能</li></ul>\r\n<h1 id=\"h1--\"><a name=\"三 核心概念\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>三 核心概念</h1><p>Docker的大部分操作都围绕着它的三大核心概念——镜像、容器和仓库而展开</p>\r\n<h2 id=\"h2-1-docker-\"><a name=\"1. Docker镜像\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1. Docker镜像</h2><p>Docker镜像类似于虚拟机镜像，可以将它理解为一个只读的模板。例如，一个镜像可以只包含一个基本的操作系统环境，里面仅安装了Apache，可以把它称为一个Apache镜像。</p>\r\n<h2 id=\"h2-2-docker-\"><a name=\"2. Docker容器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2. Docker容器</h2><p>Docker容器类似于一个轻量级的沙箱，Docker利用容器来运行和隔离应用。容器是从镜像创建的应用运行实例。可以将其启动、开始、停止、删除，而这些容器都是彼此相互隔离、互不可见的。</p>\r\n<p>可以把容器看做事一个简易版的linux系统环境（包括root用户权限、进程空间、用户空间和网络空间等）以及运行在其中的应用程序打包而成的盒子。</p>\r\n<p>注：镜像自身是只读的。容器从镜像启动的时候，会在镜像的最上层创建一个可写层。</p>\r\n<h2 id=\"h2-3-docker-\"><a name=\"3. Docker仓库\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3. Docker仓库</h2><p>Docker仓库类似于代码仓库，它是Docker集中存放镜像文件的场所。</p>\r\n<p>Docker仓库不是仓库注册服务器（Registry），仓库注册服务器是存放仓库的地方，其上往往存放着多个仓库。每个仓库集中存放某一类镜像，往往包括多个镜像文件，通过不同的标签（tag）来区分。</p>\r\n<p>Docker仓库分为空开仓库（Public）和私有仓库（Private）。目前最大的公开仓库是官方提供的Docker Hub，其中存放了数量庞大的镜像供用户下载。</p>\r\n<p>用户创建了自己的镜像之后就可以使用push命令将它上传到指定的公有或者私有仓库。这样用户下次再另一台机器上使用该镜像时，只需要从将其从仓库上pull下来就可以了。</p>\r\n<h1 id=\"h1--\"><a name=\"四 小结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>四 小结</h1><p>无论是系统管理员、应用开发人员、测试人员以及运维管理人员，都应该尽快掌握Docker，尽早享受其带来的巨大便利。</p>\r\n<h1 id=\"h1--\"><a name=\"五 相关链接\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>五 相关链接</h1><ul>\r\n<li>Docker官方主页： <a href=\"https://www.docker.com\" title=\"https://www.docker.com\">https://www.docker.com</a></li><li>Docker官方博客：<a href=\"https://blog.docker.com\" title=\"https://blog.docker.com\">https://blog.docker.com</a></li><li>Docker官方文档：<a href=\"https://docs.docker.com\" title=\"https://docs.docker.com\">https://docs.docker.com</a></li><li>Docker Hub：<a href=\"https://hub.docker.com/\" title=\"https://hub.docker.com/\">https://hub.docker.com/</a></li><li>Dockerfile 参考：<a href=\"https://docs.docker.com/engine/reference/builder/\" title=\"https://docs.docker.com/engine/reference/builder/\">https://docs.docker.com/engine/reference/builder/</a></li><li>Dockerfile 最佳实践：<a href=\"https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/\" title=\"https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/\">https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/</a></li></ul>\r\n', '', 0, 'publish', 1, 0, '/article/49.html', 'https://www.goozp.com/uploads/2018/01/docker_logo_square.png', 0, 108, '2017-06-12 14:22:28', '2017-06-12 14:22:28', '2018-02-10 19:14:57', NULL);
INSERT INTO `pt_post` VALUES (50, 10, 'article', 'PHPMailer：PHP的邮件发送类库', '# 1. 关于PHPMailer\r\nPHP用来操作发送邮件的类库。\r\n\r\nGithub地址：[https://github.com/PHPMailer/PHPMailer](https://github.com/PHPMailer/PHPMailer \"https://github.com/PHPMailer/PHPMailer\")\r\n\r\n# 2. 使用\r\n## 2.1下载\r\n首先下载类库包，直接Github下载或者通过composer都可以\r\n\r\n## 2.2 使用\r\n直接引入PHPMailerAutoload.php文件：\r\n```\r\nrequire \'/path/to/PHPMailerAutoload.php\';\r\n```\r\n然后实例化 PHPMailer() 类执行操作即可。\r\n\r\n## 2.3 使用示例\r\n官方简单示例:\r\n```php\r\n<?php\r\nrequire \'PHPMailerAutoload.php\';\r\n \r\n$mail = new PHPMailer;\r\n \r\n//$mail->SMTPDebug = 3;                               // 是否输出debug信息\r\n \r\n$mail->isSMTP();                                      // 设置mailer为SMTP模式\r\n$mail->Host = \'smtp1.example.com;smtp2.example.com\';  // SMTP服务器host\r\n$mail->SMTPAuth = true;                               // 启用SMTP身份验证\r\n$mail->Username = \'user@example.com\';                 // SMTP用户名\r\n$mail->Password = \'secret\';                           // SMTP密码\r\n$mail->SMTPSecure = \'tls\';                            // 是否使用 TLS 证书，支持\'ssl\'\r\n$mail->Port = 587;                                    // TCP连接端口\r\n \r\n$mail->setFrom(\'from@example.com\', \'Mailer\');         // 设置发件人地址\r\n$mail->addAddress(\'joe@example.net\', \'Joe User\');     // 添加收件人地址\r\n$mail->addAddress(\'ellen@example.com\');               // 添加收件人时名称是可选的\r\n$mail->addReplyTo(\'info@example.com\', \'Information\'); // 回复地址\r\n$mail->addCC(\'cc@example.com\');                       // 添加抄送地址\r\n$mail->addBCC(\'bcc@example.com\');                     // 添加密件抄送地址\r\n \r\n$mail->addAttachment(\'/var/tmp/file.tar.gz\');         // 添加附件\r\n$mail->addAttachment(\'/tmp/image.jpg\', \'new.jpg\');    // 添加带有名称的附件\r\n$mail->isHTML(true);                                  // 发送HTML格式的邮件\r\n \r\n$mail->Subject = \'Here is the subject\';               // 邮件标题\r\n$mail->Body    = \'This is the HTML message body <b>in bold!</b>\'; // 邮件主体内容\r\n$mail->AltBody = \'This is the body in plain text for non-HTML mail clients\'; //附加信息\r\n \r\n/* 执行发送邮件 */\r\nif(!$mail->send()) {\r\n	echo \'Message could not be sent.\';\r\n	echo \'Mailer Error: \' . $mail->ErrorInfo;\r\n} else {\r\n	echo \'Message has been sent\';\r\n}\r\n```\r\n\r\n# 3. 提取文件\r\n## 3.1 提取？\r\n在有些时候，我们只需要用到一个简单发送邮件功能来实现一些简单的功能，或者测试某些功能，我们可以进行一个瘦身操作；这步看个人其实可以忽略。\r\n\r\n## 3.2 操作\r\n我们可以提取出PHPmailer包中的class.phpmailer.php，class.pop3.php，class.smtp.php三个文件备用（实际使用smtp发送只引入了class.smtp）；\r\n\r\n同样直接引入class.phpmailer.php就可以使用发送邮件功能。\r\n\r\n## 3.3 简单示例\r\n```php\r\n<?php\r\nrequire  \'/path/to/class.phpmailer.php\';\r\ntry {\r\n	$mail = new PHPMailer(true);\r\n	$mail->IsSMTP();\r\n	$mail->CharSet=\'UTF-8\';\r\n	$mail->SMTPAuth = true;\r\n	$emailPort = \'\';\r\n	if ($emailPort == \'465\'){       // 如果使用ssl则加上\r\n		$mail->SMTPSecure = \'ssl\';\r\n	}\r\n	$mail->Port = $emailPort;\r\n	$mail->Host = \'\';               // 邮箱smtp地址\r\n	$mail->Username = \'\';           // 你的邮箱账号\r\n	$mail->Password = \'\';           // 你的邮箱密码\r\n	$mail->From = $mail->Username;  // 你的邮箱账号(发件人)\r\n	$mail->FromName = \'\';           // 发件人名称\r\n\r\n	$mail->AddAddress(\'\');          // 收件人\r\n	$mail->Subject = $subject;      // 标题\r\n	$mail->Body = $message;         // 邮件内容\r\n	$mail->WordWrap = 80;           // 设置长度\r\n	//$mail->AddAttachment(\"f:/test.png\"); //可以添加附件\r\n	$mail->IsHTML(true);                   //是否HTML格式\r\n	$mail->Send();                  //执行发送\r\n} catch (phpmailerException $e) {\r\n	// echo \"邮件发送失败：\".$e->errorMessage(); //测试的时候可以去掉此行的注释\r\n}\r\n```\r\n\r\n# 4. 提示\r\nPHPMailer偶尔会爆出安全性漏洞，最好保持PHPmailer时常更新，更新的安全版本状态。\r\n\r\n# 5. 可能的错误\r\n## 5.1 SMTP ERROR: Cound not connect to SMTP host.\r\n连接不到SMTP服务器，首先检查SMTP服务器是否可用，比如该邮箱提供商是否支持，如果支持看看smtp是否解析；再检查用来发送邮件的端口是否被占用；以及是否发送方式出错，例如使用了ssl方式却没有配置好环境。', '<h1 id=\"h1-1-phpmailer\"><a name=\"1. 关于PHPMailer\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1. 关于PHPMailer</h1><p>PHP用来操作发送邮件的类库。</p>\r\n<p>Github地址：<a href=\"https://github.com/PHPMailer/PHPMailer\" title=\"https://github.com/PHPMailer/PHPMailer\">https://github.com/PHPMailer/PHPMailer</a></p>\r\n<h1 id=\"h1-2-\"><a name=\"2. 使用\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2. 使用</h1><h2 id=\"h2-2-1-\"><a name=\"2.1下载\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.1下载</h2><p>首先下载类库包，直接Github下载或者通过composer都可以</p>\r\n<h2 id=\"h2-2-2-\"><a name=\"2.2 使用\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.2 使用</h2><p>直接引入PHPMailerAutoload.php文件：</p>\r\n<pre><code>require &#39;/path/to/PHPMailerAutoload.php&#39;;\r\n</code></pre><p>然后实例化 PHPMailer() 类执行操作即可。</p>\r\n<h2 id=\"h2-2-3-\"><a name=\"2.3 使用示例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.3 使用示例</h2><p>官方简单示例:</p>\r\n<pre><code class=\"lang-php\">&lt;?php\r\nrequire &#39;PHPMailerAutoload.php&#39;;\r\n\r\n$mail = new PHPMailer;\r\n\r\n//$mail-&gt;SMTPDebug = 3;                               // 是否输出debug信息\r\n\r\n$mail-&gt;isSMTP();                                      // 设置mailer为SMTP模式\r\n$mail-&gt;Host = &#39;smtp1.example.com;smtp2.example.com&#39;;  // SMTP服务器host\r\n$mail-&gt;SMTPAuth = true;                               // 启用SMTP身份验证\r\n$mail-&gt;Username = &#39;user@example.com&#39;;                 // SMTP用户名\r\n$mail-&gt;Password = &#39;secret&#39;;                           // SMTP密码\r\n$mail-&gt;SMTPSecure = &#39;tls&#39;;                            // 是否使用 TLS 证书，支持&#39;ssl&#39;\r\n$mail-&gt;Port = 587;                                    // TCP连接端口\r\n\r\n$mail-&gt;setFrom(&#39;from@example.com&#39;, &#39;Mailer&#39;);         // 设置发件人地址\r\n$mail-&gt;addAddress(&#39;joe@example.net&#39;, &#39;Joe User&#39;);     // 添加收件人地址\r\n$mail-&gt;addAddress(&#39;ellen@example.com&#39;);               // 添加收件人时名称是可选的\r\n$mail-&gt;addReplyTo(&#39;info@example.com&#39;, &#39;Information&#39;); // 回复地址\r\n$mail-&gt;addCC(&#39;cc@example.com&#39;);                       // 添加抄送地址\r\n$mail-&gt;addBCC(&#39;bcc@example.com&#39;);                     // 添加密件抄送地址\r\n\r\n$mail-&gt;addAttachment(&#39;/var/tmp/file.tar.gz&#39;);         // 添加附件\r\n$mail-&gt;addAttachment(&#39;/tmp/image.jpg&#39;, &#39;new.jpg&#39;);    // 添加带有名称的附件\r\n$mail-&gt;isHTML(true);                                  // 发送HTML格式的邮件\r\n\r\n$mail-&gt;Subject = &#39;Here is the subject&#39;;               // 邮件标题\r\n$mail-&gt;Body    = &#39;This is the HTML message body &lt;b&gt;in bold!&lt;/b&gt;&#39;; // 邮件主体内容\r\n$mail-&gt;AltBody = &#39;This is the body in plain text for non-HTML mail clients&#39;; //附加信息\r\n\r\n/* 执行发送邮件 */\r\nif(!$mail-&gt;send()) {\r\n    echo &#39;Message could not be sent.&#39;;\r\n    echo &#39;Mailer Error: &#39; . $mail-&gt;ErrorInfo;\r\n} else {\r\n    echo &#39;Message has been sent&#39;;\r\n}\r\n</code></pre>\r\n<h1 id=\"h1-3-\"><a name=\"3. 提取文件\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3. 提取文件</h1><h2 id=\"h2-3-1-\"><a name=\"3.1 提取？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.1 提取？</h2><p>在有些时候，我们只需要用到一个简单发送邮件功能来实现一些简单的功能，或者测试某些功能，我们可以进行一个瘦身操作；这步看个人其实可以忽略。</p>\r\n<h2 id=\"h2-3-2-\"><a name=\"3.2 操作\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.2 操作</h2><p>我们可以提取出PHPmailer包中的class.phpmailer.php，class.pop3.php，class.smtp.php三个文件备用（实际使用smtp发送只引入了class.smtp）；</p>\r\n<p>同样直接引入class.phpmailer.php就可以使用发送邮件功能。</p>\r\n<h2 id=\"h2-3-3-\"><a name=\"3.3 简单示例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.3 简单示例</h2><pre><code class=\"lang-php\">&lt;?php\r\nrequire  &#39;/path/to/class.phpmailer.php&#39;;\r\ntry {\r\n    $mail = new PHPMailer(true);\r\n    $mail-&gt;IsSMTP();\r\n    $mail-&gt;CharSet=&#39;UTF-8&#39;;\r\n    $mail-&gt;SMTPAuth = true;\r\n    $emailPort = &#39;&#39;;\r\n    if ($emailPort == &#39;465&#39;){       // 如果使用ssl则加上\r\n        $mail-&gt;SMTPSecure = &#39;ssl&#39;;\r\n    }\r\n    $mail-&gt;Port = $emailPort;\r\n    $mail-&gt;Host = &#39;&#39;;               // 邮箱smtp地址\r\n    $mail-&gt;Username = &#39;&#39;;           // 你的邮箱账号\r\n    $mail-&gt;Password = &#39;&#39;;           // 你的邮箱密码\r\n    $mail-&gt;From = $mail-&gt;Username;  // 你的邮箱账号(发件人)\r\n    $mail-&gt;FromName = &#39;&#39;;           // 发件人名称\r\n\r\n    $mail-&gt;AddAddress(&#39;&#39;);          // 收件人\r\n    $mail-&gt;Subject = $subject;      // 标题\r\n    $mail-&gt;Body = $message;         // 邮件内容\r\n    $mail-&gt;WordWrap = 80;           // 设置长度\r\n    //$mail-&gt;AddAttachment(&quot;f:/test.png&quot;); //可以添加附件\r\n    $mail-&gt;IsHTML(true);                   //是否HTML格式\r\n    $mail-&gt;Send();                  //执行发送\r\n} catch (phpmailerException $e) {\r\n    // echo &quot;邮件发送失败：&quot;.$e-&gt;errorMessage(); //测试的时候可以去掉此行的注释\r\n}\r\n</code></pre>\r\n<h1 id=\"h1-4-\"><a name=\"4. 提示\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4. 提示</h1><p>PHPMailer偶尔会爆出安全性漏洞，最好保持PHPmailer时常更新，更新的安全版本状态。</p>\r\n<h1 id=\"h1-5-\"><a name=\"5. 可能的错误\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5. 可能的错误</h1><h2 id=\"h2-5-1-smtp-error-cound-not-connect-to-smtp-host-\"><a name=\"5.1 SMTP ERROR: Cound not connect to SMTP host.\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.1 SMTP ERROR: Cound not connect to SMTP host.</h2><p>连接不到SMTP服务器，首先检查SMTP服务器是否可用，比如该邮箱提供商是否支持，如果支持看看smtp是否解析；再检查用来发送邮件的端口是否被占用；以及是否发送方式出错，例如使用了ssl方式却没有配置好环境。</p>\r\n', '', 0, 'publish', 1, 0, '/article/50.html', '', 0, 109, '2017-06-20 16:55:37', '2017-06-20 16:55:37', '2018-01-10 15:26:43', NULL);
INSERT INTO `pt_post` VALUES (51, 10, 'article', 'PHP QR Code：生成二维码', '# 1. 介绍\r\nPHP QR Code是一个开源的（LGPL）二维码生成库。\r\n\r\n官网及下载地址：[PHP QR Code](http://phpqrcode.sourceforge.net/ \"PHP QR Code\")\r\n\r\n# 2. 依赖\r\n环境需要开启GD2拓展\r\n\r\n# 3. 使用场景\r\n将内容生成二维码供扫码使用；例如微信支付，将支付信息生成的URL转为二维码，用户用过微信客户端扫码进行支付。\r\n\r\n# 4. 使用PHP QR Code\r\n## 4.1 官方示例\r\n可以创建生成二维码文件，或者直接将图片展示到浏览器上。\r\n```\r\nQRcode::png(\'code data text\', \'filename.png\'); // 创建文件\r\nQRcode::png(\'some othertext 1234\'); // 创建图片直接展示到浏览器上\r\n```\r\n\r\n## 4.2 关键方法png()\r\nphpqrcode.php 中的 png() 方法：\r\n```\r\npublic static function png($text, $outfile=false, $level=QR_ECLEVEL_L, $size=3, $margin=4, $saveandprint=false)\r\n```\r\n参数：\r\n- param $text 表示生成二位的的信息文本；\r\n- param $outfile 表示是否输出二维码图片 文件，默认否；\r\n- param $level 表示容错率，也就是有被覆盖的区域还能识别，默认是QR_ECLEVEL_L；可选参数为 L（QR_ECLEVEL_L，7%），M（QR_ECLEVEL_M，15%），Q（QR_ECLEVEL_Q，25%），H（QR_ECLEVEL_H，30%）；\r\n- param $size 表示生成图片大小，默认是3；\r\n- param $margin 表示二维码周围边框空白区域间距值；\r\n- param $saveandprint 表示是否保存二维码并显示。\r\n\r\n## 4.3 简单使用示例\r\n```\r\nrequire_once \'phpqrcode/phpqrcode.php\';\r\nQRcode::png(\"https://www.goozp.com\");\r\n```\r\n\r\n这里就生成了一张内容是 `”https://www.goozp.com”` 的二维码\r\n\r\n# 5. 可能遇到的问题\r\n## 5.1 生成二维码时失败，显示的是乱码\r\n生成了这样的东西：\r\n![](https://www.goozp.com/uploads/2018/01/qrcode_error.png)\r\n可能说在后面输出了东西；解决方法在和面加上`exit()`：\r\n```\r\nQRcode::png($url);\r\nexit();\r\n```\r\n', '<h1 id=\"h1-1-\"><a name=\"1. 介绍\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1. 介绍</h1><p>PHP QR Code是一个开源的（LGPL）二维码生成库。</p>\r\n<p>官网及下载地址：<a href=\"http://phpqrcode.sourceforge.net/\" title=\"PHP QR Code\">PHP QR Code</a></p>\r\n<h1 id=\"h1-2-\"><a name=\"2. 依赖\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2. 依赖</h1><p>环境需要开启GD2拓展</p>\r\n<h1 id=\"h1-3-\"><a name=\"3. 使用场景\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3. 使用场景</h1><p>将内容生成二维码供扫码使用；例如微信支付，将支付信息生成的URL转为二维码，用户用过微信客户端扫码进行支付。</p>\r\n<h1 id=\"h1-4-php-qr-code\"><a name=\"4. 使用PHP QR Code\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4. 使用PHP QR Code</h1><h2 id=\"h2-4-1-\"><a name=\"4.1 官方示例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.1 官方示例</h2><p>可以创建生成二维码文件，或者直接将图片展示到浏览器上。</p>\r\n<pre><code>QRcode::png(&#39;code data text&#39;, &#39;filename.png&#39;); // 创建文件\r\nQRcode::png(&#39;some othertext 1234&#39;); // 创建图片直接展示到浏览器上\r\n</code></pre><h2 id=\"h2-4-2-png-\"><a name=\"4.2 关键方法png()\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.2 关键方法png()</h2><p>phpqrcode.php 中的 png() 方法：</p>\r\n<pre><code>public static function png($text, $outfile=false, $level=QR_ECLEVEL_L, $size=3, $margin=4, $saveandprint=false)\r\n</code></pre><p>参数：</p>\r\n<ul>\r\n<li>param $text 表示生成二位的的信息文本；</li><li>param $outfile 表示是否输出二维码图片 文件，默认否；</li><li>param $level 表示容错率，也就是有被覆盖的区域还能识别，默认是QR_ECLEVEL_L；可选参数为 L（QR_ECLEVEL_L，7%），M（QR_ECLEVEL_M，15%），Q（QR_ECLEVEL_Q，25%），H（QR_ECLEVEL_H，30%）；</li><li>param $size 表示生成图片大小，默认是3；</li><li>param $margin 表示二维码周围边框空白区域间距值；</li><li>param $saveandprint 表示是否保存二维码并显示。</li></ul>\r\n<h2 id=\"h2-4-3-\"><a name=\"4.3 简单使用示例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.3 简单使用示例</h2><pre><code>require_once &#39;phpqrcode/phpqrcode.php&#39;;\r\nQRcode::png(&quot;https://www.goozp.com&quot;);\r\n</code></pre><p>这里就生成了一张内容是 <code>”https://www.goozp.com”</code> 的二维码</p>\r\n<h1 id=\"h1-5-\"><a name=\"5. 可能遇到的问题\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5. 可能遇到的问题</h1><h2 id=\"h2-5-1-\"><a name=\"5.1 生成二维码时失败，显示的是乱码\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.1 生成二维码时失败，显示的是乱码</h2><p>生成了这样的东西：<br><img src=\"https://www.goozp.com/uploads/2018/01/qrcode_error.png\" alt=\"\"><br>可能说在后面输出了东西；解决方法在和面加上<code>exit()</code>：</p>\r\n<pre><code>QRcode::png($url);\r\nexit();\r\n</code></pre>', '', 0, 'publish', 1, 0, '/article/51.html', '', 0, 105, '2017-06-21 03:36:10', '2017-06-21 03:36:10', '2018-01-10 15:34:37', NULL);
INSERT INTO `pt_post` VALUES (52, 10, 'article', 'QRCode.js：基于JQuery的生成二维码JS库', '# 1. QRCode.js\r\nQRCode.js是一个二维码生成javascript库；支持跨浏览器的HTML5 Canvas和表格标签的DOM操作；并且不依赖其它的库或拓展。\r\n\r\n主页：[QRCode.js](http://davidshimjs.github.io/qrcodejs/ \"QRCode.js\")\r\n\r\nGithub：[davidshimjs/qrcodejs](https://github.com/davidshimjs/qrcodejs \"davidshimjs/qrcodejs\")\r\n\r\n# 2. 用法\r\n## 2.1 基础用法\r\n```\r\n<div id=\"qrcode\"></div>\r\n<script type=\"text/javascript\">\r\nnew QRCode(document.getElementById(\"qrcode\"), \"https://www.gzpblog.com\");\r\n</script>\r\n```\r\n\r\n## 2.2 传参用法\r\n```\r\n<div id=\"qrcode\"></div>\r\n<script type=\"text/javascript\">\r\nvar qrcode = new QRCode(document.getElementById(\"qrcode\"), {\r\n    text: \"https://www.gzpblog.com\",\r\n    width: 128,\r\n    height: 128,\r\n    colorDark : \"#000000\",\r\n    colorLight : \"#ffffff\",\r\n    correctLevel : QRCode.CorrectLevel.H\r\n});\r\n</script>\r\n```\r\n\r\n## 2.3 调用函数\r\n```\r\nqrcode.clear(); // 清除二维码\r\nqrcode.makeCode(\"https://www.gzpblog.com\"); // 创建一个新的二维码\r\n```\r\n\r\n# 3. 适用范围\r\n之前用 PHP QR Code 来生成二维码，发现通过这个PHP插件来生成，有些小问题；它内部集成得不是很好，不是很适合用来直接展示二维码到浏览器上，样式不好控制（不保存二维码文件的情况下）。\r\n\r\n而使用QRCode.js可以非常方面地控制样式，就像一张图片一样来用，因为图片直接输出到：\r\n```\r\n<div id=\"qrcode\"></div>\r\n```\r\n中，非常可控。就像之前微信支付官方的sdk，phpsdk是用的phpqrcode来生成，改成QRCode.js，之后，一个简单的效果：\r\n![](https://www.goozp.com/uploads/2018/01/wechat_qrcode.png)', '<h1 id=\"h1-1-qrcode-js\"><a name=\"1. QRCode.js\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1. QRCode.js</h1><p>QRCode.js是一个二维码生成javascript库；支持跨浏览器的HTML5 Canvas和表格标签的DOM操作；并且不依赖其它的库或拓展。</p>\r\n<p>主页：<a href=\"http://davidshimjs.github.io/qrcodejs/\" title=\"QRCode.js\">QRCode.js</a></p>\r\n<p>Github：<a href=\"https://github.com/davidshimjs/qrcodejs\" title=\"davidshimjs/qrcodejs\">davidshimjs/qrcodejs</a></p>\r\n<h1 id=\"h1-2-\"><a name=\"2. 用法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2. 用法</h1><h2 id=\"h2-2-1-\"><a name=\"2.1 基础用法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.1 基础用法</h2><pre><code>&lt;div id=&quot;qrcode&quot;&gt;&lt;/div&gt;\r\n&lt;script type=&quot;text/javascript&quot;&gt;\r\nnew QRCode(document.getElementById(&quot;qrcode&quot;), &quot;https://www.gzpblog.com&quot;);\r\n&lt;/script&gt;\r\n</code></pre><h2 id=\"h2-2-2-\"><a name=\"2.2 传参用法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.2 传参用法</h2><pre><code>&lt;div id=&quot;qrcode&quot;&gt;&lt;/div&gt;\r\n&lt;script type=&quot;text/javascript&quot;&gt;\r\nvar qrcode = new QRCode(document.getElementById(&quot;qrcode&quot;), {\r\n    text: &quot;https://www.gzpblog.com&quot;,\r\n    width: 128,\r\n    height: 128,\r\n    colorDark : &quot;#000000&quot;,\r\n    colorLight : &quot;#ffffff&quot;,\r\n    correctLevel : QRCode.CorrectLevel.H\r\n});\r\n&lt;/script&gt;\r\n</code></pre><h2 id=\"h2-2-3-\"><a name=\"2.3 调用函数\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.3 调用函数</h2><pre><code>qrcode.clear(); // 清除二维码\r\nqrcode.makeCode(&quot;https://www.gzpblog.com&quot;); // 创建一个新的二维码\r\n</code></pre><h1 id=\"h1-3-\"><a name=\"3. 适用范围\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3. 适用范围</h1><p>之前用 PHP QR Code 来生成二维码，发现通过这个PHP插件来生成，有些小问题；它内部集成得不是很好，不是很适合用来直接展示二维码到浏览器上，样式不好控制（不保存二维码文件的情况下）。</p>\r\n<p>而使用QRCode.js可以非常方面地控制样式，就像一张图片一样来用，因为图片直接输出到：</p>\r\n<pre><code>&lt;div id=&quot;qrcode&quot;&gt;&lt;/div&gt;\r\n</code></pre><p>中，非常可控。就像之前微信支付官方的sdk，phpsdk是用的phpqrcode来生成，改成QRCode.js，之后，一个简单的效果：<br><img src=\"https://www.goozp.com/uploads/2018/01/wechat_qrcode.png\" alt=\"\"></p>\r\n', '', 0, 'publish', 1, 0, '/article/52.html', '', 0, 102, '2017-06-22 15:50:53', '2017-06-22 15:50:53', '2018-01-10 15:49:15', NULL);
INSERT INTO `pt_post` VALUES (53, 10, 'article', 'PACE：页面自动加载进度插件', '# 1. Pace.js\r\npace是一个页面自动加载进度的js插件，而且使用特别方便。\r\n\r\n主页地址：[PACE](http://github.hubspot.com/pace/ \"PACE\")\r\n\r\nGithub地址：[PACE](https://github.com/HubSpot/PACE/ \"PACE\")\r\n\r\n官方也提供了很多加载样式，都很不错，例如：\r\n![](https://www.goozp.com/uploads/2018/01/pace1.png)\r\n\r\n更多主题可以在这里看：[pace/docs](http://github.hubspot.com/pace/docs/welcome/ \"pace/docs\")\r\n\r\n并且提供wordpress插件：[PACE WordPress插件](https://wordpress.org/plugins/search/pace/ \"PACE WordPress插件\")\r\n\r\n# 2. 使用\r\n## 2.1 基本用法\r\n只需要引入一个pace.js文件和一个主题文件，就自动集成了该功能，在加载页面时会有主题对应的效果。\r\n```\r\n<head>\r\n<script src=\"/pace/pace.js\"></script>\r\n<link href=\"/pace/themes/pace-theme-barber-shop.css\" rel=\"stylesheet\" />\r\n</head>\r\n```\r\n\r\n## 2.2 配置\r\n设置window.paceOptions ：\r\n```\r\npaceOptions = {\r\n// Disable the \'elements\' source\r\nelements: false,\r\n\r\n// Only show the progress on regular and ajax-y page navigation,\r\n// not every request\r\nrestartOnRequestAfter: false\r\n}\r\n```\r\n\r\nscript标签中配置参数:\r\n```\r\n<script data-pace-options=\'{ \"ajax\": false }\' src=\'pace.js\'></script>\r\n<pre>\r\n```\r\n\r\n详细的配置可以查看具体的主页文档。\r\n', '<h1 id=\"h1-1-pace-js\"><a name=\"1. Pace.js\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1. Pace.js</h1><p>pace是一个页面自动加载进度的js插件，而且使用特别方便。</p>\r\n<p>主页地址：<a href=\"http://github.hubspot.com/pace/\" title=\"PACE\">PACE</a></p>\r\n<p>Github地址：<a href=\"https://github.com/HubSpot/PACE/\" title=\"PACE\">PACE</a></p>\r\n<p>官方也提供了很多加载样式，都很不错，例如：<br><img src=\"https://www.goozp.com/uploads/2018/01/pace1.png\" alt=\"\"></p>\r\n<p>更多主题可以在这里看：<a href=\"http://github.hubspot.com/pace/docs/welcome/\" title=\"pace/docs\">pace/docs</a></p>\r\n<p>并且提供wordpress插件：<a href=\"https://wordpress.org/plugins/search/pace/\" title=\"PACE WordPress插件\">PACE WordPress插件</a></p>\r\n<h1 id=\"h1-2-\"><a name=\"2. 使用\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2. 使用</h1><h2 id=\"h2-2-1-\"><a name=\"2.1 基本用法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.1 基本用法</h2><p>只需要引入一个pace.js文件和一个主题文件，就自动集成了该功能，在加载页面时会有主题对应的效果。</p>\r\n<pre><code>&lt;head&gt;\r\n&lt;script src=&quot;/pace/pace.js&quot;&gt;&lt;/script&gt;\r\n&lt;link href=&quot;/pace/themes/pace-theme-barber-shop.css&quot; rel=&quot;stylesheet&quot; /&gt;\r\n&lt;/head&gt;\r\n</code></pre><h2 id=\"h2-2-2-\"><a name=\"2.2 配置\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.2 配置</h2><p>设置window.paceOptions ：</p>\r\n<pre><code>paceOptions = {\r\n// Disable the &#39;elements&#39; source\r\nelements: false,\r\n\r\n// Only show the progress on regular and ajax-y page navigation,\r\n// not every request\r\nrestartOnRequestAfter: false\r\n}\r\n</code></pre><p>script标签中配置参数:</p>\r\n<pre><code>&lt;script data-pace-options=&#39;{ &quot;ajax&quot;: false }&#39; src=&#39;pace.js&#39;&gt;&lt;/script&gt;\r\n&lt;pre&gt;\r\n</code></pre><p>详细的配置可以查看具体的主页文档。</p>\r\n', '', 0, 'publish', 1, 0, '/article/53.html', '', 0, 135, '2017-06-23 03:46:25', '2017-06-23 03:46:25', '2018-01-10 15:58:04', NULL);
INSERT INTO `pt_post` VALUES (54, 10, 'article', 'WebSocket实现', '# 1. 什么是WebSocket？\r\nWebSocket 是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。\r\n\r\n可以用来替代长轮询（long polling）；long polling 就是客户端不停地向服务器发送请求以获取最新的数据信息，比如说用ajax轮询就是一种方式。\r\n\r\n应用场景：一些高实时的应用场景，比如社交聊天、弹幕、多玩家游戏、协同编辑、股票基金实时报价、体育实况更新、视频会议/聊天、基于位置的应用、在线教育、智能家居等等。\r\n\r\n# 2. WebSocket客户端实现\r\n## 2.1 创建一个 WebSocket 对象\r\n```\r\nvar Socket = new WebSocket(url, [protocol] );\r\n```\r\n第一个参数 url, 指定连接的 URL。WebSocket协议的URL使用`ws://`开头，SSL的WebSocket协议使用`wss://`开头。\r\n\r\n第二个参数 protocol 是可选的，指定了可接受的子协议。\r\n\r\n## 2.2 WebSocket 属性\r\n### Socket.readyState\r\n只读属性 readyState 表示连接状态，状态值：\r\n- 0 – 表示连接尚未建立。\r\n- 1 – 表示连接已建立，可以进行通信。\r\n- 2 – 表示连接正在进行关闭。\r\n- 3 – 表示连接已经关闭或者连接不能打开。\r\n\r\n### Socket.bufferedAmount\r\n只读属性 bufferedAmount 表示已被 send() 放入正在队列中等待传输，但是还没有发出的 UTF-8 文本字节数。\r\n\r\n## 2.3 WebSocket 事件\r\nWebSocket 对象目前一共有四个：onopen, onmessage, onclose 和 onerror。\r\n- Socket.onopen 连接建立时触发\r\n- Socket.onmessage 客户端接收服务端数据时触发\r\n- Socket.onerror 通信发生错误时触发\r\n- Socket.onclose 连接关闭时触发\r\n\r\n## 2.4 WebSocket 方法\r\n`Socket.send()` 使用连接发送数据\r\n\r\n`Socket.close()` 关闭连接\r\n\r\n## 2.5. 一个简单的例子\r\n```\r\n<script type=\"text/javascript\">\r\n    //检查浏览器是否支持WebSocket\r\n    if(window.WebSocket){\r\n        console.log(\'This browser supports WebSocket\');\r\n    }else{\r\n        console.log(\'This browser does not supports WebSocket\');\r\n    }\r\n\r\n    // 打开一个 web socket\r\n    var ws = new WebSocket(\"ws://localhost:1234\");\r\n\r\n    /**\r\n     * 连接建立时\r\n     */\r\n    ws.onopen = function()\r\n    {\r\n         // 使用 send() 方法发送数据\r\n         ws.send(\"hello\");\r\n    };\r\n\r\n    /**\r\n     * 接收服务端数据时\r\n     */\r\n    ws.onmessage = function (evt)\r\n    {\r\n        var received_data = evt.data;\r\n        console.log(received_data);\r\n    };\r\n\r\n    /**\r\n     * 连接关闭时\r\n     */\r\n    ws.onclose = function(){\r\n        alert(\"连接已关闭...\");\r\n    };\r\n\r\n    /**\r\n     * 通信发生错误时\r\n     */\r\n    ws.onerror = function(){\r\n        // 关闭 websocket\r\n        ws.close();\r\n    };\r\n</script>\r\n```\r\n\r\n# 3. WebSocket 服务端实现\r\n服务端实现 WebSocket，现在各种语言都很方便了。\r\n\r\n比如PHP，我们可以使用Swoole，workerman，ReactPHP等。', '<h1 id=\"h1-1-websocket-\"><a name=\"1. 什么是WebSocket？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1. 什么是WebSocket？</h1><p>WebSocket 是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。</p>\r\n<p>可以用来替代长轮询（long polling）；long polling 就是客户端不停地向服务器发送请求以获取最新的数据信息，比如说用ajax轮询就是一种方式。</p>\r\n<p>应用场景：一些高实时的应用场景，比如社交聊天、弹幕、多玩家游戏、协同编辑、股票基金实时报价、体育实况更新、视频会议/聊天、基于位置的应用、在线教育、智能家居等等。</p>\r\n<h1 id=\"h1-2-websocket-\"><a name=\"2. WebSocket客户端实现\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2. WebSocket客户端实现</h1><h2 id=\"h2-2-1-websocket-\"><a name=\"2.1 创建一个 WebSocket 对象\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.1 创建一个 WebSocket 对象</h2><pre><code>var Socket = new WebSocket(url, [protocol] );\r\n</code></pre><p>第一个参数 url, 指定连接的 URL。WebSocket协议的URL使用<code>ws://</code>开头，SSL的WebSocket协议使用<code>wss://</code>开头。</p>\r\n<p>第二个参数 protocol 是可选的，指定了可接受的子协议。</p>\r\n<h2 id=\"h2-2-2-websocket-\"><a name=\"2.2 WebSocket 属性\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.2 WebSocket 属性</h2><h3 id=\"h3-socket-readystate\"><a name=\"Socket.readyState\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Socket.readyState</h3><p>只读属性 readyState 表示连接状态，状态值：</p>\r\n<ul>\r\n<li>0 – 表示连接尚未建立。</li><li>1 – 表示连接已建立，可以进行通信。</li><li>2 – 表示连接正在进行关闭。</li><li>3 – 表示连接已经关闭或者连接不能打开。</li></ul>\r\n<h3 id=\"h3-socket-bufferedamount\"><a name=\"Socket.bufferedAmount\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Socket.bufferedAmount</h3><p>只读属性 bufferedAmount 表示已被 send() 放入正在队列中等待传输，但是还没有发出的 UTF-8 文本字节数。</p>\r\n<h2 id=\"h2-2-3-websocket-\"><a name=\"2.3 WebSocket 事件\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.3 WebSocket 事件</h2><p>WebSocket 对象目前一共有四个：onopen, onmessage, onclose 和 onerror。</p>\r\n<ul>\r\n<li>Socket.onopen 连接建立时触发</li><li>Socket.onmessage 客户端接收服务端数据时触发</li><li>Socket.onerror 通信发生错误时触发</li><li>Socket.onclose 连接关闭时触发</li></ul>\r\n<h2 id=\"h2-2-4-websocket-\"><a name=\"2.4 WebSocket 方法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.4 WebSocket 方法</h2><p><code>Socket.send()</code> 使用连接发送数据</p>\r\n<p><code>Socket.close()</code> 关闭连接</p>\r\n<h2 id=\"h2-2-5-\"><a name=\"2.5. 一个简单的例子\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.5. 一个简单的例子</h2><pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n    //检查浏览器是否支持WebSocket\r\n    if(window.WebSocket){\r\n        console.log(&#39;This browser supports WebSocket&#39;);\r\n    }else{\r\n        console.log(&#39;This browser does not supports WebSocket&#39;);\r\n    }\r\n\r\n    // 打开一个 web socket\r\n    var ws = new WebSocket(&quot;ws://localhost:1234&quot;);\r\n\r\n    /**\r\n     * 连接建立时\r\n     */\r\n    ws.onopen = function()\r\n    {\r\n         // 使用 send() 方法发送数据\r\n         ws.send(&quot;hello&quot;);\r\n    };\r\n\r\n    /**\r\n     * 接收服务端数据时\r\n     */\r\n    ws.onmessage = function (evt)\r\n    {\r\n        var received_data = evt.data;\r\n        console.log(received_data);\r\n    };\r\n\r\n    /**\r\n     * 连接关闭时\r\n     */\r\n    ws.onclose = function(){\r\n        alert(&quot;连接已关闭...&quot;);\r\n    };\r\n\r\n    /**\r\n     * 通信发生错误时\r\n     */\r\n    ws.onerror = function(){\r\n        // 关闭 websocket\r\n        ws.close();\r\n    };\r\n&lt;/script&gt;\r\n</code></pre><h1 id=\"h1-3-websocket-\"><a name=\"3. WebSocket 服务端实现\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3. WebSocket 服务端实现</h1><p>服务端实现 WebSocket，现在各种语言都很方便了。</p>\r\n<p>比如PHP，我们可以使用Swoole，workerman，ReactPHP等。</p>\r\n', '', 0, 'publish', 1, 0, '/article/54.html', '', 0, 110, '2017-06-23 08:12:59', '2017-06-23 08:12:59', '2018-01-10 16:15:21', NULL);
INSERT INTO `pt_post` VALUES (55, 10, 'article', 'PHP正则表达式的应用', '> 关于PCRE的介绍以及实现正则表达式功能的所有说明，都可以在官方手册中看到：[正则表达式(兼容 Perl)](http://php.net/manual/zh/book.pcre.php \"正则表达式(兼容 Perl)\")\r\n\r\n# 一 认识PCRE\r\n##  1. 什么是PCRE\r\nPCRE 库是一个实现了与 perl 5 在语法和语义上略有差异的正则表达式模式匹配功能的函数集。\r\n\r\n## 2. PCRE 库介绍\r\n**PCRE 是 PHP 核心扩展**，所以总是启用的。\r\n默认情况下，该扩展使用内置的 PCRE library。或者，也可以通过指定 configure 选项 –with-pcre-regex=DIR 设置外部 PCRE library 目录，DIR 是 PCRE 的 include 和 library 文件位置。 PHP 5.6/7.0 推荐使用 PCRE 8.10 或更高版本。\r\n\r\n这些函数中使用的模式语法非常类似 perl。表达式必须用分隔符闭合，比如一个正斜杠(/)。 分隔符可以使任意非字母数字，除反斜杠(\\)和空字节之外的非空白 ascii 字符。 如果分隔符 在表达式中使用，需要使用反斜线进行转义。自php 4.0.4开始，可以使用 perl 样式的()、 {}、 [] 以及 <> 作为分隔符。\r\n\r\n## 3. PCRE正则与POSIX 正则\r\n除了PCRE正则库，还有POSIX 正则库。 **自PHP 5.3.0起， POSIX 正则表达式扩展被废弃。**所以，这里也没有必要研究 POSIX 正则了，这里我们就看PCRE正则。\r\n\r\n## 4. 版本特性\r\nPHP 7.0.0 起 PCRE 默认支持 JIT（just-in-time）编译技术，PHP 7.0.12 起可以通过 –without-pcre-jit 禁用 PCRE 的 JIT 功能。\r\n\r\nPHP 的 Windows 版本已内建对此扩展的支持。不需要载入额外的扩展来使用这些函数。\r\n\r\nPHP 5.3.0 的之前版本，可通过 –without-pcre-regex 配置选项禁用此扩展。\r\n\r\n# 二. 预定义常量\r\n下列常量由此扩展定义，且仅在此扩展编译入 PHP 或在运行时动态载入时可用。\r\n\r\n|  常量 | 描述  |  自哪个版本起 |\r\n| ------------ | ------------ | ------------ |\r\n| PREG_PATTERN_ORDER  | 结果按照”规则”排序，仅用于preg_match_all()，即$matches[0]是完整规则的匹配结果，$matches[1]是第一个子组匹配的结果，等等。  |  since |\r\n| PREG_SET_ORDER  |  结果按照”集合”排序，仅用于preg_match_all()，即$matches[0]保存第一次匹配结果的所有结果(包含子组)信息, $matches[1]保存第二次的结果信息，等等。 |   |\r\n| PREG_OFFSET_CAPTURE | 查看PREG_SPLIT_OFFSET_CAPTURE的描述。 | 4.3.0\r\n| PREG_SPLIT_NO_EMPTY | 这个标记告诉preg_split()仅返回非空部分。| \r\n| PREG_SPLIT_DELIM_CAPTURE | 这个标记告诉preg_split()同时捕获括号表达式匹配到的内容。 | 4.0.5\r\n| PREG_SPLIT_OFFSET_CAPTURE | 如果设置了这个标记，每次出现的匹配子串的偏移量也会被返回。注意，这会改变返回数组中的值，每个元素都是由匹配子串作为第0个元素，它相对目标字符串的偏移量作为第1个元素的数组。这个标记只能用于preg_split()。 | 4.3.0\r\n| PREG_NO_ERROR | 没有匹配错误时调用 preg_last_error() 返回。 | 5.2.0\r\n| PREG_INTERNAL_ERROR | 如果有PCRE内部错误时调用 preg_last_error() 返回。 | 5.2.0\r\n| PREG_BACKTRACK_LIMIT_ERROR | 如果调用回溯限制超出，调用preg_last_error()时返回。 | 5.2.0\r\n| PREG_RECURSION_LIMIT_ERROR | 如果递归限制超出，调用preg_last_error()时返回。 | 5.2.0\r\n| PREG_BAD_UTF8_ERROR | 如果最后一个错误时由于异常的utf-8数据(仅在运行在UTF-8 模式正则表达式下可用)。导致的，调用preg_last_error()返回。 | 5.2.0\r\n| vPREG_BAD_UTF8_OFFSET_ERROR | 如果偏移量与合法的urf-8代码不匹配(仅在运行在UTF-8 模式正则表达式下可用)。调用preg_last_error()返回。 | 5.3.0\r\n| PREG_JIT_STACKLIMIT_ERROR | 当 PCRE 函数因 JIT 栈空间限制而失败， preg_last_error() 就会返回此常量。 | 7.0.0\r\n| PCRE_VERSION | PCRE版本号和发布日期(比如： “7.0 18-Dec-2006”)。 | 5.2.4\r\n\r\n# 三 正则语法\r\n1. 详细的正则语法可以参考：[http://php.net/manual/zh/reference.pcre.pattern.syntax.php](http://php.net/manual/zh/reference.pcre.pattern.syntax.php \"http://php.net/manual/zh/reference.pcre.pattern.syntax.php\")\r\n\r\n# 四 PCRE 函数\r\n这篇文章的关注重点将在于函数，和函数的应用，即是正则在PHP中的具体实现。接下来一个一个看。\r\n\r\n## 1. preg_filter() 执行一个正则表达式搜索和替换\r\n- 语法：mixed preg_filter ( mixed $pattern , mixed $replacement , mixed $subject [, int $limit = -1 [, int &$count ]] )\r\n\r\n- 说明：preg_filter()等价于preg_replace() 除了它仅仅返回(可能经过转化)与目标匹配的结果。\r\n\r\n- 返回值： 如果subject是一个数组，返回一个数组， 其他情况返回一个字符串。如果没有找到匹配或者发生了错误，当subject是数组 时返回一个空数组，其他情况返回NULL。\r\n\r\n- 例子：\r\n\r\n```\r\n<?php\r\n$subject = array(\'1\', \'a\', \'2\', \'b\', \'3\', \'A\', \'B\', \'4\'); \r\n$pattern = array(\'/\\d/\', \'/[a-z]/\', \'/[1a]/\'); \r\n$replace = array(\'A:$0\', \'B:$0\', \'C:$0\'); \r\n \r\nprint_r(preg_filter($pattern, $replace, $subject)); //使用filter\r\n \r\nprint_r(preg_replace($pattern, $replace, $subject)); //使用replace\r\n \r\n/*\r\n返回： \r\nArray\r\n(\r\n    [0] => A:C:1\r\n    [1] => B:C:a\r\n    [2] => A:2\r\n    [3] => B:b\r\n    [4] => A:3\r\n    [7] => A:4\r\n)\r\nArray\r\n(\r\n    [0] => A:C:1\r\n    [1] => B:C:a\r\n    [2] => A:2\r\n    [3] => B:b\r\n    [4] => A:3\r\n    [5] => A\r\n    [6] => B\r\n    [7] => A:4\r\n)\r\npreg_filter()只返回匹配到的；preg_replace() 返回所有\r\n*/\r\n```\r\n\r\n## 2. preg_grep() 返回匹配模式的数组条目；正则检索一个数组的所有元素\r\n\r\n- 语法：array preg_grep ( string $pattern , array $input [, int $flags = 0 ] )\r\n\r\n- 说明：返回给定数组input中与模式pattern 匹配的元素组成的数组.\r\n\r\n- 参数：\r\n	- pattern，要搜索的模式, 字符串形式.\r\n	- input，输入数组.\r\n	- flags，如果设置为PREG_GREP_INVERT, 这个函数返回输入数组中与 给定模式pattern不匹配的元素组成的数组\r\n\r\n- 返回值：返回使用input中key做索引的数组。\r\n\r\n- 例子：\r\n```php\r\n<?php\r\n// 找出有p的\r\n$foods = array(\"pasta\", \"steak\", \"fish\", \"potatoes\");\r\n$p_foods = preg_grep(\"/p(\\w+)/\", $foods);\r\nprint_r($p_foods)\r\n// 输出\r\n// Array ( [0] => pasta [3] => potatoes )\r\n```\r\n\r\n## 3. preg_last_error() 返回最后一个PCRE正则执行产生的错误代码\r\n- 语法：int preg_last_error ( void )\r\n\r\n- 返回值：返回最后一次PCRE正则执行的错误代码。\r\n	- PREG_NO_ERROR 没有匹配错误\r\n	- PREG_INTERNAL_ERROR 有PCRE内部错误\r\n	- PREG_BACKTRACK_LIMIT_ERROR 调用回溯限制超出\r\n	- PREG_RECURSION_LIMIT_ERROR 递归限制超出\r\n	- PREG_BAD_UTF8_ERROR 异常的utf-8数据导致\r\n	- PREG_BAD_UTF8_OFFSET_ERROR （自 PHP 5.3.0 起） 偏移量与合法的urf-8代码不匹配\r\n	- PREG_JIT_STACKLIMIT_ERROR (自 PHP 7.0.0 起) 因 JIT 栈空间限制而失败\r\n具体错误代码的详情在上面预定义常量部分。\r\n\r\n- 例子：\r\n\r\n```php\r\n<?php\r\n$a = preg_match(\'/(?:\\D+|<\\d+>)*[!?]/\', \'foobar foobar foobar\');\r\nprint_r($a);\r\n \r\nif (preg_last_error() == PREG_BACKTRACK_LIMIT_ERROR) {\r\n	print \'Backtrack limit was exhausted!\';\r\n}\r\n// 输出：Backtrack limit was exhausted!\r\n```\r\n\r\n## 4. preg_match() 执行匹配正则表达式\r\n- 语法：int preg_match ( string $pattern , string $subject [, array &$matches [, int $flags = 0 [, int $offset = 0 ]]] )\r\n\r\n- 说明：搜索subject与pattern给定的正则表达式的一个匹配。\r\n\r\n- 参数：\r\n	- pattern，要搜索的模式，字符串类型。\r\n	- subject，输入字符串。\r\n	- matches，如果提供了参数matches，它将被填充为搜索结果。 $matches[0]将包含完整模式匹配到的文本， $matches[1] 将包含第一个捕获子组匹配到的文本，以此类推。\r\n	- flags，flags可以被设置为以下标记值：\r\n		○ PREG_OFFSET_CAPTURE，如果传递了这个标记，对于每一个出现的匹配返回时会附加字符串偏移量(相对于目标字符串的)。 注意：这会改变填充到matches参数的数组，使其每个元素成为一个由 第0个元素是匹配到的字符串，第1个元素是该匹配字符串 在目标字符串subject中的偏移量。\r\n	- offset，通常，搜索从目标字符串的开始位置开始。可选参数 offset 用于 指定从目标字符串的某个位置开始搜索(单位是字节)。\r\n\r\n- 返回值：preg_match()返回 pattern 的匹配次数。 它的值将是0次（不匹配）或1次，因为preg_match()在第一次匹配后 将会停止搜索。preg_match_all()不同于此，它会一直搜索subject 直到到达结尾。 如果发生错误preg_match()返回 FALSE。\r\n\r\n- 例子：\r\n\r\n```php\r\n<?php\r\n//从URL中获取主机名称\r\npreg_match(\'@^(?:http://)?([^/]+)@i\', \"http://www.php.net/index.html\", $matches);\r\nprint_r($matches);\r\n// 输出 Array ( [0] => http://www.php.net [1] => www.php.net )\r\n\r\npreg_match(\'/[^.]+\\.[^.]+$/\', $matches[1], $matches);\r\nprint_r($matches);\r\n// 输出 Array ( [0] => php.net )\r\n```\r\n\r\n## 5. preg_match_all() 执行一个全局正则表达式匹配\r\n- 语法：int preg_match_all ( string $pattern , string $subject [, array &$matches [, int $flags = PREG_PATTERN_ORDER [, int $offset = 0 ]]] )\r\n\r\n- 说明： 搜索subject中所有匹配pattern给定正则表达式的匹配结果并且将它们以flag指定顺序输出到matches中。在第一个匹配找到后，子序列继续从最后一次匹配位置搜索。\r\n\r\n- 参数：\r\n	- pattern，要搜索的模式，字符串形式。\r\n    - subject，输入字符串。\r\n    - matches，多维数组，作为输出参数输出所有匹配结果, 数组排序通过flags指定。\r\n    - flags，可以结合下面标记使用(注意不能同时使用PREG_PATTERN_ORDER和PREG_SET_ORDER)\r\n		- PREG_PATTERN_ORDER 结果排序为$matches[0]保存完整模式的所有匹配, $matches[1] 保存第一个子组的所有匹配，以此类推。\r\n		- PREG_SET_ORDER 结果排序为$matches[0]包含第一次匹配得到的所有匹配(包含子组)， $matches[1]是包含第二次匹配到的所有匹配(包含子组)的数组，以此类推。\r\n		- PREG_OFFSET_CAPTURE 如果这个标记被传递，每个发现的匹配返回时会增加它相对目标字符串的偏移量。 注意这会改变matches中的每一个匹配结果字符串元素，使其 成为一个第0个元素为匹配结果字符串，第1个元素为 匹配结果字符串在subject中的偏移量。\r\n		- 如果没有给定排序标记，假定设置为PREG_PATTERN_ORDER。\r\n    - offset，通常， 查找时从目标字符串的开始位置开始。可选参数offset用于 从目标字符串中指定位置开始搜索(单位是字节)。\r\n\r\n- 返回值：返回完整匹配次数（可能是0），或者如果发生错误返回FALSE。\r\n\r\n- 例子：\r\n\r\n```\r\n<?php\r\n// \\\\2是一个后向引用的示例. 这会告诉pcre它必须匹配正则表达式中第二个圆括号(这里是([\\w]+))\r\n// 匹配到的结果. 这里使用两个反斜线是因为这里使用了双引号.\r\n$html = \"<b>bold text</b><a href=howdy.html>click me</a>\";\r\npreg_match_all(\"/(<([\\w]+)[^>]*>)(.*?)(<\\/\\\\2>)/\", $html, $matches, PREG_SET_ORDER);\r\nprint_r($matches);\r\n/*\r\n输出\r\nArray\r\n(\r\n    [0] => Array\r\n        (\r\n            [0] => <b>bold text</b>\r\n            [1] => <b>\r\n            [2] => b\r\n            [3] => bold text\r\n            [4] => </b>\r\n        )\r\n\r\n    [1] => Array\r\n        (\r\n            [0] => <a href=howdy.html>click me</a>\r\n            [1] => <a href=howdy.html>\r\n            [2] => a\r\n            [3] => click me\r\n            [4] => </a>\r\n        )\r\n\r\n)\r\n*/\r\n```\r\n\r\n## 6. preg_quote() 转义正则表达式字符\r\n- 语法：string preg_quote ( string $str [, string $delimiter = NULL ] )\r\n\r\n- 说明： preg_quote()需要参数 str 并向其中每个正则表达式语法中的字符前增加一个反斜线。 这通常用于你有一些运行时字符串需要作为正则表达式进行匹配的时候。\r\n    - 正则表达式特殊字符有： . \\ + * ? [ ^ ] $ ( ) { } = ! < > | : –\r\n    - 注意 / 不是正则表达式特殊字符。\r\n\r\n- 注意：preg_quote() 的应用场景不是用于 preg_replace() 的 $replacement 字符串参数。\r\n\r\n- 参数：\r\n   - str，输入字符串\r\n   - delimiter，如果指定了可选参数 delimiter，它也会被转义。这通常用于 转义PCRE函数使用的分隔符。 / 是最常见的分隔符。\r\n\r\n- 返回值：返回转义后的字符串。\r\n\r\n- 例子：\r\n```\r\n<?php\r\n$keywords = \'$40 for a g3/400\';\r\n$keywords = preg_quote($keywords, \'/\');\r\necho $keywords; \r\n// 返回 \\$40 for a g3\\/400\r\n// $是正则表达式特殊字符, /被当参数传入也转义\r\n```\r\n\r\n## 7. preg_replace_callback() 执行一个正则表达式搜索并且使用一个回调进行替换\r\n- 语法：mixed preg_replace_callback ( mixed $pattern , callable $callback , mixed $subject [, int $limit = -1 [, int &$count ]] )\r\n\r\n- 说明：这个函数的行为除了 可以指定一个 callback 替代 replacement 进行替换 字符串的计算，其他方面等同于 preg_replace()。\r\n\r\n- 参数：\r\n    - pattern，要搜索的模式，可以使字符串或一个字符串数组。\r\n    - callback， 一个回调函数，在每次需要替换时调用，调用时函数得到的参数是从subject 中匹配到的结果。回调函数返回真正参与替换的字符串。这是该回调函数的签名：string handler ( array $matches ) 。你可能经常会需要callback函数而 仅用于preg_replace_callback()一个地方的调用。在这种情况下，你可以 使用匿名函数来定义一个匿名函数作 为preg_replace_callback()调用时的回调。 这样做你可以保留所有 调用信息在同一个位置并且不会因为一个不在任何其他地方使用的回调函数名称而污染函数名称空间。\r\n   - subject，要搜索替换的目标字符串或字符串数组。\r\n   - limit，对于每个模式用于每个 subject 字符串的最大可替换次数。 默认是-1（无限制）。\r\n   - count，如果指定，这个变量将被填充为替换执行的次数。\r\n\r\n- 返回值： 如果subject是一个数组， preg_replace_callback()返回一个数组，其他情况返回字符串。 错误发生时返回 NULL。如果查找到了匹配，返回替换后的目标字符串（或字符串数组）， 其他情况subject 将会无变化返回。\r\n\r\n例子：\r\n```\r\n<?php\r\n/* 将文本中的年份增加一年 */\r\n$text = \"April fools day is 04/01/2002\\n\";\r\n$text.= \"Last christmas was 12/24/2001\\n\";\r\n// 回调函数\r\nfunction next_year($matches)\r\n{\r\n    /*\r\n    print_r($matches);$matches为:\r\n    Array\r\n    (\r\n        [0] => 04/01/2002\r\n        [1] => 04/01/\r\n        [2] => 2002\r\n    )\r\n    Array\r\n    (\r\n        [0] => 12/24/2001\r\n        [1] => 12/24/\r\n        [2] => 2001\r\n    )\r\n    说明匹配到一个就扔进来一次\r\n    */\r\n    return $matches[1].($matches[2]+1);\r\n}\r\n$text = preg_replace_callback(\"|(\\d{2}/\\d{2}/)(\\d{4})|\", \"next_year\", $text);\r\necho $text;\r\n/*\r\n输出\r\nApril fools day is 04/01/2003\r\nLast christmas was 12/24/2002\r\n*/\r\n```\r\n\r\n## 8. preg_replace_callback_array() 执行一个正则表达式搜索并且使用多个回调进行替换\r\n- 语法：mixed preg_replace_callback_array ( array $patterns_and_callbacks , mixed $subject [, int $limit = -1 [, int &$count ]] )\r\n\r\n- 说明：类似于 preg_replace_callback(), 除了回调函数是基于每个参数。\r\n\r\n- 参数：\r\n    - patterns_and_callbacks，参数（keys）对应回调函数（values）的数组。\r\n    - subject，要搜索替换的目标字符串或字符串数组。\r\n    - limit，对于每个模式用于每个 subject 字符串的最大可替换次数。 默认是-1（无限制）。\r\n    - count，如果指定，这个变量将被填充为替换执行的次数。\r\n\r\n- 返回值：\r\npreg_replace_callback_array() 如果参数是数组则会返回一个数组，否则为字符串。出错时返回 NULL；如果匹配到，会返回一个新的subject\r\n\r\n- 例子：\r\n```php\r\n<?php\r\n$subject = \'Aaaaaa Bbb\';\r\npreg_replace_callback_array(\r\n    [\r\n        \'~[a]+~i\' => function ($match) {\r\n            echo strlen($match[0]), \' matches for \"a\" found\', PHP_EOL;\r\n        },\r\n        \'~[b]+~i\' => function ($match) {\r\n            echo strlen($match[0]), \' matches for \"b\" found\', PHP_EOL;\r\n        }\r\n    ],\r\n    $subject\r\n);\r\n/*\r\n输出\r\n6 matches for \"a\" found\r\n3 matches for \"b\" found\r\n*/\r\n```\r\n\r\n## 9. preg_replace() 执行一个正则表达式的搜索和替换\r\n- 语法：mixed preg_replace ( mixed $pattern , mixed $replacement , mixed $subject [, int $limit = -1 [, int &$count ]] )\r\n\r\n- 说明：搜索subject中匹配pattern的部分， 以replacement进行替换。\r\n\r\n- 参数：\r\n    - pattern，要搜索的模式。可以使一个字符串或字符串数组。 可以使用一些PCRE修饰符。\r\n    - replacement，用于替换的字符串或字符串数组。如果这个参数是一个字符串，并且pattern 是一个数组，那么所有的模式都使用这个字符串进行替换。如果pattern和replacement 都是数组，每个pattern使用replacement中对应的 元素进行替换。如果replacement中的元素比pattern中的少， 多出来的pattern使用空字符串进行替换。replacement中可以包含后向引用\\\\n 或$n，语法上首选后者。 每个 这样的引用将被匹配到的第n个捕获子组捕获到的文本替换。 n 可以是0-99，\\\\0和$0代表完整的模式匹配文本。 捕获子组的序号计数方式为：代表捕获子组的左括号从左到右， 从1开始数。如果要在replacement 中使用反斜线，必须使用4个(“\\\\\\\\”，译注：因为这首先是php的字符串，经过转义后，是两个，再经过 正则表达式引擎后才被认为是一个原文反斜线)。当在替换模式下工作并且后向引用后面紧跟着需要是另外一个数字(比如：在一个匹配模式后紧接着增加一个原文数字)， 不能使用\\\\1这样的语法来描述后向引用。比如， \\\\11将会使preg_replace() 不能理解你希望的是一个\\\\1后向引用紧跟一个原文1，还是 一个\\\\11后向引用后面不跟任何东西。 这种情况下解决方案是使用${1}1。 这创建了一个独立的$1后向引用, 一个独立的原文1。当使用被弃用的 e 修饰符时, 这个函数会转义一些字符(即：’、”、 \\ 和 NULL) 然后进行后向引用替换。当这些完成后请确保后向引用解析完后没有单引号或 双引号引起的语法错误(比如： ‘strlen(\\’$1\\’)+strlen(“$2”)’)。确保符合PHP的 字符串语法，并且符合eval语法。因为在完成替换后， 引擎会将结果字符串作为php代码使用eval方式进行评估并将返回值作为最终参与替换的字符串。\r\n    - subject，要进行搜索和替换的字符串或字符串数组。如果subject是一个数组，搜索和替换回在subject 的每一个元素上进行, 并且返回值也会是一个数组。\r\n    - limit，每个模式在每个subject上进行替换的最大次数。默认是 -1(无限)。\r\n    - count，如果指定，将会被填充为完成的替换次数。\r\n\r\n- 返回值： 如果subject是一个数组， preg_replace()返回一个数组， 其他情况下返回一个字符串。如果匹配被查找到，替换后的subject被返回，其他情况下 返回没有改变的 subject。如果发生错误，返回 NULL 。\r\n\r\n- 例子：\r\n```php\r\n<?php\r\n$patterns = array (\'/(19|20)(\\d{2})-(\\d{1,2})-(\\d{1,2})/\', \'/^\\s*{(\\w+)}\\s*=/\');\r\n$replace = array (\'\\3/\\4/\\1\\2\', \'$\\1 =\');\r\necho preg_replace($patterns, $replace, \'{startDate} = 1999-5-27\');\r\n// 输出: $startDate = 5/27/1999\r\n```\r\n\r\n## 10. preg_split() 通过一个正则表达式分隔字符串\r\n- 语法：array preg_split ( string $pattern , string $subject [, int $limit = -1 [, int $flags = 0 ]] )\r\n\r\n- 说明：通过一个正则表达式分隔给定字符串.\r\n\r\n- 参数：\r\n    - pattern，用于搜索的模式，字符串形式。\r\n    - subject，输入字符串\r\n    - limit，如果指定，将限制分隔得到的子串最多只有limit个，返回的最后一个 子串将包含所有剩余部分。limit值为-1， 0或null时都代表”不限制”， 作为php的标准，你可以使用null跳过对flags的设置。\r\n    - flags，flags 可以是任何下面标记的组合(以位或运算 | 组合)：\r\n		- PREG_SPLIT_NO_EMPTY，如果这个标记被设置， preg_split() 将进返回分隔后的非空部分。\r\n		- PREG_SPLIT_DELIM_CAPTURE，如果这个标记设置了，用于分隔的模式中的括号表达式将被捕获并返回。\r\n		- PREG_SPLIT_OFFSET_CAPTURE，如果这个标记被设置, 对于每一个出现的匹配返回时将会附加字符串偏移量. 注意：这将会改变返回数组中的每一个元素, 使其每个元素成为一个由第0 个元素为分隔后的子串，第1个元素为该子串在subject 中的偏移量组成的数组。\r\n\r\n- 返回值：返回一个使用 pattern 边界分隔 subject 后得到 的子串组成的数组， 或者在失败时返回 FALSE。\r\n\r\n- 例子：\r\n```php\r\n<?php\r\n$keywords = preg_split (\"/[\\s,]+/\", \"hypertext language, programming\"); \r\nprint_r($keywords);\r\n// 输出\r\n// Array ( [0] => hypertext [1] => language [2] => programming )\r\n```', '<blockquote>\r\n<p>关于PCRE的介绍以及实现正则表达式功能的所有说明，都可以在官方手册中看到：<a href=\"http://php.net/manual/zh/book.pcre.php\" title=\"正则表达式(兼容 Perl)\">正则表达式(兼容 Perl)</a></p>\r\n</blockquote>\r\n<h1 id=\"h1--pcre\"><a name=\"一 认识PCRE\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一 认识PCRE</h1><h2 id=\"h2-1-pcre\"><a name=\"1. 什么是PCRE\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1. 什么是PCRE</h2><p>PCRE 库是一个实现了与 perl 5 在语法和语义上略有差异的正则表达式模式匹配功能的函数集。</p>\r\n<h2 id=\"h2-2-pcre-\"><a name=\"2. PCRE 库介绍\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2. PCRE 库介绍</h2><p><strong>PCRE 是 PHP 核心扩展</strong>，所以总是启用的。<br>默认情况下，该扩展使用内置的 PCRE library。或者，也可以通过指定 configure 选项 –with-pcre-regex=DIR 设置外部 PCRE library 目录，DIR 是 PCRE 的 include 和 library 文件位置。 PHP 5.6/7.0 推荐使用 PCRE 8.10 或更高版本。</p>\r\n<p>这些函数中使用的模式语法非常类似 perl。表达式必须用分隔符闭合，比如一个正斜杠(/)。 分隔符可以使任意非字母数字，除反斜杠()和空字节之外的非空白 ascii 字符。 如果分隔符 在表达式中使用，需要使用反斜线进行转义。自php 4.0.4开始，可以使用 perl 样式的()、 {}、 [] 以及 &lt;&gt; 作为分隔符。</p>\r\n<h2 id=\"h2-3-pcre-posix-\"><a name=\"3. PCRE正则与POSIX 正则\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3. PCRE正则与POSIX 正则</h2><p>除了PCRE正则库，还有POSIX 正则库。 <strong>自PHP 5.3.0起， POSIX 正则表达式扩展被废弃。</strong>所以，这里也没有必要研究 POSIX 正则了，这里我们就看PCRE正则。</p>\r\n<h2 id=\"h2-4-\"><a name=\"4. 版本特性\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4. 版本特性</h2><p>PHP 7.0.0 起 PCRE 默认支持 JIT（just-in-time）编译技术，PHP 7.0.12 起可以通过 –without-pcre-jit 禁用 PCRE 的 JIT 功能。</p>\r\n<p>PHP 的 Windows 版本已内建对此扩展的支持。不需要载入额外的扩展来使用这些函数。</p>\r\n<p>PHP 5.3.0 的之前版本，可通过 –without-pcre-regex 配置选项禁用此扩展。</p>\r\n<h1 id=\"h1--\"><a name=\"二. 预定义常量\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二. 预定义常量</h1><p>下列常量由此扩展定义，且仅在此扩展编译入 PHP 或在运行时动态载入时可用。</p>\r\n<table>\r\n<thead>\r\n<tr>\r\n<th>常量</th>\r\n<th>描述</th>\r\n<th>自哪个版本起</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr>\r\n<td>PREG_PATTERN_ORDER</td>\r\n<td>结果按照”规则”排序，仅用于preg_match_all()，即$matches[0]是完整规则的匹配结果，$matches[1]是第一个子组匹配的结果，等等。</td>\r\n<td>since</td>\r\n</tr>\r\n<tr>\r\n<td>PREG_SET_ORDER</td>\r\n<td>结果按照”集合”排序，仅用于preg_match_all()，即$matches[0]保存第一次匹配结果的所有结果(包含子组)信息, $matches[1]保存第二次的结果信息，等等。</td>\r\n<td></td>\r\n</tr>\r\n<tr>\r\n<td>PREG_OFFSET_CAPTURE</td>\r\n<td>查看PREG_SPLIT_OFFSET_CAPTURE的描述。</td>\r\n<td>4.3.0</td>\r\n</tr>\r\n<tr>\r\n<td>PREG_SPLIT_NO_EMPTY</td>\r\n<td>这个标记告诉preg_split()仅返回非空部分。</td>\r\n</tr>\r\n<tr>\r\n<td>PREG_SPLIT_DELIM_CAPTURE</td>\r\n<td>这个标记告诉preg_split()同时捕获括号表达式匹配到的内容。</td>\r\n<td>4.0.5</td>\r\n</tr>\r\n<tr>\r\n<td>PREG_SPLIT_OFFSET_CAPTURE</td>\r\n<td>如果设置了这个标记，每次出现的匹配子串的偏移量也会被返回。注意，这会改变返回数组中的值，每个元素都是由匹配子串作为第0个元素，它相对目标字符串的偏移量作为第1个元素的数组。这个标记只能用于preg_split()。</td>\r\n<td>4.3.0</td>\r\n</tr>\r\n<tr>\r\n<td>PREG_NO_ERROR</td>\r\n<td>没有匹配错误时调用 preg_last_error() 返回。</td>\r\n<td>5.2.0</td>\r\n</tr>\r\n<tr>\r\n<td>PREG_INTERNAL_ERROR</td>\r\n<td>如果有PCRE内部错误时调用 preg_last_error() 返回。</td>\r\n<td>5.2.0</td>\r\n</tr>\r\n<tr>\r\n<td>PREG_BACKTRACK_LIMIT_ERROR</td>\r\n<td>如果调用回溯限制超出，调用preg_last_error()时返回。</td>\r\n<td>5.2.0</td>\r\n</tr>\r\n<tr>\r\n<td>PREG_RECURSION_LIMIT_ERROR</td>\r\n<td>如果递归限制超出，调用preg_last_error()时返回。</td>\r\n<td>5.2.0</td>\r\n</tr>\r\n<tr>\r\n<td>PREG_BAD_UTF8_ERROR</td>\r\n<td>如果最后一个错误时由于异常的utf-8数据(仅在运行在UTF-8 模式正则表达式下可用)。导致的，调用preg_last_error()返回。</td>\r\n<td>5.2.0</td>\r\n</tr>\r\n<tr>\r\n<td>vPREG_BAD_UTF8_OFFSET_ERROR</td>\r\n<td>如果偏移量与合法的urf-8代码不匹配(仅在运行在UTF-8 模式正则表达式下可用)。调用preg_last_error()返回。</td>\r\n<td>5.3.0</td>\r\n</tr>\r\n<tr>\r\n<td>PREG_JIT_STACKLIMIT_ERROR</td>\r\n<td>当 PCRE 函数因 JIT 栈空间限制而失败， preg_last_error() 就会返回此常量。</td>\r\n<td>7.0.0</td>\r\n</tr>\r\n<tr>\r\n<td>PCRE_VERSION</td>\r\n<td>PCRE版本号和发布日期(比如： “7.0 18-Dec-2006”)。</td>\r\n<td>5.2.4</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<h1 id=\"h1--\"><a name=\"三 正则语法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>三 正则语法</h1><ol>\r\n<li>详细的正则语法可以参考：<a href=\"http://php.net/manual/zh/reference.pcre.pattern.syntax.php\" title=\"http://php.net/manual/zh/reference.pcre.pattern.syntax.php\">http://php.net/manual/zh/reference.pcre.pattern.syntax.php</a></li></ol>\r\n<h1 id=\"h1--pcre-\"><a name=\"四 PCRE 函数\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>四 PCRE 函数</h1><p>这篇文章的关注重点将在于函数，和函数的应用，即是正则在PHP中的具体实现。接下来一个一个看。</p>\r\n<h2 id=\"h2-1-preg_filter-\"><a name=\"1. preg_filter() 执行一个正则表达式搜索和替换\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1. preg_filter() 执行一个正则表达式搜索和替换</h2><ul>\r\n<li><p>语法：mixed preg_filter ( mixed $pattern , mixed $replacement , mixed $subject [, int $limit = -1 [, int &amp;$count ]] )</p>\r\n</li><li><p>说明：preg_filter()等价于preg_replace() 除了它仅仅返回(可能经过转化)与目标匹配的结果。</p>\r\n</li><li><p>返回值： 如果subject是一个数组，返回一个数组， 其他情况返回一个字符串。如果没有找到匹配或者发生了错误，当subject是数组 时返回一个空数组，其他情况返回NULL。</p>\r\n</li><li><p>例子：</p>\r\n</li></ul>\r\n<pre><code>&lt;?php\r\n$subject = array(&#39;1&#39;, &#39;a&#39;, &#39;2&#39;, &#39;b&#39;, &#39;3&#39;, &#39;A&#39;, &#39;B&#39;, &#39;4&#39;); \r\n$pattern = array(&#39;/\\d/&#39;, &#39;/[a-z]/&#39;, &#39;/[1a]/&#39;); \r\n$replace = array(&#39;A:$0&#39;, &#39;B:$0&#39;, &#39;C:$0&#39;); \r\n\r\nprint_r(preg_filter($pattern, $replace, $subject)); //使用filter\r\n\r\nprint_r(preg_replace($pattern, $replace, $subject)); //使用replace\r\n\r\n/*\r\n返回： \r\nArray\r\n(\r\n    [0] =&gt; A:C:1\r\n    [1] =&gt; B:C:a\r\n    [2] =&gt; A:2\r\n    [3] =&gt; B:b\r\n    [4] =&gt; A:3\r\n    [7] =&gt; A:4\r\n)\r\nArray\r\n(\r\n    [0] =&gt; A:C:1\r\n    [1] =&gt; B:C:a\r\n    [2] =&gt; A:2\r\n    [3] =&gt; B:b\r\n    [4] =&gt; A:3\r\n    [5] =&gt; A\r\n    [6] =&gt; B\r\n    [7] =&gt; A:4\r\n)\r\npreg_filter()只返回匹配到的；preg_replace() 返回所有\r\n*/\r\n</code></pre><h2 id=\"h2-2-preg_grep-\"><a name=\"2. preg_grep() 返回匹配模式的数组条目；正则检索一个数组的所有元素\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2. preg_grep() 返回匹配模式的数组条目；正则检索一个数组的所有元素</h2><ul>\r\n<li><p>语法：array preg_grep ( string $pattern , array $input [, int $flags = 0 ] )</p>\r\n</li><li><p>说明：返回给定数组input中与模式pattern 匹配的元素组成的数组.</p>\r\n</li><li><p>参数：</p>\r\n<ul>\r\n<li>pattern，要搜索的模式, 字符串形式.</li><li>input，输入数组.</li><li>flags，如果设置为PREG_GREP_INVERT, 这个函数返回输入数组中与 给定模式pattern不匹配的元素组成的数组</li></ul>\r\n</li><li><p>返回值：返回使用input中key做索引的数组。</p>\r\n</li><li><p>例子：</p>\r\n<pre><code class=\"lang-php\">&lt;?php\r\n// 找出有p的\r\n$foods = array(&quot;pasta&quot;, &quot;steak&quot;, &quot;fish&quot;, &quot;potatoes&quot;);\r\n$p_foods = preg_grep(&quot;/p(\\w+)/&quot;, $foods);\r\nprint_r($p_foods)\r\n// 输出\r\n// Array ( [0] =&gt; pasta [3] =&gt; potatoes )\r\n</code></pre>\r\n</li></ul>\r\n<h2 id=\"h2-3-preg_last_error-pcre-\"><a name=\"3. preg_last_error() 返回最后一个PCRE正则执行产生的错误代码\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3. preg_last_error() 返回最后一个PCRE正则执行产生的错误代码</h2><ul>\r\n<li><p>语法：int preg_last_error ( void )</p>\r\n</li><li><p>返回值：返回最后一次PCRE正则执行的错误代码。</p>\r\n<ul>\r\n<li>PREG_NO_ERROR 没有匹配错误</li><li>PREG_INTERNAL_ERROR 有PCRE内部错误</li><li>PREG_BACKTRACK_LIMIT_ERROR 调用回溯限制超出</li><li>PREG_RECURSION_LIMIT_ERROR 递归限制超出</li><li>PREG_BAD_UTF8_ERROR 异常的utf-8数据导致</li><li>PREG_BAD_UTF8_OFFSET_ERROR （自 PHP 5.3.0 起） 偏移量与合法的urf-8代码不匹配</li><li>PREG_JIT_STACKLIMIT_ERROR (自 PHP 7.0.0 起) 因 JIT 栈空间限制而失败<br>具体错误代码的详情在上面预定义常量部分。</li></ul>\r\n</li><li><p>例子：</p>\r\n</li></ul>\r\n<pre><code class=\"lang-php\">&lt;?php\r\n$a = preg_match(&#39;/(?:\\D+|&lt;\\d+&gt;)*[!?]/&#39;, &#39;foobar foobar foobar&#39;);\r\nprint_r($a);\r\n\r\nif (preg_last_error() == PREG_BACKTRACK_LIMIT_ERROR) {\r\n    print &#39;Backtrack limit was exhausted!&#39;;\r\n}\r\n// 输出：Backtrack limit was exhausted!\r\n</code></pre>\r\n<h2 id=\"h2-4-preg_match-\"><a name=\"4. preg_match() 执行匹配正则表达式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4. preg_match() 执行匹配正则表达式</h2><ul>\r\n<li><p>语法：int preg_match ( string $pattern , string $subject [, array &amp;$matches [, int $flags = 0 [, int $offset = 0 ]]] )</p>\r\n</li><li><p>说明：搜索subject与pattern给定的正则表达式的一个匹配。</p>\r\n</li><li><p>参数：</p>\r\n<ul>\r\n<li>pattern，要搜索的模式，字符串类型。</li><li>subject，输入字符串。</li><li>matches，如果提供了参数matches，它将被填充为搜索结果。 $matches[0]将包含完整模式匹配到的文本， $matches[1] 将包含第一个捕获子组匹配到的文本，以此类推。</li><li>flags，flags可以被设置为以下标记值：<br>  ○ PREG_OFFSET_CAPTURE，如果传递了这个标记，对于每一个出现的匹配返回时会附加字符串偏移量(相对于目标字符串的)。 注意：这会改变填充到matches参数的数组，使其每个元素成为一个由 第0个元素是匹配到的字符串，第1个元素是该匹配字符串 在目标字符串subject中的偏移量。</li><li>offset，通常，搜索从目标字符串的开始位置开始。可选参数 offset 用于 指定从目标字符串的某个位置开始搜索(单位是字节)。</li></ul>\r\n</li><li><p>返回值：preg_match()返回 pattern 的匹配次数。 它的值将是0次（不匹配）或1次，因为preg_match()在第一次匹配后 将会停止搜索。preg_match_all()不同于此，它会一直搜索subject 直到到达结尾。 如果发生错误preg_match()返回 FALSE。</p>\r\n</li><li><p>例子：</p>\r\n</li></ul>\r\n<pre><code class=\"lang-php\">&lt;?php\r\n//从URL中获取主机名称\r\npreg_match(&#39;@^(?:http://)?([^/]+)@i&#39;, &quot;http://www.php.net/index.html&quot;, $matches);\r\nprint_r($matches);\r\n// 输出 Array ( [0] =&gt; http://www.php.net [1] =&gt; www.php.net )\r\n\r\npreg_match(&#39;/[^.]+\\.[^.]+$/&#39;, $matches[1], $matches);\r\nprint_r($matches);\r\n// 输出 Array ( [0] =&gt; php.net )\r\n</code></pre>\r\n<h2 id=\"h2-5-preg_match_all-\"><a name=\"5. preg_match_all() 执行一个全局正则表达式匹配\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5. preg_match_all() 执行一个全局正则表达式匹配</h2><ul>\r\n<li><p>语法：int preg_match_all ( string $pattern , string $subject [, array &amp;$matches [, int $flags = PREG_PATTERN_ORDER [, int $offset = 0 ]]] )</p>\r\n</li><li><p>说明： 搜索subject中所有匹配pattern给定正则表达式的匹配结果并且将它们以flag指定顺序输出到matches中。在第一个匹配找到后，子序列继续从最后一次匹配位置搜索。</p>\r\n</li><li><p>参数：</p>\r\n<ul>\r\n<li>pattern，要搜索的模式，字符串形式。</li><li>subject，输入字符串。</li><li>matches，多维数组，作为输出参数输出所有匹配结果, 数组排序通过flags指定。</li><li>flags，可以结合下面标记使用(注意不能同时使用PREG_PATTERN_ORDER和PREG_SET_ORDER)<ul>\r\n<li>PREG_PATTERN_ORDER 结果排序为$matches[0]保存完整模式的所有匹配, $matches[1] 保存第一个子组的所有匹配，以此类推。</li><li>PREG_SET_ORDER 结果排序为$matches[0]包含第一次匹配得到的所有匹配(包含子组)， $matches[1]是包含第二次匹配到的所有匹配(包含子组)的数组，以此类推。</li><li>PREG_OFFSET_CAPTURE 如果这个标记被传递，每个发现的匹配返回时会增加它相对目标字符串的偏移量。 注意这会改变matches中的每一个匹配结果字符串元素，使其 成为一个第0个元素为匹配结果字符串，第1个元素为 匹配结果字符串在subject中的偏移量。</li><li>如果没有给定排序标记，假定设置为PREG_PATTERN_ORDER。</li></ul>\r\n</li><li>offset，通常， 查找时从目标字符串的开始位置开始。可选参数offset用于 从目标字符串中指定位置开始搜索(单位是字节)。</li></ul>\r\n</li><li><p>返回值：返回完整匹配次数（可能是0），或者如果发生错误返回FALSE。</p>\r\n</li><li><p>例子：</p>\r\n</li></ul>\r\n<pre><code>&lt;?php\r\n// \\\\2是一个后向引用的示例. 这会告诉pcre它必须匹配正则表达式中第二个圆括号(这里是([\\w]+))\r\n// 匹配到的结果. 这里使用两个反斜线是因为这里使用了双引号.\r\n$html = &quot;&lt;b&gt;bold text&lt;/b&gt;&lt;a href=howdy.html&gt;click me&lt;/a&gt;&quot;;\r\npreg_match_all(&quot;/(&lt;([\\w]+)[^&gt;]*&gt;)(.*?)(&lt;\\/\\\\2&gt;)/&quot;, $html, $matches, PREG_SET_ORDER);\r\nprint_r($matches);\r\n/*\r\n输出\r\nArray\r\n(\r\n    [0] =&gt; Array\r\n        (\r\n            [0] =&gt; &lt;b&gt;bold text&lt;/b&gt;\r\n            [1] =&gt; &lt;b&gt;\r\n            [2] =&gt; b\r\n            [3] =&gt; bold text\r\n            [4] =&gt; &lt;/b&gt;\r\n        )\r\n\r\n    [1] =&gt; Array\r\n        (\r\n            [0] =&gt; &lt;a href=howdy.html&gt;click me&lt;/a&gt;\r\n            [1] =&gt; &lt;a href=howdy.html&gt;\r\n            [2] =&gt; a\r\n            [3] =&gt; click me\r\n            [4] =&gt; &lt;/a&gt;\r\n        )\r\n\r\n)\r\n*/\r\n</code></pre><h2 id=\"h2-6-preg_quote-\"><a name=\"6. preg_quote() 转义正则表达式字符\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>6. preg_quote() 转义正则表达式字符</h2><ul>\r\n<li><p>语法：string preg_quote ( string $str [, string $delimiter = NULL ] )</p>\r\n</li><li><p>说明： preg_quote()需要参数 str 并向其中每个正则表达式语法中的字符前增加一个反斜线。 这通常用于你有一些运行时字符串需要作为正则表达式进行匹配的时候。</p>\r\n<ul>\r\n<li>正则表达式特殊字符有： . \\ + * ? [ ^ ] $ ( ) { } = ! &lt; &gt; | : –</li><li>注意 / 不是正则表达式特殊字符。</li></ul>\r\n</li><li><p>注意：preg_quote() 的应用场景不是用于 preg_replace() 的 $replacement 字符串参数。</p>\r\n</li><li><p>参数：</p>\r\n<ul>\r\n<li>str，输入字符串</li><li>delimiter，如果指定了可选参数 delimiter，它也会被转义。这通常用于 转义PCRE函数使用的分隔符。 / 是最常见的分隔符。</li></ul>\r\n</li><li><p>返回值：返回转义后的字符串。</p>\r\n</li><li><p>例子：</p>\r\n<pre><code>&lt;?php\r\n$keywords = &#39;$40 for a g3/400&#39;;\r\n$keywords = preg_quote($keywords, &#39;/&#39;);\r\necho $keywords; \r\n// 返回 \\$40 for a g3\\/400\r\n// $是正则表达式特殊字符, /被当参数传入也转义\r\n</code></pre></li></ul>\r\n<h2 id=\"h2-7-preg_replace_callback-\"><a name=\"7. preg_replace_callback() 执行一个正则表达式搜索并且使用一个回调进行替换\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>7. preg_replace_callback() 执行一个正则表达式搜索并且使用一个回调进行替换</h2><ul>\r\n<li><p>语法：mixed preg_replace_callback ( mixed $pattern , callable $callback , mixed $subject [, int $limit = -1 [, int &amp;$count ]] )</p>\r\n</li><li><p>说明：这个函数的行为除了 可以指定一个 callback 替代 replacement 进行替换 字符串的计算，其他方面等同于 preg_replace()。</p>\r\n</li><li><p>参数：</p>\r\n<ul>\r\n<li>pattern，要搜索的模式，可以使字符串或一个字符串数组。</li><li>callback， 一个回调函数，在每次需要替换时调用，调用时函数得到的参数是从subject 中匹配到的结果。回调函数返回真正参与替换的字符串。这是该回调函数的签名：string handler ( array $matches ) 。你可能经常会需要callback函数而 仅用于preg_replace_callback()一个地方的调用。在这种情况下，你可以 使用匿名函数来定义一个匿名函数作 为preg_replace_callback()调用时的回调。 这样做你可以保留所有 调用信息在同一个位置并且不会因为一个不在任何其他地方使用的回调函数名称而污染函数名称空间。<ul>\r\n<li>subject，要搜索替换的目标字符串或字符串数组。</li><li>limit，对于每个模式用于每个 subject 字符串的最大可替换次数。 默认是-1（无限制）。</li><li>count，如果指定，这个变量将被填充为替换执行的次数。</li></ul>\r\n</li></ul>\r\n</li><li><p>返回值： 如果subject是一个数组， preg_replace_callback()返回一个数组，其他情况返回字符串。 错误发生时返回 NULL。如果查找到了匹配，返回替换后的目标字符串（或字符串数组）， 其他情况subject 将会无变化返回。</p>\r\n</li></ul>\r\n<p>例子：</p>\r\n<pre><code>&lt;?php\r\n/* 将文本中的年份增加一年 */\r\n$text = &quot;April fools day is 04/01/2002\\n&quot;;\r\n$text.= &quot;Last christmas was 12/24/2001\\n&quot;;\r\n// 回调函数\r\nfunction next_year($matches)\r\n{\r\n    /*\r\n    print_r($matches);$matches为:\r\n    Array\r\n    (\r\n        [0] =&gt; 04/01/2002\r\n        [1] =&gt; 04/01/\r\n        [2] =&gt; 2002\r\n    )\r\n    Array\r\n    (\r\n        [0] =&gt; 12/24/2001\r\n        [1] =&gt; 12/24/\r\n        [2] =&gt; 2001\r\n    )\r\n    说明匹配到一个就扔进来一次\r\n    */\r\n    return $matches[1].($matches[2]+1);\r\n}\r\n$text = preg_replace_callback(&quot;|(\\d{2}/\\d{2}/)(\\d{4})|&quot;, &quot;next_year&quot;, $text);\r\necho $text;\r\n/*\r\n输出\r\nApril fools day is 04/01/2003\r\nLast christmas was 12/24/2002\r\n*/\r\n</code></pre><h2 id=\"h2-8-preg_replace_callback_array-\"><a name=\"8. preg_replace_callback_array() 执行一个正则表达式搜索并且使用多个回调进行替换\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>8. preg_replace_callback_array() 执行一个正则表达式搜索并且使用多个回调进行替换</h2><ul>\r\n<li><p>语法：mixed preg_replace_callback_array ( array $patterns_and_callbacks , mixed $subject [, int $limit = -1 [, int &amp;$count ]] )</p>\r\n</li><li><p>说明：类似于 preg_replace_callback(), 除了回调函数是基于每个参数。</p>\r\n</li><li><p>参数：</p>\r\n<ul>\r\n<li>patterns_and_callbacks，参数（keys）对应回调函数（values）的数组。</li><li>subject，要搜索替换的目标字符串或字符串数组。</li><li>limit，对于每个模式用于每个 subject 字符串的最大可替换次数。 默认是-1（无限制）。</li><li>count，如果指定，这个变量将被填充为替换执行的次数。</li></ul>\r\n</li><li><p>返回值：<br>preg_replace_callback_array() 如果参数是数组则会返回一个数组，否则为字符串。出错时返回 NULL；如果匹配到，会返回一个新的subject</p>\r\n</li><li><p>例子：</p>\r\n<pre><code class=\"lang-php\">&lt;?php\r\n$subject = &#39;Aaaaaa Bbb&#39;;\r\npreg_replace_callback_array(\r\n  [\r\n      &#39;~[a]+~i&#39; =&gt; function ($match) {\r\n          echo strlen($match[0]), &#39; matches for &quot;a&quot; found&#39;, PHP_EOL;\r\n      },\r\n      &#39;~[b]+~i&#39; =&gt; function ($match) {\r\n          echo strlen($match[0]), &#39; matches for &quot;b&quot; found&#39;, PHP_EOL;\r\n      }\r\n  ],\r\n  $subject\r\n);\r\n/*\r\n输出\r\n6 matches for &quot;a&quot; found\r\n3 matches for &quot;b&quot; found\r\n*/\r\n</code></pre>\r\n</li></ul>\r\n<h2 id=\"h2-9-preg_replace-\"><a name=\"9. preg_replace() 执行一个正则表达式的搜索和替换\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>9. preg_replace() 执行一个正则表达式的搜索和替换</h2><ul>\r\n<li><p>语法：mixed preg_replace ( mixed $pattern , mixed $replacement , mixed $subject [, int $limit = -1 [, int &amp;$count ]] )</p>\r\n</li><li><p>说明：搜索subject中匹配pattern的部分， 以replacement进行替换。</p>\r\n</li><li><p>参数：</p>\r\n<ul>\r\n<li>pattern，要搜索的模式。可以使一个字符串或字符串数组。 可以使用一些PCRE修饰符。</li><li>replacement，用于替换的字符串或字符串数组。如果这个参数是一个字符串，并且pattern 是一个数组，那么所有的模式都使用这个字符串进行替换。如果pattern和replacement 都是数组，每个pattern使用replacement中对应的 元素进行替换。如果replacement中的元素比pattern中的少， 多出来的pattern使用空字符串进行替换。replacement中可以包含后向引用\\n 或$n，语法上首选后者。 每个 这样的引用将被匹配到的第n个捕获子组捕获到的文本替换。 n 可以是0-99，\\0和$0代表完整的模式匹配文本。 捕获子组的序号计数方式为：代表捕获子组的左括号从左到右， 从1开始数。如果要在replacement 中使用反斜线，必须使用4个(“\\\\”，译注：因为这首先是php的字符串，经过转义后，是两个，再经过 正则表达式引擎后才被认为是一个原文反斜线)。当在替换模式下工作并且后向引用后面紧跟着需要是另外一个数字(比如：在一个匹配模式后紧接着增加一个原文数字)， 不能使用\\1这样的语法来描述后向引用。比如， \\11将会使preg_replace() 不能理解你希望的是一个\\1后向引用紧跟一个原文1，还是 一个\\11后向引用后面不跟任何东西。 这种情况下解决方案是使用${1}1。 这创建了一个独立的$1后向引用, 一个独立的原文1。当使用被弃用的 e 修饰符时, 这个函数会转义一些字符(即：’、”、 \\ 和 NULL) 然后进行后向引用替换。当这些完成后请确保后向引用解析完后没有单引号或 双引号引起的语法错误(比如： ‘strlen(\\’$1\\’)+strlen(“$2”)’)。确保符合PHP的 字符串语法，并且符合eval语法。因为在完成替换后， 引擎会将结果字符串作为php代码使用eval方式进行评估并将返回值作为最终参与替换的字符串。</li><li>subject，要进行搜索和替换的字符串或字符串数组。如果subject是一个数组，搜索和替换回在subject 的每一个元素上进行, 并且返回值也会是一个数组。</li><li>limit，每个模式在每个subject上进行替换的最大次数。默认是 -1(无限)。</li><li>count，如果指定，将会被填充为完成的替换次数。</li></ul>\r\n</li><li><p>返回值： 如果subject是一个数组， preg_replace()返回一个数组， 其他情况下返回一个字符串。如果匹配被查找到，替换后的subject被返回，其他情况下 返回没有改变的 subject。如果发生错误，返回 NULL 。</p>\r\n</li><li><p>例子：</p>\r\n<pre><code class=\"lang-php\">&lt;?php\r\n$patterns = array (&#39;/(19|20)(\\d{2})-(\\d{1,2})-(\\d{1,2})/&#39;, &#39;/^\\s*{(\\w+)}\\s*=/&#39;);\r\n$replace = array (&#39;\\3/\\4/\\1\\2&#39;, &#39;$\\1 =&#39;);\r\necho preg_replace($patterns, $replace, &#39;{startDate} = 1999-5-27&#39;);\r\n// 输出: $startDate = 5/27/1999\r\n</code></pre>\r\n</li></ul>\r\n<h2 id=\"h2-10-preg_split-\"><a name=\"10. preg_split() 通过一个正则表达式分隔字符串\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>10. preg_split() 通过一个正则表达式分隔字符串</h2><ul>\r\n<li><p>语法：array preg_split ( string $pattern , string $subject [, int $limit = -1 [, int $flags = 0 ]] )</p>\r\n</li><li><p>说明：通过一个正则表达式分隔给定字符串.</p>\r\n</li><li><p>参数：</p>\r\n<ul>\r\n<li>pattern，用于搜索的模式，字符串形式。</li><li>subject，输入字符串</li><li>limit，如果指定，将限制分隔得到的子串最多只有limit个，返回的最后一个 子串将包含所有剩余部分。limit值为-1， 0或null时都代表”不限制”， 作为php的标准，你可以使用null跳过对flags的设置。</li><li>flags，flags 可以是任何下面标记的组合(以位或运算 | 组合)：<ul>\r\n<li>PREG_SPLIT_NO_EMPTY，如果这个标记被设置， preg_split() 将进返回分隔后的非空部分。</li><li>PREG_SPLIT_DELIM_CAPTURE，如果这个标记设置了，用于分隔的模式中的括号表达式将被捕获并返回。</li><li>PREG_SPLIT_OFFSET_CAPTURE，如果这个标记被设置, 对于每一个出现的匹配返回时将会附加字符串偏移量. 注意：这将会改变返回数组中的每一个元素, 使其每个元素成为一个由第0 个元素为分隔后的子串，第1个元素为该子串在subject 中的偏移量组成的数组。</li></ul>\r\n</li></ul>\r\n</li><li><p>返回值：返回一个使用 pattern 边界分隔 subject 后得到 的子串组成的数组， 或者在失败时返回 FALSE。</p>\r\n</li><li><p>例子：</p>\r\n<pre><code class=\"lang-php\">&lt;?php\r\n$keywords = preg_split (&quot;/[\\s,]+/&quot;, &quot;hypertext language, programming&quot;); \r\nprint_r($keywords);\r\n// 输出\r\n// Array ( [0] =&gt; hypertext [1] =&gt; language [2] =&gt; programming )\r\n</code></pre>\r\n</li></ul>\r\n', '', 0, 'publish', 1, 0, '/article/55.html', '', 0, 102, '2017-07-13 06:35:18', '2017-07-13 06:35:18', '2018-01-10 17:37:19', NULL);
INSERT INTO `pt_post` VALUES (56, 10, 'article', 'Guzzle：PHP的HTTP客户端', '# 1. 什么是Guzzle？\r\nGuzzle是一个PHP的HTTP客户端，用来轻而易举地发送请求，并集成到我们的WEB服务上。\r\n- 接口简单：构建查询语句、POST请求、分流上传下载大文件、使用HTTP cookies、上传JSON数据等等。\r\n- 发送同步或异步的请求均使用相同的接口。\r\n- 使用PSR-7接口来请求、响应、分流，允许你使用其他兼容的PSR-7类库与Guzzle共同开发。\r\n- 抽象了底层的HTTP传输，允许你改变环境以及其他的代码，如：对cURL与PHP的流或socket并非重度依赖，非阻塞事件循环。\r\n- 中间件系统允许你创建构成客户端行为。\r\n\r\nGithub地址：[guzzle/guzzle](https://github.com/guzzle/guzzle/ \"guzzle/guzzle\")\r\n\r\n官方文档：[http://docs.guzzlephp.org/en/stable/](http://docs.guzzlephp.org/en/stable/ \"http://docs.guzzlephp.org/en/stable/\")\r\n\r\n中文文档：[http://guzzle-cn.readthedocs.io/zh_CN/latest/](http://guzzle-cn.readthedocs.io/zh_CN/latest/ \"http://guzzle-cn.readthedocs.io/zh_CN/latest/\")\r\n\r\n# 2. 安装Guzzle\r\n## 2.1 通过composer安装\r\n\r\n执行composer命令：\r\n```\r\nphp composer.phar require guzzlehttp/guzzle\r\n```\r\n\r\n引入Composer自动加载类：\r\n```\r\nrequire ‘vendor/autoload.php’;\r\n```\r\n通过Composer更新Guzzle：\r\n```\r\ncomposer.phar update\r\n```\r\n\r\n# 3. 例子\r\n```php\r\n$client = new \\GuzzleHttp\\Client();\r\n$res = $client->request(\'GET\', \'https://api.github.com/repos/guzzle/guzzle\');\r\necho $res->getStatusCode();\r\n// 200\r\necho $res->getHeaderLine(\'content-type\');\r\n// \'application/json; charset=utf8\'\r\necho $res->getBody();\r\n// \'{\"id\": 1420053, \"name\": \"guzzle\", ...}\'\r\n\r\n// 发送一个异步请求\r\n$request = new \\GuzzleHttp\\Psr7\\Request(\'GET\', \'http://httpbin.org\');\r\n$promise = $client->sendAsync($request)->then(function ($response) {\r\n    echo \'I completed! \' . $response->getBody();\r\n});\r\n$promise->wait();\r\n```\r\n\r\n# 4. 发送请求\r\n## 4.1 创建客户端\r\n通过实例化Client类创建一个客户端：\r\n```php\r\n<?php\r\nuse GuzzleHttp\\Client;\r\n\r\n$client = new Client([\r\n    // 基URI\r\n    \'base_uri\' => \'http://httpbin.org\',\r\n    // 设置默认请求参数\r\n    \'timeout\'  => 2.0,\r\n]);\r\n```\r\n\r\n## 4.2 发送请求\r\nClient对象的方法可以很容易的发送请求：\r\n```php\r\n<?php \r\n$response = $client->get(\'http://httpbin.org/get\');\r\n$response = $client->delete(\'http://httpbin.org/delete\');\r\n$response = $client->head(\'http://httpbin.org/get\');\r\n$response = $client->options(\'http://httpbin.org/get\');\r\n$response = $client->patch(\'http://httpbin.org/patch\');\r\n$response = $client->post(\'http://httpbin.org/post\');\r\n$response = $client->put(\'http://httpbin.org/put\');\r\n```\r\n或者创建一个请求，一切就绪后再发送请求：\r\n```php\r\n<?php\r\nuse GuzzleHttp\\Psr7\\Request;\r\n\r\n$request = new Request(\'PUT\', \'http://httpbin.org/put\');\r\n$response = $client->send($request, [\'timeout\' => 2]);\r\n```\r\n\r\n## 4.3 异步请求\r\n直接用Client提供的方法来创建异步请求：\r\n```php\r\n<?php \r\n$promise = $client->getAsync(\'http://httpbin.org/get\');\r\n$promise = $client->deleteAsync(\'http://httpbin.org/delete\');\r\n$promise = $client->headAsync(\'http://httpbin.org/get\');\r\n$promise = $client->optionsAsync(\'http://httpbin.org/get\');\r\n$promise = $client->patchAsync(\'http://httpbin.org/patch\');\r\n$promise = $client->postAsync(\'http://httpbin.org/post\');\r\n$promise = $client->putAsync(\'http://httpbin.org/put\');\r\n```\r\n\r\n或者使用Client的 sendAsync() and requestAsync() 方法：\r\n```php\r\n<?php \r\n// 创建一个PSR-7请求对象 $headers = [\'X-Foo\' => \'Bar\'];\r\n$body = \'Hello!\';\r\n$request = new Request(\'HEAD\', \'http://httpbin.org/head\', $headers, $body);\r\n\r\n// 如果不需要进去请求实例\r\n$promise = $client->requestAsync(\'GET\', \'http://httpbin.org/get\');\r\n```\r\n\r\n使用 then() 来调用返回值，成功使用 Psr\\Http\\Message\\ResponseInterface 处理器，否则抛出一个异常：\r\n```php\r\n<?php\r\nuse Psr\\Http\\Message\\ResponseInterface;\r\nuse GuzzleHttp\\Exception\\RequestException;\r\n\r\n$promise = $client->requestAsync(\'GET\', \'http://httpbin.org/get\');\r\n$promise->then(\r\n    function (ResponseInterface $res) {\r\n        echo $res->getStatusCode() . \"\\n\";\r\n    },\r\n    function (RequestException $e) {\r\n        echo $e->getMessage() . \"\\n\";\r\n        echo $e->getRequest()->getMethod();\r\n    }\r\n);\r\n```\r\n\r\n## 4.4 并发请求\r\n使用Promise和异步请求来同时发送多个请求：\r\n```php\r\n<?php\r\nuse GuzzleHttp\\Client;\r\nuse GuzzleHttp\\Promise;\r\n\r\n$client = new Client([\'base_uri\' => \'http://httpbin.org/\']);\r\n\r\n// 初始化每一个非阻塞请求\r\n$promises = [\r\n    \'image\' => $client->getAsync(\'/image\'),\r\n    \'png\'   => $client->getAsync(\'/image/png\'),\r\n    \'jpeg\'  => $client->getAsync(\'/image/jpeg\'),\r\n    \'webp\'  => $client->getAsync(\'/image/webp\')\r\n];\r\n\r\n// 等待请求完成\r\n$results = Promise\\unwrap($promises);\r\n\r\n// 通过键名接收每一个结果\r\n// function.\r\necho $results[\'image\']->getHeader(\'Content-Length\');\r\necho $results[\'png\']->getHeader(\'Content-Length\');\r\n```\r\n\r\n当你想发送不确定数量的请求时，可以使用 GuzzleHttp\\Pool 对象：\r\n```php\r\n<?php\r\nuse GuzzleHttp\\Pool;\r\nuse GuzzleHttp\\Client;\r\nuse GuzzleHttp\\Psr7\\Request;\r\n\r\n$client = new Client();\r\n\r\n$requests = function ($total) {\r\n    $uri = \'http://127.0.0.1:8126/guzzle-server/perf\';\r\n    for ($i = 0; $i < $total; $i++) {\r\n        yield new Request(\'GET\', $uri);\r\n    }\r\n};\r\n\r\n$pool = new Pool($client, $requests(100), [\r\n    \'concurrency\' => 5,\r\n    \'fulfilled\' => function ($response, $index) {\r\n        // 每个成功的请求\r\n    },\r\n    \'rejected\' => function ($reason, $index) {\r\n        // 每个失败的请求\r\n    },\r\n]);\r\n\r\n// 初始化传输和创建授权\r\n$promise = $pool->promise();\r\n\r\n// 等待请求池完成\r\n$promise->wait();\r\n```\r\n\r\n# 5. 响应\r\n## 5.1 获取响应的状态码\r\n```\r\n$code = $response->getStatusCode(); // 200\r\n```\r\n\r\n## 5.2 获取原因短语(reason phrase)\r\n```\r\n$reason = $response->getReasonPhrase(); // OK\r\n```\r\n\r\n## 5.3 获取头信息(header)\r\n```php\r\n// 检查是否存在头信息\r\nif ($response->hasHeader(\'Content-Length\')) {\r\n    echo \"It exists\";\r\n}\r\n\r\n// 获取头信息\r\necho $response->getHeader(\'Content-Length\');\r\n\r\n// 获取所有响应头信息\r\nforeach ($response->getHeaders() as $name => $values) {\r\n    echo $name . \': \' . implode(\', \', $values) . \"\\r\\n\";\r\n}\r\n```\r\n\r\n## 5.4 获取响应的主体部分(body)\r\n```php\r\n$body = $response->getBody();\r\n// 隐式转换成字符串并输出\r\necho $body;\r\n// 显示转换body成字符串\r\n$stringBody = (string) $body;\r\n// 从body中读取10字节（bytes）\r\n$tenBytes = $body->read(10);\r\n// 将正文的剩余内容作为字符串读取\r\n$remainingBytes = $body->getContents();\r\n```\r\n\r\n# 6. 参数\r\n## 6.1 在请求的URI中设置查询字符串\r\n```\r\n$response = $client->request(\'GET\', \'http://httpbin.org?foo=bar\');\r\n```\r\n\r\n## 6.2 使用 query 请求参数来声明查询字符串参数\r\n```\r\n$client->request(\'GET\', \'http://httpbin.org\', [\r\n    \'query\' => [\'foo\' => \'bar\']\r\n]);\r\n```\r\n\r\n## 6.3 提供一个字符串作为 query 请求参数\r\n```\r\n$client->request(\'GET\', \'http://httpbin.org\', [\'query\' => \'foo=bar\']);\r\n```\r\n\r\n# 7. 其它\r\nGuzzle还提供了一些其它有用的功能\r\n   - 上传数据（[http://docs.guzzlephp.org/en/stable/quickstart.html#uploading-data](http://docs.guzzlephp.org/en/stable/quickstart.html#uploading-data \"http://docs.guzzlephp.org/en/stable/quickstart.html#uploading-data\")）\r\n   - POST/表单请求（[http://docs.guzzlephp.org/en/stable/quickstart.html#post-form-requests](http://docs.guzzlephp.org/en/stable/quickstart.html#post-form-requests \"http://docs.guzzlephp.org/en/stable/quickstart.html#post-form-requests\")）\r\n   - Cookies（[http://docs.guzzlephp.org/en/stable/quickstart.html#cookies](http://docs.guzzlephp.org/en/stable/quickstart.html#cookies \"http://docs.guzzlephp.org/en/stable/quickstart.html#cookies\")）\r\n   - 重定向（[http://docs.guzzlephp.org/en/stable/quickstart.html#redirects](http://docs.guzzlephp.org/en/stable/quickstart.html#redirects \"http://docs.guzzlephp.org/en/stable/quickstart.html#redirects\")）\r\n   - 异常（[http://docs.guzzlephp.org/en/stable/quickstart.html#exceptions](http://docs.guzzlephp.org/en/stable/quickstart.html#exceptions \"http://docs.guzzlephp.org/en/stable/quickstart.html#exceptions\")）\r\n\r\n具体的可以查看官方文档。\r\n', '<h1 id=\"h1-1-guzzle-\"><a name=\"1. 什么是Guzzle？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1. 什么是Guzzle？</h1><p>Guzzle是一个PHP的HTTP客户端，用来轻而易举地发送请求，并集成到我们的WEB服务上。</p>\r\n<ul>\r\n<li>接口简单：构建查询语句、POST请求、分流上传下载大文件、使用HTTP cookies、上传JSON数据等等。</li><li>发送同步或异步的请求均使用相同的接口。</li><li>使用PSR-7接口来请求、响应、分流，允许你使用其他兼容的PSR-7类库与Guzzle共同开发。</li><li>抽象了底层的HTTP传输，允许你改变环境以及其他的代码，如：对cURL与PHP的流或socket并非重度依赖，非阻塞事件循环。</li><li>中间件系统允许你创建构成客户端行为。</li></ul>\r\n<p>Github地址：<a href=\"https://github.com/guzzle/guzzle/\" title=\"guzzle/guzzle\">guzzle/guzzle</a></p>\r\n<p>官方文档：<a href=\"http://docs.guzzlephp.org/en/stable/\" title=\"http://docs.guzzlephp.org/en/stable/\">http://docs.guzzlephp.org/en/stable/</a></p>\r\n<p>中文文档：<a href=\"http://guzzle-cn.readthedocs.io/zh_CN/latest/\" title=\"http://guzzle-cn.readthedocs.io/zh_CN/latest/\">http://guzzle-cn.readthedocs.io/zh_CN/latest/</a></p>\r\n<h1 id=\"h1-2-guzzle\"><a name=\"2. 安装Guzzle\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2. 安装Guzzle</h1><h2 id=\"h2-2-1-composer-\"><a name=\"2.1 通过composer安装\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.1 通过composer安装</h2><p>执行composer命令：</p>\r\n<pre><code>php composer.phar require guzzlehttp/guzzle\r\n</code></pre><p>引入Composer自动加载类：</p>\r\n<pre><code>require ‘vendor/autoload.php’;\r\n</code></pre><p>通过Composer更新Guzzle：</p>\r\n<pre><code>composer.phar update\r\n</code></pre><h1 id=\"h1-3-\"><a name=\"3. 例子\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3. 例子</h1><pre><code class=\"lang-php\">$client = new \\GuzzleHttp\\Client();\r\n$res = $client-&gt;request(&#39;GET&#39;, &#39;https://api.github.com/repos/guzzle/guzzle&#39;);\r\necho $res-&gt;getStatusCode();\r\n// 200\r\necho $res-&gt;getHeaderLine(&#39;content-type&#39;);\r\n// &#39;application/json; charset=utf8&#39;\r\necho $res-&gt;getBody();\r\n// &#39;{&quot;id&quot;: 1420053, &quot;name&quot;: &quot;guzzle&quot;, ...}&#39;\r\n\r\n// 发送一个异步请求\r\n$request = new \\GuzzleHttp\\Psr7\\Request(&#39;GET&#39;, &#39;http://httpbin.org&#39;);\r\n$promise = $client-&gt;sendAsync($request)-&gt;then(function ($response) {\r\n    echo &#39;I completed! &#39; . $response-&gt;getBody();\r\n});\r\n$promise-&gt;wait();\r\n</code></pre>\r\n<h1 id=\"h1-4-\"><a name=\"4. 发送请求\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4. 发送请求</h1><h2 id=\"h2-4-1-\"><a name=\"4.1 创建客户端\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.1 创建客户端</h2><p>通过实例化Client类创建一个客户端：</p>\r\n<pre><code class=\"lang-php\">&lt;?php\r\nuse GuzzleHttp\\Client;\r\n\r\n$client = new Client([\r\n    // 基URI\r\n    &#39;base_uri&#39; =&gt; &#39;http://httpbin.org&#39;,\r\n    // 设置默认请求参数\r\n    &#39;timeout&#39;  =&gt; 2.0,\r\n]);\r\n</code></pre>\r\n<h2 id=\"h2-4-2-\"><a name=\"4.2 发送请求\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.2 发送请求</h2><p>Client对象的方法可以很容易的发送请求：</p>\r\n<pre><code class=\"lang-php\">&lt;?php \r\n$response = $client-&gt;get(&#39;http://httpbin.org/get&#39;);\r\n$response = $client-&gt;delete(&#39;http://httpbin.org/delete&#39;);\r\n$response = $client-&gt;head(&#39;http://httpbin.org/get&#39;);\r\n$response = $client-&gt;options(&#39;http://httpbin.org/get&#39;);\r\n$response = $client-&gt;patch(&#39;http://httpbin.org/patch&#39;);\r\n$response = $client-&gt;post(&#39;http://httpbin.org/post&#39;);\r\n$response = $client-&gt;put(&#39;http://httpbin.org/put&#39;);\r\n</code></pre>\r\n<p>或者创建一个请求，一切就绪后再发送请求：</p>\r\n<pre><code class=\"lang-php\">&lt;?php\r\nuse GuzzleHttp\\Psr7\\Request;\r\n\r\n$request = new Request(&#39;PUT&#39;, &#39;http://httpbin.org/put&#39;);\r\n$response = $client-&gt;send($request, [&#39;timeout&#39; =&gt; 2]);\r\n</code></pre>\r\n<h2 id=\"h2-4-3-\"><a name=\"4.3 异步请求\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.3 异步请求</h2><p>直接用Client提供的方法来创建异步请求：</p>\r\n<pre><code class=\"lang-php\">&lt;?php \r\n$promise = $client-&gt;getAsync(&#39;http://httpbin.org/get&#39;);\r\n$promise = $client-&gt;deleteAsync(&#39;http://httpbin.org/delete&#39;);\r\n$promise = $client-&gt;headAsync(&#39;http://httpbin.org/get&#39;);\r\n$promise = $client-&gt;optionsAsync(&#39;http://httpbin.org/get&#39;);\r\n$promise = $client-&gt;patchAsync(&#39;http://httpbin.org/patch&#39;);\r\n$promise = $client-&gt;postAsync(&#39;http://httpbin.org/post&#39;);\r\n$promise = $client-&gt;putAsync(&#39;http://httpbin.org/put&#39;);\r\n</code></pre>\r\n<p>或者使用Client的 sendAsync() and requestAsync() 方法：</p>\r\n<pre><code class=\"lang-php\">&lt;?php \r\n// 创建一个PSR-7请求对象 $headers = [&#39;X-Foo&#39; =&gt; &#39;Bar&#39;];\r\n$body = &#39;Hello!&#39;;\r\n$request = new Request(&#39;HEAD&#39;, &#39;http://httpbin.org/head&#39;, $headers, $body);\r\n\r\n// 如果不需要进去请求实例\r\n$promise = $client-&gt;requestAsync(&#39;GET&#39;, &#39;http://httpbin.org/get&#39;);\r\n</code></pre>\r\n<p>使用 then() 来调用返回值，成功使用 Psr\\Http\\Message\\ResponseInterface 处理器，否则抛出一个异常：</p>\r\n<pre><code class=\"lang-php\">&lt;?php\r\nuse Psr\\Http\\Message\\ResponseInterface;\r\nuse GuzzleHttp\\Exception\\RequestException;\r\n\r\n$promise = $client-&gt;requestAsync(&#39;GET&#39;, &#39;http://httpbin.org/get&#39;);\r\n$promise-&gt;then(\r\n    function (ResponseInterface $res) {\r\n        echo $res-&gt;getStatusCode() . &quot;\\n&quot;;\r\n    },\r\n    function (RequestException $e) {\r\n        echo $e-&gt;getMessage() . &quot;\\n&quot;;\r\n        echo $e-&gt;getRequest()-&gt;getMethod();\r\n    }\r\n);\r\n</code></pre>\r\n<h2 id=\"h2-4-4-\"><a name=\"4.4 并发请求\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.4 并发请求</h2><p>使用Promise和异步请求来同时发送多个请求：</p>\r\n<pre><code class=\"lang-php\">&lt;?php\r\nuse GuzzleHttp\\Client;\r\nuse GuzzleHttp\\Promise;\r\n\r\n$client = new Client([&#39;base_uri&#39; =&gt; &#39;http://httpbin.org/&#39;]);\r\n\r\n// 初始化每一个非阻塞请求\r\n$promises = [\r\n    &#39;image&#39; =&gt; $client-&gt;getAsync(&#39;/image&#39;),\r\n    &#39;png&#39;   =&gt; $client-&gt;getAsync(&#39;/image/png&#39;),\r\n    &#39;jpeg&#39;  =&gt; $client-&gt;getAsync(&#39;/image/jpeg&#39;),\r\n    &#39;webp&#39;  =&gt; $client-&gt;getAsync(&#39;/image/webp&#39;)\r\n];\r\n\r\n// 等待请求完成\r\n$results = Promise\\unwrap($promises);\r\n\r\n// 通过键名接收每一个结果\r\n// function.\r\necho $results[&#39;image&#39;]-&gt;getHeader(&#39;Content-Length&#39;);\r\necho $results[&#39;png&#39;]-&gt;getHeader(&#39;Content-Length&#39;);\r\n</code></pre>\r\n<p>当你想发送不确定数量的请求时，可以使用 GuzzleHttp\\Pool 对象：</p>\r\n<pre><code class=\"lang-php\">&lt;?php\r\nuse GuzzleHttp\\Pool;\r\nuse GuzzleHttp\\Client;\r\nuse GuzzleHttp\\Psr7\\Request;\r\n\r\n$client = new Client();\r\n\r\n$requests = function ($total) {\r\n    $uri = &#39;http://127.0.0.1:8126/guzzle-server/perf&#39;;\r\n    for ($i = 0; $i &lt; $total; $i++) {\r\n        yield new Request(&#39;GET&#39;, $uri);\r\n    }\r\n};\r\n\r\n$pool = new Pool($client, $requests(100), [\r\n    &#39;concurrency&#39; =&gt; 5,\r\n    &#39;fulfilled&#39; =&gt; function ($response, $index) {\r\n        // 每个成功的请求\r\n    },\r\n    &#39;rejected&#39; =&gt; function ($reason, $index) {\r\n        // 每个失败的请求\r\n    },\r\n]);\r\n\r\n// 初始化传输和创建授权\r\n$promise = $pool-&gt;promise();\r\n\r\n// 等待请求池完成\r\n$promise-&gt;wait();\r\n</code></pre>\r\n<h1 id=\"h1-5-\"><a name=\"5. 响应\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5. 响应</h1><h2 id=\"h2-5-1-\"><a name=\"5.1 获取响应的状态码\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.1 获取响应的状态码</h2><pre><code>$code = $response-&gt;getStatusCode(); // 200\r\n</code></pre><h2 id=\"h2-5-2-reason-phrase-\"><a name=\"5.2 获取原因短语(reason phrase)\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.2 获取原因短语(reason phrase)</h2><pre><code>$reason = $response-&gt;getReasonPhrase(); // OK\r\n</code></pre><h2 id=\"h2-5-3-header-\"><a name=\"5.3 获取头信息(header)\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.3 获取头信息(header)</h2><pre><code class=\"lang-php\">// 检查是否存在头信息\r\nif ($response-&gt;hasHeader(&#39;Content-Length&#39;)) {\r\n    echo &quot;It exists&quot;;\r\n}\r\n\r\n// 获取头信息\r\necho $response-&gt;getHeader(&#39;Content-Length&#39;);\r\n\r\n// 获取所有响应头信息\r\nforeach ($response-&gt;getHeaders() as $name =&gt; $values) {\r\n    echo $name . &#39;: &#39; . implode(&#39;, &#39;, $values) . &quot;\\r\\n&quot;;\r\n}\r\n</code></pre>\r\n<h2 id=\"h2-5-4-body-\"><a name=\"5.4 获取响应的主体部分(body)\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.4 获取响应的主体部分(body)</h2><pre><code class=\"lang-php\">$body = $response-&gt;getBody();\r\n// 隐式转换成字符串并输出\r\necho $body;\r\n// 显示转换body成字符串\r\n$stringBody = (string) $body;\r\n// 从body中读取10字节（bytes）\r\n$tenBytes = $body-&gt;read(10);\r\n// 将正文的剩余内容作为字符串读取\r\n$remainingBytes = $body-&gt;getContents();\r\n</code></pre>\r\n<h1 id=\"h1-6-\"><a name=\"6. 参数\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>6. 参数</h1><h2 id=\"h2-6-1-uri-\"><a name=\"6.1 在请求的URI中设置查询字符串\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>6.1 在请求的URI中设置查询字符串</h2><pre><code>$response = $client-&gt;request(&#39;GET&#39;, &#39;http://httpbin.org?foo=bar&#39;);\r\n</code></pre><h2 id=\"h2-6-2-query-\"><a name=\"6.2 使用 query 请求参数来声明查询字符串参数\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>6.2 使用 query 请求参数来声明查询字符串参数</h2><pre><code>$client-&gt;request(&#39;GET&#39;, &#39;http://httpbin.org&#39;, [\r\n    &#39;query&#39; =&gt; [&#39;foo&#39; =&gt; &#39;bar&#39;]\r\n]);\r\n</code></pre><h2 id=\"h2-6-3-query-\"><a name=\"6.3 提供一个字符串作为 query 请求参数\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>6.3 提供一个字符串作为 query 请求参数</h2><pre><code>$client-&gt;request(&#39;GET&#39;, &#39;http://httpbin.org&#39;, [&#39;query&#39; =&gt; &#39;foo=bar&#39;]);\r\n</code></pre><h1 id=\"h1-7-\"><a name=\"7. 其它\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>7. 其它</h1><p>Guzzle还提供了一些其它有用的功能</p>\r\n<ul>\r\n<li>上传数据（<a href=\"http://docs.guzzlephp.org/en/stable/quickstart.html#uploading-data\" title=\"http://docs.guzzlephp.org/en/stable/quickstart.html#uploading-data\">http://docs.guzzlephp.org/en/stable/quickstart.html#uploading-data</a>）</li><li>POST/表单请求（<a href=\"http://docs.guzzlephp.org/en/stable/quickstart.html#post-form-requests\" title=\"http://docs.guzzlephp.org/en/stable/quickstart.html#post-form-requests\">http://docs.guzzlephp.org/en/stable/quickstart.html#post-form-requests</a>）</li><li>Cookies（<a href=\"http://docs.guzzlephp.org/en/stable/quickstart.html#cookies\" title=\"http://docs.guzzlephp.org/en/stable/quickstart.html#cookies\">http://docs.guzzlephp.org/en/stable/quickstart.html#cookies</a>）</li><li>重定向（<a href=\"http://docs.guzzlephp.org/en/stable/quickstart.html#redirects\" title=\"http://docs.guzzlephp.org/en/stable/quickstart.html#redirects\">http://docs.guzzlephp.org/en/stable/quickstart.html#redirects</a>）</li><li>异常（<a href=\"http://docs.guzzlephp.org/en/stable/quickstart.html#exceptions\" title=\"http://docs.guzzlephp.org/en/stable/quickstart.html#exceptions\">http://docs.guzzlephp.org/en/stable/quickstart.html#exceptions</a>）</li></ul>\r\n<p>具体的可以查看官方文档。</p>\r\n', '', 0, 'publish', 1, 0, '/article/56.html', '', 0, 221, '2017-07-31 08:09:15', '2017-07-31 08:09:15', '2018-01-10 17:48:33', NULL);
INSERT INTO `pt_post` VALUES (57, 10, 'article', 'Wireshark基础用法：用Wireshark抓包分析网络通讯', '# 1. 什么是Wireshark？\r\nWireshark 是一个网络封包分析软件。网络封包分析软件的功能是捕获网络封包，并尽可能显示出最为详细的网络封包资料。\r\n\r\nWireshark不会对网络封包产生内容的修改，它只会反映出目前流通的封包资讯。 Wireshark本身也不会送出封包至网络上。\r\n\r\n官网：[https://www.wireshark.org/](https://www.wireshark.org/ \"https://www.wireshark.org/\")\r\n\r\n# 2. 使用\r\n## 2.1 安装\r\n\r\n下载地址：[https://www.wireshark.org/download.html](https://www.wireshark.org/download.html \"https://www.wireshark.org/download.html\")\r\n\r\n下载下来安装就好，过程很简单，我发现现在安装下来之后直接就是中文版了。\r\n## 2.2 开始捕获\r\n\r\n启动Wireshark后，会自动检测网络接口，然后给你选择进行捕获：\r\n![](https://www.goozp.com/uploads/2018/01/Wireshark1.png)\r\n\r\n比如我们选择本地连接，就会捕获本地连接中的网络通讯。下面是Wireshark主要的捕获界面，列出了捕获到的所有网络封包：\r\n![](https://www.goozp.com/uploads/2018/01/Wireshark2_768x724.png)\r\n\r\n## 2.3 着色规则\r\n可以发现，在捕获到的报文包中，Wireshark会用不同的颜色区分出来。具体的着色规则，可以在 视图 -> 着色规则（如果你是中文版） 中看到：\r\n![](https://www.goozp.com/uploads/2018/01/Wireshark3.png)\r\n熟悉之后，通过颜色，就可以快速定位你要关注的包了，比如Bad TCP就是黑底红色的。\r\n\r\n## 2.4 过滤器\r\nwireshark有两种过滤器：捕捉过滤器（CaptureFilters）和显示过滤器（DisplayFilters）。\r\n\r\n捕捉过滤器（CaptureFilters）：用于决定将什么样的信息记录在捕捉结果中，在捕捉时就进行过滤。\r\n\r\n显示过滤器（DisplayFilters）：在捕捉结果中进行过滤查找。\r\n\r\n可以在下图标注的两个地方用到这两个过滤器：\r\n![](https://www.goozp.com/uploads/2018/01/Wireshark4.png)\r\n\r\n过滤器会有语法规则，一开始不熟悉，其实也挺方便查看的，点击表达式，会有如下一个界面：\r\n![](https://www.goozp.com/uploads/2018/01/Wireshark5.png)\r\n可以在这里查看显示过滤器的表达式规则，很方便。\r\n\r\n过滤例子，只查看HTTP：\r\n![](https://www.goozp.com/uploads/2018/01/Wireshark6_768x715.png)\r\n\r\n## 2.5 追踪流\r\n\r\n通过使用追踪流，还能够看到服务器和目标端之间的全部会话。可以通过右键来选择：\r\n![](https://www.goozp.com/uploads/2018/01/Wireshark7.png)\r\n\r\n会看到两边的会话信息：\r\n![](https://www.goozp.com/uploads/2018/01/Wireshark8.png)\r\n查看完追踪流后，会自动添加过滤条件并显示。\r\n\r\n## 2.6 检查报文\r\n单击捕获的报文列表，下面的框框就会显示出该报文的信息，或者直接双击查看。', '<h1 id=\"h1-1-wireshark-\"><a name=\"1. 什么是Wireshark？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1. 什么是Wireshark？</h1><p>Wireshark 是一个网络封包分析软件。网络封包分析软件的功能是捕获网络封包，并尽可能显示出最为详细的网络封包资料。</p>\r\n<p>Wireshark不会对网络封包产生内容的修改，它只会反映出目前流通的封包资讯。 Wireshark本身也不会送出封包至网络上。</p>\r\n<p>官网：<a href=\"https://www.wireshark.org/\" title=\"https://www.wireshark.org/\">https://www.wireshark.org/</a></p>\r\n<h1 id=\"h1-2-\"><a name=\"2. 使用\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2. 使用</h1><h2 id=\"h2-2-1-\"><a name=\"2.1 安装\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.1 安装</h2><p>下载地址：<a href=\"https://www.wireshark.org/download.html\" title=\"https://www.wireshark.org/download.html\">https://www.wireshark.org/download.html</a></p>\r\n<p>下载下来安装就好，过程很简单，我发现现在安装下来之后直接就是中文版了。</p>\r\n<h2 id=\"h2-2-2-\"><a name=\"2.2 开始捕获\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.2 开始捕获</h2><p>启动Wireshark后，会自动检测网络接口，然后给你选择进行捕获：<br><img src=\"https://www.goozp.com/uploads/2018/01/Wireshark1.png\" alt=\"\"></p>\r\n<p>比如我们选择本地连接，就会捕获本地连接中的网络通讯。下面是Wireshark主要的捕获界面，列出了捕获到的所有网络封包：<br><img src=\"https://www.goozp.com/uploads/2018/01/Wireshark2_768x724.png\" alt=\"\"></p>\r\n<h2 id=\"h2-2-3-\"><a name=\"2.3 着色规则\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.3 着色规则</h2><p>可以发现，在捕获到的报文包中，Wireshark会用不同的颜色区分出来。具体的着色规则，可以在 视图 -&gt; 着色规则（如果你是中文版） 中看到：<br><img src=\"https://www.goozp.com/uploads/2018/01/Wireshark3.png\" alt=\"\"><br>熟悉之后，通过颜色，就可以快速定位你要关注的包了，比如Bad TCP就是黑底红色的。</p>\r\n<h2 id=\"h2-2-4-\"><a name=\"2.4 过滤器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.4 过滤器</h2><p>wireshark有两种过滤器：捕捉过滤器（CaptureFilters）和显示过滤器（DisplayFilters）。</p>\r\n<p>捕捉过滤器（CaptureFilters）：用于决定将什么样的信息记录在捕捉结果中，在捕捉时就进行过滤。</p>\r\n<p>显示过滤器（DisplayFilters）：在捕捉结果中进行过滤查找。</p>\r\n<p>可以在下图标注的两个地方用到这两个过滤器：<br><img src=\"https://www.goozp.com/uploads/2018/01/Wireshark4.png\" alt=\"\"></p>\r\n<p>过滤器会有语法规则，一开始不熟悉，其实也挺方便查看的，点击表达式，会有如下一个界面：<br><img src=\"https://www.goozp.com/uploads/2018/01/Wireshark5.png\" alt=\"\"><br>可以在这里查看显示过滤器的表达式规则，很方便。</p>\r\n<p>过滤例子，只查看HTTP：<br><img src=\"https://www.goozp.com/uploads/2018/01/Wireshark6_768x715.png\" alt=\"\"></p>\r\n<h2 id=\"h2-2-5-\"><a name=\"2.5 追踪流\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.5 追踪流</h2><p>通过使用追踪流，还能够看到服务器和目标端之间的全部会话。可以通过右键来选择：<br><img src=\"https://www.goozp.com/uploads/2018/01/Wireshark7.png\" alt=\"\"></p>\r\n<p>会看到两边的会话信息：<br><img src=\"https://www.goozp.com/uploads/2018/01/Wireshark8.png\" alt=\"\"><br>查看完追踪流后，会自动添加过滤条件并显示。</p>\r\n<h2 id=\"h2-2-6-\"><a name=\"2.6 检查报文\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.6 检查报文</h2><p>单击捕获的报文列表，下面的框框就会显示出该报文的信息，或者直接双击查看。</p>\r\n', '', 0, 'publish', 1, 0, '/article/57.html', 'https://www.goozp.com/uploads/2018/01/wireshark_logo.png', 0, 113, '2017-06-27 04:58:32', '2017-06-27 04:58:32', '2018-01-11 02:35:59', NULL);
INSERT INTO `pt_post` VALUES (58, 10, 'article', '用 Fiddler 进行HTTP请求调试', '# 1. 什么是Fiddler？\r\nFiddler是一个http协议调试代理工具，它能够记录并检查所有你的电脑和互联网之间的http通讯，设置断点，查看所有“进出”Fiddler的数据（指cookie,html,js,css等文件，这些都可以让你胡乱修改的意思）。\r\n\r\n通过Fiddle这个目前最常用的抓包工具之一，我们可以更加方便地在Web开发时进行Debug，像之前，进行ajax接口调试时，都要console.log打印，比较麻烦。用Fiddler就可以省事很多。\r\n\r\n抓包工具，HTTP和HTTPS调试用Fiddler，涉及TCP、UDP等其它的就用Wireshark。\r\n\r\n其实官网这个图就非常简单地说明了Fiddler可以用来做什么，Fiddler就充当了图中放大镜部分的作用，位于客户端和服务器端之前的HTTP代理。\r\n![](https://www.goozp.com/uploads/2018/01/Fiddler1.png)\r\n它能够记录客户端和服务器之间获取到的所有HTTP请求，并且可以针对特定的HTTP请求，分析请求的数据，还能设置断点，修改请求的数据，甚至可以修改服务器返回的数据。\r\n\r\n官网地址：[http://www.telerik.com/fiddler](http://www.telerik.com/fiddler \"http://www.telerik.com/fiddler\")\r\n\r\n# 2. 使用\r\n## 2.1 下载\r\n到官网免费下载，需要填一下邮箱：\r\n![](https://www.goozp.com/uploads/2018/01/Fiddler2.png)\r\n\r\n## 2.2 安装\r\n直接安装，安装过程很无脑。\r\n![](https://www.goozp.com/uploads/2018/01/Fiddler3.png)\r\n\r\n安装完后启动Fiddler，然后用浏览器随便打开一个网页，发现Fiddler已经开始工作了，左边为获取到的请求列表，点击查看详情后可以在右边查看到请求的详情；列表下面有个小黑框，是执行命令行用的。\r\n![](https://www.goozp.com/uploads/2018/01/Fiddler4.png)\r\n\r\n## 2.3 配置\r\n### 2.3.1 代理设置\r\n打开Tools -> Options -> Connections，可以看到默认端口为8888，把Allow remote computers to connect勾上，允许其他电脑的连接。\r\n![](https://www.goozp.com/uploads/2018/01/Fiddler5.png)\r\nFiddler可以代理PC端的请求，也可以代理移动端的请求，只需要将手机网络设置中的HTTP代理设置为电脑的IP地址，端口为Fiddler的默认端口号8888即可。\r\n\r\n### 2.3.2  配置捕获HTTPS\r\n![](https://www.goozp.com/uploads/2018/01/Fiddler6.png)\r\n会弹出一个Trust the Fiddler Root certificate的确认，点击Yes信任证书即可。\r\n\r\n## 2.4 分析\r\n### 2.4.1 性能数据分析（Statistics）\r\n右侧第一个指标，Statistics，可以看到关于HTTP请求的性能以及数据分析，以及饼图。\r\n![](https://www.goozp.com/uploads/2018/01/Fiddler7.png)\r\n\r\n### 2.4.2 会话内容（Inspectors）\r\nInspectors是用于查看会话的内容，上半部分是请求的内容（Request），下半部分是响应的内容（Response），可以查看header，json，text等等，选择就可以。\r\n![](https://www.goozp.com/uploads/2018/01/Fiddler8.png)\r\n\r\n### 2.4.3 自动响应（AutoResponder）\r\nAutoResponder允许你拦截指定规则的请求，并自动返回本地资源或Fiddler资源，从而代替服务器响应。\r\n\r\n比如，正常打开百度是这样的：\r\n![](https://www.goozp.com/uploads/2018/01/Fiddler9_1024x394.png)\r\n\r\n我们在AutoResponder设置一条简单的规则，将baidu绑定到我本地的一张图片：\r\n![](https://www.goozp.com/uploads/2018/01/Fiddler10.png)\r\n\r\n这个时候再打开百度，就被拦截下来了，并返回了我设置好的这张图片：\r\n![](https://www.goozp.com/uploads/2018/01/Fiddler11_768x514.png)\r\n\r\n### 2.4.4 自定义请求发送服务器（Composer）\r\nComposer可以自定义请求发送到服务器，通过手动创建一个新的请求，或者在会话列表中，拖拽一个现有的请求。\r\n\r\n输入一个url地址既可以模拟请求，也可以填写一些其它属性。\r\n![](https://www.goozp.com/uploads/2018/01/Fiddler12_1024x581.png)\r\n\r\n### 2.4.5 日志（Log）\r\nLog部分可以看到Fiddler的运行日志\r\n![](https://www.goozp.com/uploads/2018/01/Fiddler13.png)\r\n\r\n### 2.4.6 请求过滤（Filters）\r\n通过设置Filters设置规则来过滤掉一些请求；点击Use Filters开启功能，第一个框Hosts设置里，可以设置本地还是局域网，设置域名的过滤；下面还有一些更具体的设置。\r\n![](https://www.goozp.com/uploads/2018/01/Fiddler14_768x568.png)\r\n\r\n### 2.4.7 请求响应时间线（Timeline）\r\n![](https://www.goozp.com/uploads/2018/01/Fiddler15.png)\r\n\r\n## 2.5 命令使用\r\n列表下面的黑色框框，可以输入命令进行操作：\r\n![](https://www.goozp.com/uploads/2018/01/Fiddler16.png)\r\n\r\n### 2.5.1 基本命令\r\n\r\n| 命令  |  对应请求项 | 介绍  | 示例  |\r\n| ------------ | ------------ | ------------ | ------------ |\r\n|  ? | All  | 问号后边跟一个字符串，可以匹配出包含这个字符串的请求  | ?google  |\r\n|  > | Body   | 大于号后面跟一个数字，可以匹配出请求大小，大于这个数字请求  |  >1000 |\r\n| <  | Body  | 小于号跟大于号相反，匹配出请求大小，小于这个数字的请求  | <100 |\r\n| = |  Result |  等于号后面跟数字，可以匹配HTTP返回码 | =200  |\r\n|  @ | Host  | @后面跟Host，可以匹配域名  | @www.baidu.com  |\r\n|  select |  Content-Type | select后面跟响应类型，可以匹配到相关的类型  |  select image |\r\n| cls 	| All |	清空当前所有请求 |	cls|\r\n|dump |	All |	将所有请求打包成saz压缩包，保存到“我的文档\\Fiddler2\\Captures”目录下 |	dump|\r\n|start |	All |	开始监听请求 |	start |\r\n|stop |	All |	停止监听请求 |	stop |\r\n\r\n### 2.5.2 断点命令（进行断点测试）\r\n\r\n| 命令  |  对应请求项 | 介绍  | 示例  |\r\n| ------------ | ------------ | ------------ | ------------ |\r\n| bpafter | 	All | 	bpafter后边跟一个字符串，表示中断所有包含该字符串的请求 | 	bpafter baidu（输入bpafter解除断点） |\r\n| bpu |	All |	跟bpafter差不多，只不过这个是收到请求了，中断响应 |	bpu baidu（输入bpu解除断点） |\r\n| bps |	Result |	后面跟状态吗，表示中断所有是这个状态码的请求 |	bps 200（输入bps解除断点） |\r\n|bpv / bpm  |	HTTP方法  |	只中断HTTP方法的命令，HTTP方法如POST、GET |	bpv get（输入bpv解除断点） |\r\n|g / Go 	| All 	| 放行所有中断下来的请求  |	g |\r\n\r\n例如，运行命令bpu www.gzpblog.com，然后打开www.gzpblog.com，发现直接被怼掉：\r\n![](https://www.goozp.com/uploads/2018/01/Fiddler17_1024x33.png)\r\n\r\n我们看下这个请求，这个时候可以输入要传入的数据，然后可以选择黄色button断掉，或者绿色button继续加载：\r\n![](https://www.goozp.com/uploads/2018/01/Fiddler18_1024x522.png)\r\n\r\n点击绿色Run to Completion，就开始加载了：\r\n![](https://www.goozp.com/uploads/2018/01/Fiddler19_1024x72.png)\r\n有可能会挡掉下载的很多请求，我们可以运行go放行所有中断下来的请求。', '<h1 id=\"h1-1-fiddler-\"><a name=\"1. 什么是Fiddler？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1. 什么是Fiddler？</h1><p>Fiddler是一个http协议调试代理工具，它能够记录并检查所有你的电脑和互联网之间的http通讯，设置断点，查看所有“进出”Fiddler的数据（指cookie,html,js,css等文件，这些都可以让你胡乱修改的意思）。</p>\r\n<p>通过Fiddle这个目前最常用的抓包工具之一，我们可以更加方便地在Web开发时进行Debug，像之前，进行ajax接口调试时，都要console.log打印，比较麻烦。用Fiddler就可以省事很多。</p>\r\n<p>抓包工具，HTTP和HTTPS调试用Fiddler，涉及TCP、UDP等其它的就用Wireshark。</p>\r\n<p>其实官网这个图就非常简单地说明了Fiddler可以用来做什么，Fiddler就充当了图中放大镜部分的作用，位于客户端和服务器端之前的HTTP代理。<br><img src=\"https://www.goozp.com/uploads/2018/01/Fiddler1.png\" alt=\"\"><br>它能够记录客户端和服务器之间获取到的所有HTTP请求，并且可以针对特定的HTTP请求，分析请求的数据，还能设置断点，修改请求的数据，甚至可以修改服务器返回的数据。</p>\r\n<p>官网地址：<a href=\"http://www.telerik.com/fiddler\" title=\"http://www.telerik.com/fiddler\">http://www.telerik.com/fiddler</a></p>\r\n<h1 id=\"h1-2-\"><a name=\"2. 使用\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2. 使用</h1><h2 id=\"h2-2-1-\"><a name=\"2.1 下载\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.1 下载</h2><p>到官网免费下载，需要填一下邮箱：<br><img src=\"https://www.goozp.com/uploads/2018/01/Fiddler2.png\" alt=\"\"></p>\r\n<h2 id=\"h2-2-2-\"><a name=\"2.2 安装\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.2 安装</h2><p>直接安装，安装过程很无脑。<br><img src=\"https://www.goozp.com/uploads/2018/01/Fiddler3.png\" alt=\"\"></p>\r\n<p>安装完后启动Fiddler，然后用浏览器随便打开一个网页，发现Fiddler已经开始工作了，左边为获取到的请求列表，点击查看详情后可以在右边查看到请求的详情；列表下面有个小黑框，是执行命令行用的。<br><img src=\"https://www.goozp.com/uploads/2018/01/Fiddler4.png\" alt=\"\"></p>\r\n<h2 id=\"h2-2-3-\"><a name=\"2.3 配置\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.3 配置</h2><h3 id=\"h3-2-3-1-\"><a name=\"2.3.1 代理设置\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.3.1 代理设置</h3><p>打开Tools -&gt; Options -&gt; Connections，可以看到默认端口为8888，把Allow remote computers to connect勾上，允许其他电脑的连接。<br><img src=\"https://www.goozp.com/uploads/2018/01/Fiddler5.png\" alt=\"\"><br>Fiddler可以代理PC端的请求，也可以代理移动端的请求，只需要将手机网络设置中的HTTP代理设置为电脑的IP地址，端口为Fiddler的默认端口号8888即可。</p>\r\n<h3 id=\"h3-2-3-2-https\"><a name=\"2.3.2  配置捕获HTTPS\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.3.2  配置捕获HTTPS</h3><p><img src=\"https://www.goozp.com/uploads/2018/01/Fiddler6.png\" alt=\"\"><br>会弹出一个Trust the Fiddler Root certificate的确认，点击Yes信任证书即可。</p>\r\n<h2 id=\"h2-2-4-\"><a name=\"2.4 分析\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.4 分析</h2><h3 id=\"h3-2-4-1-statistics-\"><a name=\"2.4.1 性能数据分析（Statistics）\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.4.1 性能数据分析（Statistics）</h3><p>右侧第一个指标，Statistics，可以看到关于HTTP请求的性能以及数据分析，以及饼图。<br><img src=\"https://www.goozp.com/uploads/2018/01/Fiddler7.png\" alt=\"\"></p>\r\n<h3 id=\"h3-2-4-2-inspectors-\"><a name=\"2.4.2 会话内容（Inspectors）\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.4.2 会话内容（Inspectors）</h3><p>Inspectors是用于查看会话的内容，上半部分是请求的内容（Request），下半部分是响应的内容（Response），可以查看header，json，text等等，选择就可以。<br><img src=\"https://www.goozp.com/uploads/2018/01/Fiddler8.png\" alt=\"\"></p>\r\n<h3 id=\"h3-2-4-3-autoresponder-\"><a name=\"2.4.3 自动响应（AutoResponder）\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.4.3 自动响应（AutoResponder）</h3><p>AutoResponder允许你拦截指定规则的请求，并自动返回本地资源或Fiddler资源，从而代替服务器响应。</p>\r\n<p>比如，正常打开百度是这样的：<br><img src=\"https://www.goozp.com/uploads/2018/01/Fiddler9_1024x394.png\" alt=\"\"></p>\r\n<p>我们在AutoResponder设置一条简单的规则，将baidu绑定到我本地的一张图片：<br><img src=\"https://www.goozp.com/uploads/2018/01/Fiddler10.png\" alt=\"\"></p>\r\n<p>这个时候再打开百度，就被拦截下来了，并返回了我设置好的这张图片：<br><img src=\"https://www.goozp.com/uploads/2018/01/Fiddler11_768x514.png\" alt=\"\"></p>\r\n<h3 id=\"h3-2-4-4-composer-\"><a name=\"2.4.4 自定义请求发送服务器（Composer）\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.4.4 自定义请求发送服务器（Composer）</h3><p>Composer可以自定义请求发送到服务器，通过手动创建一个新的请求，或者在会话列表中，拖拽一个现有的请求。</p>\r\n<p>输入一个url地址既可以模拟请求，也可以填写一些其它属性。<br><img src=\"https://www.goozp.com/uploads/2018/01/Fiddler12_1024x581.png\" alt=\"\"></p>\r\n<h3 id=\"h3-2-4-5-log-\"><a name=\"2.4.5 日志（Log）\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.4.5 日志（Log）</h3><p>Log部分可以看到Fiddler的运行日志<br><img src=\"https://www.goozp.com/uploads/2018/01/Fiddler13.png\" alt=\"\"></p>\r\n<h3 id=\"h3-2-4-6-filters-\"><a name=\"2.4.6 请求过滤（Filters）\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.4.6 请求过滤（Filters）</h3><p>通过设置Filters设置规则来过滤掉一些请求；点击Use Filters开启功能，第一个框Hosts设置里，可以设置本地还是局域网，设置域名的过滤；下面还有一些更具体的设置。<br><img src=\"https://www.goozp.com/uploads/2018/01/Fiddler14_768x568.png\" alt=\"\"></p>\r\n<h3 id=\"h3-2-4-7-timeline-\"><a name=\"2.4.7 请求响应时间线（Timeline）\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.4.7 请求响应时间线（Timeline）</h3><p><img src=\"https://www.goozp.com/uploads/2018/01/Fiddler15.png\" alt=\"\"></p>\r\n<h2 id=\"h2-2-5-\"><a name=\"2.5 命令使用\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.5 命令使用</h2><p>列表下面的黑色框框，可以输入命令进行操作：<br><img src=\"https://www.goozp.com/uploads/2018/01/Fiddler16.png\" alt=\"\"></p>\r\n<h3 id=\"h3-2-5-1-\"><a name=\"2.5.1 基本命令\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.5.1 基本命令</h3><table>\r\n<thead>\r\n<tr>\r\n<th>命令</th>\r\n<th>对应请求项</th>\r\n<th>介绍</th>\r\n<th>示例</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr>\r\n<td>?</td>\r\n<td>All</td>\r\n<td>问号后边跟一个字符串，可以匹配出包含这个字符串的请求</td>\r\n<td>?google</td>\r\n</tr>\r\n<tr>\r\n<td>&gt;</td>\r\n<td>Body</td>\r\n<td>大于号后面跟一个数字，可以匹配出请求大小，大于这个数字请求</td>\r\n<td>&gt;1000</td>\r\n</tr>\r\n<tr>\r\n<td>&lt;</td>\r\n<td>Body</td>\r\n<td>小于号跟大于号相反，匹配出请求大小，小于这个数字的请求</td>\r\n<td>&lt;100</td>\r\n</tr>\r\n<tr>\r\n<td>=</td>\r\n<td>Result</td>\r\n<td>等于号后面跟数字，可以匹配HTTP返回码</td>\r\n<td>=200</td>\r\n</tr>\r\n<tr>\r\n<td>@</td>\r\n<td>Host</td>\r\n<td>@后面跟Host，可以匹配域名</td>\r\n<td><a href=\"https://github.com/www\" title=\"&#64;www\" class=\"at-link\">@www</a>.baidu.com</td>\r\n</tr>\r\n<tr>\r\n<td>select</td>\r\n<td>Content-Type</td>\r\n<td>select后面跟响应类型，可以匹配到相关的类型</td>\r\n<td>select image</td>\r\n</tr>\r\n<tr>\r\n<td>cls</td>\r\n<td>All</td>\r\n<td>清空当前所有请求</td>\r\n<td>cls</td>\r\n</tr>\r\n<tr>\r\n<td>dump</td>\r\n<td>All</td>\r\n<td>将所有请求打包成saz压缩包，保存到“我的文档\\Fiddler2\\Captures”目录下</td>\r\n<td>dump</td>\r\n</tr>\r\n<tr>\r\n<td>start</td>\r\n<td>All</td>\r\n<td>开始监听请求</td>\r\n<td>start</td>\r\n</tr>\r\n<tr>\r\n<td>stop</td>\r\n<td>All</td>\r\n<td>停止监听请求</td>\r\n<td>stop</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<h3 id=\"h3-2-5-2-\"><a name=\"2.5.2 断点命令（进行断点测试）\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.5.2 断点命令（进行断点测试）</h3><table>\r\n<thead>\r\n<tr>\r\n<th>命令</th>\r\n<th>对应请求项</th>\r\n<th>介绍</th>\r\n<th>示例</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr>\r\n<td>bpafter</td>\r\n<td>All</td>\r\n<td>bpafter后边跟一个字符串，表示中断所有包含该字符串的请求</td>\r\n<td>bpafter baidu（输入bpafter解除断点）</td>\r\n</tr>\r\n<tr>\r\n<td>bpu</td>\r\n<td>All</td>\r\n<td>跟bpafter差不多，只不过这个是收到请求了，中断响应</td>\r\n<td>bpu baidu（输入bpu解除断点）</td>\r\n</tr>\r\n<tr>\r\n<td>bps</td>\r\n<td>Result</td>\r\n<td>后面跟状态吗，表示中断所有是这个状态码的请求</td>\r\n<td>bps 200（输入bps解除断点）</td>\r\n</tr>\r\n<tr>\r\n<td>bpv / bpm</td>\r\n<td>HTTP方法</td>\r\n<td>只中断HTTP方法的命令，HTTP方法如POST、GET</td>\r\n<td>bpv get（输入bpv解除断点）</td>\r\n</tr>\r\n<tr>\r\n<td>g / Go</td>\r\n<td>All</td>\r\n<td>放行所有中断下来的请求</td>\r\n<td>g</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<p>例如，运行命令bpu www.gzpblog.com，然后打开www.gzpblog.com，发现直接被怼掉：<br><img src=\"https://www.goozp.com/uploads/2018/01/Fiddler17_1024x33.png\" alt=\"\"></p>\r\n<p>我们看下这个请求，这个时候可以输入要传入的数据，然后可以选择黄色button断掉，或者绿色button继续加载：<br><img src=\"https://www.goozp.com/uploads/2018/01/Fiddler18_1024x522.png\" alt=\"\"></p>\r\n<p>点击绿色Run to Completion，就开始加载了：<br><img src=\"https://www.goozp.com/uploads/2018/01/Fiddler19_1024x72.png\" alt=\"\"><br>有可能会挡掉下载的很多请求，我们可以运行go放行所有中断下来的请求。</p>\r\n', '', 0, 'publish', 1, 0, '/article/58.html', '', 0, 149, '2017-06-28 18:55:12', '2017-06-28 18:55:12', '2018-01-11 02:34:32', NULL);
INSERT INTO `pt_post` VALUES (59, 10, 'article', 'Win10系统安装使用Docker', '> 注：本文更新时间：2017-07-05（Docker发展得很快）\r\n\r\n# 1. 环境要求\r\n需要Windows 10 Pro系统；不是win10的windows系统不能用Docker for Windows，需要使用 Docker Toolbox。\r\n\r\n# 2. 安装\r\n## 2.1 下载\r\nDocker store下载地址：下载 [Docker CE for Windows](https://store.docker.com/editions/community/docker-ce-desktop-windows \"Docker CE for Windows\")\r\n\r\n## 2.2 安装\r\n基本上，什么都不用干！勾个协议就搞定了。\r\n\r\n## 2.3 启动\r\n第一次启动的时候，会提示Hyper-V没有开启，点击OK电脑会重启。\r\n![](https://www.goozp.com/uploads/2018/01/docker_for_windows4.png)\r\n电脑重启后Docker就可以正常启用了，右下角小图标会有一个小鲸鱼在动，等小鲸鱼动完了停下来就启动成功了。\r\n\r\n# 3. 使用\r\n## 3.1 通过PowerShell\r\n接下来可以用CMD命令行窗口或者PowerShell来开始使用，推荐PowerShell。\r\n![](https://www.goozp.com/uploads/2018/01/docker_for_windows5.png)\r\n打开PowerShell。\r\n\r\n## 3.2 查看版本\r\n查看docker的版本：`docker –version`\r\n查看docker compose的版本：`docker-compose –version`\r\n查看docker machine的版本：`docker-machine –version`\r\n![](https://www.goozp.com/uploads/2018/01/docker_for_windows6.png)\r\n\r\n## 3.3 使用示例\r\n- 启动Shell（PowerShell或其它Shell）\r\n- 运行docker命令, 例如 docker ps，docker version，和 docker info。\r\n![](https://www.goozp.com/uploads/2018/01/docker_for_windows7.png)\r\n\r\n	![](https://www.goozp.com/uploads/2018/01/docker_for_windows8_768x601.png)\r\n\r\n- 尝试执行 docker run hello-world 来测试从 Docker Hub 上拉取一个镜像并运行该容器。这是一个hello world demo，运行成功说明docker工作正常。\r\n![](https://www.goozp.com/uploads/2018/01/docker_for_windows9.png)\r\n\r\n- 尝试执行 docker run -it ubuntu bash 运行一个Ubuntu镜像。成功之后直接启动Ubuntu并进入到了系统中，exit可以退出返回到shell。\r\n![](https://www.goozp.com/uploads/2018/01/docker_for_windows10.png)\r\n\r\n- 执行命令下载并启动一个 Nginx容器；命名为 webserver。\r\n`docker run -d -p 80:80 –name webserver nginx`\r\n![](https://www.goozp.com/uploads/2018/01/docker_for_windows11.png)\r\n\r\n	因为是默认的80端口，浏览器中直接打开localhost，可以看到：\r\n	![](https://www.goozp.com/uploads/2018/01/docker_for_windows12_768x201.png)\r\n	说明Nginx服务已经开启了。\r\n\r\n	这个时候如果再运行 `docker ps` 可以看到运行着一个Nginx容器；是的，docker可以允许只单独运行一个独立的容器，可以是Nginx，Apache，Ubuntu等等。\r\n	![](https://www.goozp.com/uploads/2018/01/docker_for_windows13.png)\r\n	这个Nginx服务会一直在容器中运行，直到你停止或者删除容器。（Docker的核心概念镜像，容器，仓库；我们必须知道容器是镜像的运行实例）\r\n\r\n	可以通过 docker stop webserver 停止Nginx（NAMES是webserver）；通过 docker start webserver 开启服务。\r\n	![](https://www.goozp.com/uploads/2018/01/docker_for_windows14.png)\r\n\r\n- 停止并移除运行中的容器，可以通过命令： docker rm -f webserver\r\n	该命令会删除这个容器，但是不会删除镜像。\r\n	通过命令：docker images 可以查看当前本地的所有 Docker 镜像。\r\n![](https://www.goozp.com/uploads/2018/01/docker_for_windows15.png)\r\n\r\n	下次要使用这些镜像来创建容器的时候，就不需要从 Docker Hub 上去下载了，可以直接从本地拿来用。\r\n\r\n	不再需要的可以通过命令删除：`docker rmi [镜像id或者镜像名]`例如：`docker rmi nginx`\r\n\r\n- 在进行以上步奏run 镜像的时候，如果本地没有镜像，会到远程下载。官方仓库在国内可能会连接失败，可以配置为阿里云的加速镜像地址。（看下面的配置）\r\n\r\n# 4. 配置\r\n## 4.1 配置阿里云镜像\r\n阿里云Docker镜像的地址：[https://cr.console.aliyun.com/](https://cr.console.aliyun.com/ \"https://cr.console.aliyun.com/\")\r\n可以得到一个专属的地址：\r\n![](https://www.goozp.com/uploads/2018/01/docker_for_windows16_768x321.png)\r\n\r\n### 1）通过客户端直接配置\r\n打开settings -> Daemon，在 Resgistry mirrors 注册一个镜像地址，将专属地址写进去：\r\n![](https://www.goozp.com/uploads/2018/01/docker_for_windows17_300x195.png)\r\n确定应用后，Docker会自动重启。\r\n\r\n### 2）创建 docker machine 方式配置\r\n创建一台安装有Docker环境的Linux虚拟机，指定机器名称为default，同时配置Docker加速器地址：\r\n```\r\ndocker-machine create –engine-registry-mirror=https://kab482al.mirror.aliyuncs.com -d virtualbox default\r\n```\r\n\r\n查看机器的环境配置，并配置到本地，并通过Docker客户端访问Docker服务：\r\n```\r\ndocker-machine env default\r\neval “$(docker-machine env default)”\r\ndocker info\r\n```\r\n', '<blockquote>\r\n<p>注：本文更新时间：2017-07-05（Docker发展得很快）</p>\r\n</blockquote>\r\n<h1 id=\"h1-1-\"><a name=\"1. 环境要求\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1. 环境要求</h1><p>需要Windows 10 Pro系统；不是win10的windows系统不能用Docker for Windows，需要使用 Docker Toolbox。</p>\r\n<h1 id=\"h1-2-\"><a name=\"2. 安装\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2. 安装</h1><h2 id=\"h2-2-1-\"><a name=\"2.1 下载\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.1 下载</h2><p>Docker store下载地址：下载 <a href=\"https://store.docker.com/editions/community/docker-ce-desktop-windows\" title=\"Docker CE for Windows\">Docker CE for Windows</a></p>\r\n<h2 id=\"h2-2-2-\"><a name=\"2.2 安装\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.2 安装</h2><p>基本上，什么都不用干！勾个协议就搞定了。</p>\r\n<h2 id=\"h2-2-3-\"><a name=\"2.3 启动\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.3 启动</h2><p>第一次启动的时候，会提示Hyper-V没有开启，点击OK电脑会重启。<br><img src=\"https://www.goozp.com/uploads/2018/01/docker_for_windows4.png\" alt=\"\"><br>电脑重启后Docker就可以正常启用了，右下角小图标会有一个小鲸鱼在动，等小鲸鱼动完了停下来就启动成功了。</p>\r\n<h1 id=\"h1-3-\"><a name=\"3. 使用\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3. 使用</h1><h2 id=\"h2-3-1-powershell\"><a name=\"3.1 通过PowerShell\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.1 通过PowerShell</h2><p>接下来可以用CMD命令行窗口或者PowerShell来开始使用，推荐PowerShell。<br><img src=\"https://www.goozp.com/uploads/2018/01/docker_for_windows5.png\" alt=\"\"><br>打开PowerShell。</p>\r\n<h2 id=\"h2-3-2-\"><a name=\"3.2 查看版本\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.2 查看版本</h2><p>查看docker的版本：<code>docker –version</code><br>查看docker compose的版本：<code>docker-compose –version</code><br>查看docker machine的版本：<code>docker-machine –version</code><br><img src=\"https://www.goozp.com/uploads/2018/01/docker_for_windows6.png\" alt=\"\"></p>\r\n<h2 id=\"h2-3-3-\"><a name=\"3.3 使用示例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.3 使用示例</h2><ul>\r\n<li>启动Shell（PowerShell或其它Shell）</li><li><p>运行docker命令, 例如 docker ps，docker version，和 docker info。<br><img src=\"https://www.goozp.com/uploads/2018/01/docker_for_windows7.png\" alt=\"\"></p>\r\n<p>  <img src=\"https://www.goozp.com/uploads/2018/01/docker_for_windows8_768x601.png\" alt=\"\"></p>\r\n</li><li><p>尝试执行 docker run hello-world 来测试从 Docker Hub 上拉取一个镜像并运行该容器。这是一个hello world demo，运行成功说明docker工作正常。<br><img src=\"https://www.goozp.com/uploads/2018/01/docker_for_windows9.png\" alt=\"\"></p>\r\n</li><li><p>尝试执行 docker run -it ubuntu bash 运行一个Ubuntu镜像。成功之后直接启动Ubuntu并进入到了系统中，exit可以退出返回到shell。<br><img src=\"https://www.goozp.com/uploads/2018/01/docker_for_windows10.png\" alt=\"\"></p>\r\n</li><li><p>执行命令下载并启动一个 Nginx容器；命名为 webserver。<br><code>docker run -d -p 80:80 –name webserver nginx</code><br><img src=\"https://www.goozp.com/uploads/2018/01/docker_for_windows11.png\" alt=\"\"></p>\r\n<p>  因为是默认的80端口，浏览器中直接打开localhost，可以看到：<br>  <img src=\"https://www.goozp.com/uploads/2018/01/docker_for_windows12_768x201.png\" alt=\"\"><br>  说明Nginx服务已经开启了。</p>\r\n<p>  这个时候如果再运行 <code>docker ps</code> 可以看到运行着一个Nginx容器；是的，docker可以允许只单独运行一个独立的容器，可以是Nginx，Apache，Ubuntu等等。<br>  <img src=\"https://www.goozp.com/uploads/2018/01/docker_for_windows13.png\" alt=\"\"><br>  这个Nginx服务会一直在容器中运行，直到你停止或者删除容器。（Docker的核心概念镜像，容器，仓库；我们必须知道容器是镜像的运行实例）</p>\r\n<p>  可以通过 docker stop webserver 停止Nginx（NAMES是webserver）；通过 docker start webserver 开启服务。<br>  <img src=\"https://www.goozp.com/uploads/2018/01/docker_for_windows14.png\" alt=\"\"></p>\r\n</li><li><p>停止并移除运行中的容器，可以通过命令： docker rm -f webserver<br>  该命令会删除这个容器，但是不会删除镜像。<br>  通过命令：docker images 可以查看当前本地的所有 Docker 镜像。<br><img src=\"https://www.goozp.com/uploads/2018/01/docker_for_windows15.png\" alt=\"\"></p>\r\n<p>  下次要使用这些镜像来创建容器的时候，就不需要从 Docker Hub 上去下载了，可以直接从本地拿来用。</p>\r\n<p>  不再需要的可以通过命令删除：<code>docker rmi [镜像id或者镜像名]</code>例如：<code>docker rmi nginx</code></p>\r\n</li><li><p>在进行以上步奏run 镜像的时候，如果本地没有镜像，会到远程下载。官方仓库在国内可能会连接失败，可以配置为阿里云的加速镜像地址。（看下面的配置）</p>\r\n</li></ul>\r\n<h1 id=\"h1-4-\"><a name=\"4. 配置\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4. 配置</h1><h2 id=\"h2-4-1-\"><a name=\"4.1 配置阿里云镜像\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.1 配置阿里云镜像</h2><p>阿里云Docker镜像的地址：<a href=\"https://cr.console.aliyun.com/\" title=\"https://cr.console.aliyun.com/\">https://cr.console.aliyun.com/</a><br>可以得到一个专属的地址：<br><img src=\"https://www.goozp.com/uploads/2018/01/docker_for_windows16_768x321.png\" alt=\"\"></p>\r\n<h3 id=\"h3-1-\"><a name=\"1）通过客户端直接配置\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1）通过客户端直接配置</h3><p>打开settings -&gt; Daemon，在 Resgistry mirrors 注册一个镜像地址，将专属地址写进去：<br><img src=\"https://www.goozp.com/uploads/2018/01/docker_for_windows17_300x195.png\" alt=\"\"><br>确定应用后，Docker会自动重启。</p>\r\n<h3 id=\"h3-2-docker-machine-\"><a name=\"2）创建 docker machine 方式配置\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2）创建 docker machine 方式配置</h3><p>创建一台安装有Docker环境的Linux虚拟机，指定机器名称为default，同时配置Docker加速器地址：</p>\r\n<pre><code>docker-machine create –engine-registry-mirror=https://kab482al.mirror.aliyuncs.com -d virtualbox default\r\n</code></pre><p>查看机器的环境配置，并配置到本地，并通过Docker客户端访问Docker服务：</p>\r\n<pre><code>docker-machine env default\r\neval “$(docker-machine env default)”\r\ndocker info\r\n</code></pre>', '', 0, 'publish', 1, 0, '/article/59.html', '', 0, 128, '2017-07-05 03:02:18', '2017-07-05 03:02:18', '2018-02-10 19:14:46', NULL);
INSERT INTO `pt_post` VALUES (60, 10, 'page', '关于', '![](https://www.goozp.com/uploads/2018/01/coffee.png)\r\n## 关于我\r\n我给自己起了个网名，叫咖灰怪，因为我嗜咖如命啊；喝的是咖啡，挤出来的是代码。\r\n\r\n我并不是计算机专业出生，半路出家，虽然起步慢了很多，但是感觉自己成长也比较快。至今为止很充实，对技术有很高的热情。\r\n\r\n目前专注于后端开发，主要用PHP，目前在学Golang，偶尔写写前端；同时也会涉猎其它互联网知识，广撒网铺开广度。\r\n\r\n因为不断地在吸收各方面的知识，多，并不能全部记住，所以我觉得，记不住的话就多写写，不是天才那就多动动手，于是开始了博客的折腾之旅。\r\n\r\n## 关于本站\r\n15年底开了独立博客，用过WordPress，typecho，Z-blog等，最后停在了WordPress，并开发了一些主题，直到有一天，我想从头到尾开发一个我自己的全功能博客系统，并开源。然后就有了 [zPhal](https://github.com/ZpGuo/zPhal \"zPhal\" ) 项目，和本博客站点，上线时也换了一个新域名。\r\n\r\n目前本博客是用的我自己基于Phalcon开发的博客系统： [zPhal](https://github.com/ZpGuo/zPhal \"zPhal\" )，而且已经稳定跑在 Docker 上。\r\n\r\n我会在这里记录一些学习笔记，发一些技术文章，亦或是写写生活上的事或感悟。\r\n\r\n## 版权说明\r\n除非在文章开头说明转载和出处，本站的文章都是原创，并且采用 [知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议](https://creativecommons.org/licenses/by-nc-nd/4.0/ \"知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议\") 进行许可。有什么问题可以与我联系。\r\n\r\n## 联系方式\r\n你可以通过以下方式联系到我：\r\n- 邮件：gzp@goozp.com\r\n- GitHub：[ZpGuo](https://github.com/ZpGuo \"ZpGuo\")\r\n- segmentfault：[https://segmentfault.com/u/goozp](https://segmentfault.com/u/goozp \"https://segmentfault.com/u/goozp\")\r\n', '<p><img src=\"https://www.goozp.com/uploads/2018/01/coffee.png\" alt=\"\"></p>\r\n<h2 id=\"h2-u5173u4E8Eu6211\"><a name=\"关于我\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>关于我</h2><p>我给自己起了个网名，叫咖灰怪，因为我嗜咖如命啊；喝的是咖啡，挤出来的是代码。</p>\r\n<p>我并不是计算机专业出生，半路出家，虽然起步慢了很多，但是感觉自己成长也比较快。至今为止很充实，对技术有很高的热情。</p>\r\n<p>目前专注于后端开发，主要用PHP，目前在学Golang，偶尔写写前端；同时也会涉猎其它互联网知识，广撒网铺开广度。</p>\r\n<p>因为不断地在吸收各方面的知识，多，并不能全部记住，所以我觉得，记不住的话就多写写，不是天才那就多动动手，于是开始了博客的折腾之旅。</p>\r\n<h2 id=\"h2-u5173u4E8Eu672Cu7AD9\"><a name=\"关于本站\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>关于本站</h2><p>15年底开了独立博客，用过WordPress，typecho，Z-blog等，最后停在了WordPress，并开发了一些主题，直到有一天，我想从头到尾开发一个我自己的全功能博客系统，并开源。然后就有了 <a href=\"https://github.com/ZpGuo/zPhal\" title=\"zPhal\">zPhal</a> 项目，和本博客站点，上线时也换了一个新域名。</p>\r\n<p>目前本博客是用的我自己基于Phalcon开发的博客系统： <a href=\"https://github.com/ZpGuo/zPhal\" title=\"zPhal\">zPhal</a>，而且已经稳定跑在 Docker 上。</p>\r\n<p>我会在这里记录一些学习笔记，发一些技术文章，亦或是写写生活上的事或感悟。</p>\r\n<h2 id=\"h2-u7248u6743u8BF4u660E\"><a name=\"版权说明\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>版权说明</h2><p>除非在文章开头说明转载和出处，本站的文章都是原创，并且采用 <a href=\"https://creativecommons.org/licenses/by-nc-nd/4.0/\" title=\"知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议\">知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a> 进行许可。有什么问题可以与我联系。</p>\r\n<h2 id=\"h2-u8054u7CFBu65B9u5F0F\"><a name=\"联系方式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>联系方式</h2><p>你可以通过以下方式联系到我：</p>\r\n<ul>\r\n<li>邮件：<a href=\"mailto:gzp@goozp.com\">gzp@goozp.com</a></li><li>GitHub：<a href=\"https://github.com/ZpGuo\" title=\"ZpGuo\">ZpGuo</a></li><li>segmentfault：<a href=\"https://segmentfault.com/u/goozp\" title=\"https://segmentfault.com/u/goozp\">https://segmentfault.com/u/goozp</a></li></ul>\r\n', 'about-me', 0, 'publish', 1, 0, '/about-me', '', 0, 417, '2018-01-11 10:20:43', '2018-01-11 10:20:43', '2018-02-27 16:26:26', NULL);
INSERT INTO `pt_post` VALUES (61, 10, 'article', '基于Phalcon的博客系统 zPhal 1.0发布啦', '今天正式release了zPhal第一个正式版，接下来会不断维护更新。\r\n先放个地址：[ZpGuo/zPhal](https://github.com/ZpGuo/zPhal \"ZpGuo/zPhal\")\r\n\r\n# 什么是zPhal\r\nzPhal是我这段时间一直在进行的一个开源项目，基于Phalcon开发的博客系统，是全功能的动态博客系统。\r\n\r\n为什么要做这么一个东西呢？首先我是想开发一个从头到尾自己操刀的项目，然后想学习Phalcon这个框架，学习设计模式的应用，以及想抛弃一直在用的臃肿的WordPress（即使我优化过后打开也很快），希望功能多一点而不是静态博客。这样一来，不如就搞一个开源的博客系统吧，于是有了zPhal，每天下班抽空就开始写，我的目标是：CMS系统的功能，静态博客的效果。\r\n\r\n我在开发的时候考虑得挺多，尽量将代码进行优化，但是我是第一次用Phalcon来做一个项目，多多少少有点问题，欢迎拍砖。开发过程却是也有很多可以改进和优化的地方，但是由于时间问题，没有全部照顾到，但是我大部分都写了TODO，将在以后的版本进行改进。数据库设计部分沿用了WordPress的设计，因为一开始我是想能够兼容WordPress方便博客迁移，但是WordPress的数据库有些地方设计得我自己也不是很喜欢，但是对于博客这种小型系统，也就没关系了。\r\n\r\n前端方面，我保留了可以演进成主题模板的方式，但是还是控制器和试图结合。也没有采用现在大热的React，vue之类的，其实一开始是想用vue来做，后来还是没有，依旧是用PHP进行渲染，主要是因为：\r\n- 作为后端程序猿学习Vue还需要时间\r\n- 博客系统可能比较注重SEO，而单页面模式优化起来比较麻烦\r\n- 结合Phalcon开发的系统完全可以用PHP渲染将性能最大化\r\n\r\n但是将PHP从View层分离开其实是一个很好的选择，方便主题开发，以后可能会从这方面改进。\r\n\r\n# 目的\r\n其实开发这款软件主要是我自己要用，开源出来如果有人喜欢更好。不过因为是C拓展的框架，而且使用了Redis，估计这个门槛一下就......。那作为一个Phalcon的学习demo也是好的嘛~\r\n\r\n# 为什么选择Phalcon\r\nPHP框架很多，为什么选择Phalcon这款框架呢。一般我们选择一款框架会考虑很多因素，并非是这个框架好不好。比如公司叫我两天完成一个项目，急，那我可能会选择用TP速撸。我个人比较喜欢性能高一点，要的就是爽，虽然不管什么框架进行优化，都不会太差，往往性能瓶颈不在PHP这里，但是用Phalcon我们可以省去很多优化的时间，而且性能在某些时候确实是有体现，我觉得现在web的发展方向会越来越重视高并发高可用，所以Swoole和Phalcon是我计划中的两个关注点。而Phalcon的问题在于学习成本，但是，其实很多问题你只需要google一下就可以找到答案，大部分在Stack Overflow或者官方论坛上都有，主要是国内的资料比较少，圈子也小。\r\n\r\n最后的效果如何呢？看一下这个动图：\r\n![zphal-demo](https://www.goozp.com/uploads/2018/01/demo_for_zphal.gif \"zphal-demo\")\r\n\r\n截的时候不知道为什么截不到鼠标，可以在我博客体验：[咖啡与代码](https://www.goozp.com \"咖啡与代码\")\r\n\r\n# 功能特性\r\n来瞄一眼后台侧栏：\r\n![](https://www.goozp.com/uploads/2018/01/zphal1_1.png)\r\n\r\n基本功能已经实现的有：\r\n- 文章板块\r\n- 页面板块\r\n- 专题板块\r\n- 媒体板块\r\n- 链接板块的添加删除等操作\r\n- 用户管理\r\n- 设置功能\r\n\r\n基本上该有的功能都有了，除了一些还在开发计划，例如评论功能。\r\n\r\n我还融入了一些我的想法，比如专题这个功能，我希望能够将我的知识进行归类；比如设置作品（GitHub作品）方便进行展示等等。\r\n\r\n总的来说，我称之为“全功能”博客系统。\r\n\r\n# 开发计划\r\n计划中的功能有这些，未来要实现的功能：\r\n- 评论板块\r\n- 发送邮件\r\n- 后台信息展示和登录状态操作条\r\n- 菜单设置\r\n- 链接展示\r\n- 数据库备份\r\n- ACL权限管理\r\n\r\n可能会考虑的功能：\r\n- 主题功能\r\n- 插件功能\r\n- 侧栏实现自定义\r\n\r\n其实精力有限，可能进展会比较缓慢，因为要工作，要学习，要生活，当一个精致的码农呀；如果没什么人用的话，可能一些功能会阉割掉，最后完成一个我自己用着舒服的版本，一些必要功能是肯定会继续的。\r\n\r\n# 怎么使用\r\n## 运行环境\r\n### 环境要求\r\n- PHP 7.0+\r\n- Phalcon 3.0.0+\r\n- MySQL\r\n- Nginx or Apache\r\n- Redis\r\n- Composer\r\n\r\n### 使用Docker搭建环境（推荐）\r\n因为依赖Redis等，推荐用Docker统一进行管理，更加方便。\r\n这里有ZPhal对应的docker-file供参考：[ZpGuo/zPhal-dockerfiles](https://github.com/ZpGuo/zPhal-dockerfiles \"ZpGuo/zPhal-dockerfiles\")\r\n\r\n## 安装\r\n### 下载\r\n下载项目 [release的压缩文件](https://github.com/ZpGuo/zPhal/archive/master.zip \"release的压缩文件\") 或者clone项目。\r\nGitHub地址：[ZpGuo/zPhal](https://github.com/ZpGuo/zPhal \"ZpGuo/zPhal\")\r\n\r\n### 运行Composer\r\n该项目依赖composer。\r\n进入项目根目录，执行：\r\n```\r\ncomposer update\r\n```\r\n\r\n### 导入数据库\r\n因为没有做安装引导，所以需要手动导入数据库。\r\n创建数据库，并导入初始数据库；SQL文件位于schema目录下，文件名是zphaldb.sql。\r\n环境配置\r\n\r\n### 环境配置\r\n复制根目录下的.env.example文件并命名为.env文件；打开文件，修改配置为你环境对应的配置，注意在Docker环境下的配置有所不同。\r\n\r\n### Webserver配置\r\nwebserver可以使用Apache或者nginx。\r\n\r\n#### Apache服务器\r\n项目中已经有.htaccess文件；\r\n\r\n#### Nginx服务器\r\n对于Nginx服务器，下面是一个供参考的配置：\r\n```\r\nserver {\r\n    listen        80;\r\n    server_name www.zphal.com zphal.com;\r\n\r\n    ##########################\r\n    # In production require SSL\r\n    # listen 443 ssl default_server;\r\n\r\n    # ssl on;\r\n    # ssl_session_timeout  5m;\r\n    # ssl_protocols  SSLv2 SSLv3 TLSv1;\r\n    # ssl_ciphers  ALL:!ADH:!EXPORT56:RC4+RSA:+HIGH:+MEDIUM:+LOW:+SSLv2:+EXP;\r\n    # ssl_prefer_server_ciphers   on;\r\n\r\n    # These locations depend on where you store your certs\r\n    # ssl_certificate        /var/nginx/certs/default.cert;\r\n    # ssl_certificate_key    /var/nginx/certs/default.key;\r\n    ##########################\r\n\r\n    root /data/www/zPhal/public;\r\n    index index.php index.html index.htm;\r\n\r\n    charset utf-8;\r\n    client_max_body_size 100M;\r\n    fastcgi_read_timeout 1800;\r\n\r\n    location / {\r\n        # Matches URLS `$_GET[\'_url\']`\r\n        try_files $uri $uri/ /index.php?_url=$uri&$args;\r\n    }\r\n\r\n    location ~ \\.php$ {\r\n        try_files $uri =404;\r\n\r\n        #fastcgi_pass  unix:/var/run/php/php7.0-fpm.sock;\r\n        fastcgi_pass  php-fpm:9000;\r\n\r\n        fastcgi_index /index.php;\r\n\r\n        include fastcgi_params;\r\n        fastcgi_split_path_info       ^(.+\\.php)(/.+)$;\r\n        fastcgi_param PATH_INFO       $fastcgi_path_info;\r\n        fastcgi_param PATH_TRANSLATED /data/www/zPhal/public/$fastcgi_path_info;\r\n        fastcgi_param SCRIPT_FILENAME /data/www/zPhal/public/$fastcgi_script_name;\r\n    }\r\n\r\n    location ~ /\\.ht {\r\n        deny all;\r\n    }\r\n\r\n    location ~* \\.(js|css|png|jpg|jpeg|gif|ico)$ {\r\n        expires       max;\r\n        log_not_found off;\r\n        access_log    off;\r\n    }\r\n}\r\n```\r\n## 开始使用\r\n一切准备就绪，就可以开始使用了。\r\n\r\n在项目路劲后加/admin可进入后台登录页面；初始账号为admin，密码为admin（线上环境请不要再使用初始账号，可以在后台进行修改）。', '<p>今天正式release了zPhal第一个正式版，接下来会不断维护更新。<br>先放个地址：<a href=\"https://github.com/ZpGuo/zPhal\" title=\"ZpGuo/zPhal\">ZpGuo/zPhal</a></p>\r\n<h1 id=\"h1--zphal\"><a name=\"什么是zPhal\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>什么是zPhal</h1><p>zPhal是我这段时间一直在进行的一个开源项目，基于Phalcon开发的博客系统，是全功能的动态博客系统。</p>\r\n<p>为什么要做这么一个东西呢？首先我是想开发一个从头到尾自己操刀的项目，然后想学习Phalcon这个框架，学习设计模式的应用，以及想抛弃一直在用的臃肿的WordPress（即使我优化过后打开也很快），希望功能多一点而不是静态博客。这样一来，不如就搞一个开源的博客系统吧，于是有了zPhal，每天下班抽空就开始写，我的目标是：CMS系统的功能，静态博客的效果。</p>\r\n<p>我在开发的时候考虑得挺多，尽量将代码进行优化，但是我是第一次用Phalcon来做一个项目，多多少少有点问题，欢迎拍砖。开发过程却是也有很多可以改进和优化的地方，但是由于时间问题，没有全部照顾到，但是我大部分都写了TODO，将在以后的版本进行改进。数据库设计部分沿用了WordPress的设计，因为一开始我是想能够兼容WordPress方便博客迁移，但是WordPress的数据库有些地方设计得我自己也不是很喜欢，但是对于博客这种小型系统，也就没关系了。</p>\r\n<p>前端方面，我保留了可以演进成主题模板的方式，但是还是控制器和试图结合。也没有采用现在大热的React，vue之类的，其实一开始是想用vue来做，后来还是没有，依旧是用PHP进行渲染，主要是因为：</p>\r\n<ul>\r\n<li>作为后端程序猿学习Vue还需要时间</li><li>博客系统可能比较注重SEO，而单页面模式优化起来比较麻烦</li><li>结合Phalcon开发的系统完全可以用PHP渲染将性能最大化</li></ul>\r\n<p>但是将PHP从View层分离开其实是一个很好的选择，方便主题开发，以后可能会从这方面改进。</p>\r\n<h1 id=\"h1-u76EEu7684\"><a name=\"目的\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>目的</h1><p>其实开发这款软件主要是我自己要用，开源出来如果有人喜欢更好。不过因为是C拓展的框架，而且使用了Redis，估计这个门槛一下就……。那作为一个Phalcon的学习demo也是好的嘛~</p>\r\n<h1 id=\"h1--phalcon\"><a name=\"为什么选择Phalcon\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>为什么选择Phalcon</h1><p>PHP框架很多，为什么选择Phalcon这款框架呢。一般我们选择一款框架会考虑很多因素，并非是这个框架好不好。比如公司叫我两天完成一个项目，急，那我可能会选择用TP速撸。我个人比较喜欢性能高一点，要的就是爽，虽然不管什么框架进行优化，都不会太差，往往性能瓶颈不在PHP这里，但是用Phalcon我们可以省去很多优化的时间，而且性能在某些时候确实是有体现，我觉得现在web的发展方向会越来越重视高并发高可用，所以Swoole和Phalcon是我计划中的两个关注点。而Phalcon的问题在于学习成本，但是，其实很多问题你只需要google一下就可以找到答案，大部分在Stack Overflow或者官方论坛上都有，主要是国内的资料比较少，圈子也小。</p>\r\n<p>最后的效果如何呢？看一下这个动图：<br><img src=\"https://www.goozp.com/uploads/2018/01/demo_for_zphal.gif\" alt=\"zphal-demo\" title=\"zphal-demo\"></p>\r\n<p>截的时候不知道为什么截不到鼠标，可以在我博客体验：<a href=\"https://www.goozp.com\" title=\"咖啡与代码\">咖啡与代码</a></p>\r\n<h1 id=\"h1-u529Fu80FDu7279u6027\"><a name=\"功能特性\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>功能特性</h1><p>来瞄一眼后台侧栏：<br><img src=\"https://www.goozp.com/uploads/2018/01/zphal1_1.png\" alt=\"\"></p>\r\n<p>基本功能已经实现的有：</p>\r\n<ul>\r\n<li>文章板块</li><li>页面板块</li><li>专题板块</li><li>媒体板块</li><li>链接板块的添加删除等操作</li><li>用户管理</li><li>设置功能</li></ul>\r\n<p>基本上该有的功能都有了，除了一些还在开发计划，例如评论功能。</p>\r\n<p>我还融入了一些我的想法，比如专题这个功能，我希望能够将我的知识进行归类；比如设置作品（GitHub作品）方便进行展示等等。</p>\r\n<p>总的来说，我称之为“全功能”博客系统。</p>\r\n<h1 id=\"h1-u5F00u53D1u8BA1u5212\"><a name=\"开发计划\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>开发计划</h1><p>计划中的功能有这些，未来要实现的功能：</p>\r\n<ul>\r\n<li>评论板块</li><li>发送邮件</li><li>后台信息展示和登录状态操作条</li><li>菜单设置</li><li>链接展示</li><li>数据库备份</li><li>ACL权限管理</li></ul>\r\n<p>可能会考虑的功能：</p>\r\n<ul>\r\n<li>主题功能</li><li>插件功能</li><li>侧栏实现自定义</li></ul>\r\n<p>其实精力有限，可能进展会比较缓慢，因为要工作，要学习，要生活，当一个精致的码农呀；如果没什么人用的话，可能一些功能会阉割掉，最后完成一个我自己用着舒服的版本，一些必要功能是肯定会继续的。</p>\r\n<h1 id=\"h1-u600Eu4E48u4F7Fu7528\"><a name=\"怎么使用\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>怎么使用</h1><h2 id=\"h2-u8FD0u884Cu73AFu5883\"><a name=\"运行环境\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>运行环境</h2><h3 id=\"h3-u73AFu5883u8981u6C42\"><a name=\"环境要求\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>环境要求</h3><ul>\r\n<li>PHP 7.0+</li><li>Phalcon 3.0.0+</li><li>MySQL</li><li>Nginx or Apache</li><li>Redis</li><li>Composer</li></ul>\r\n<h3 id=\"h3--docker-\"><a name=\"使用Docker搭建环境（推荐）\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>使用Docker搭建环境（推荐）</h3><p>因为依赖Redis等，推荐用Docker统一进行管理，更加方便。<br>这里有ZPhal对应的docker-file供参考：<a href=\"https://github.com/ZpGuo/zPhal-dockerfiles\" title=\"ZpGuo/zPhal-dockerfiles\">ZpGuo/zPhal-dockerfiles</a></p>\r\n<h2 id=\"h2-u5B89u88C5\"><a name=\"安装\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>安装</h2><h3 id=\"h3-u4E0Bu8F7D\"><a name=\"下载\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>下载</h3><p>下载项目 <a href=\"https://github.com/ZpGuo/zPhal/archive/master.zip\" title=\"release的压缩文件\">release的压缩文件</a> 或者clone项目。<br>GitHub地址：<a href=\"https://github.com/ZpGuo/zPhal\" title=\"ZpGuo/zPhal\">ZpGuo/zPhal</a></p>\r\n<h3 id=\"h3--composer\"><a name=\"运行Composer\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>运行Composer</h3><p>该项目依赖composer。<br>进入项目根目录，执行：</p>\r\n<pre><code>composer update\r\n</code></pre><h3 id=\"h3-u5BFCu5165u6570u636Eu5E93\"><a name=\"导入数据库\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>导入数据库</h3><p>因为没有做安装引导，所以需要手动导入数据库。<br>创建数据库，并导入初始数据库；SQL文件位于schema目录下，文件名是zphaldb.sql。<br>环境配置</p>\r\n<h3 id=\"h3-u73AFu5883u914Du7F6E\"><a name=\"环境配置\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>环境配置</h3><p>复制根目录下的.env.example文件并命名为.env文件；打开文件，修改配置为你环境对应的配置，注意在Docker环境下的配置有所不同。</p>\r\n<h3 id=\"h3-webserver-\"><a name=\"Webserver配置\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Webserver配置</h3><p>webserver可以使用Apache或者nginx。</p>\r\n<h4 id=\"h4-apache-\"><a name=\"Apache服务器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Apache服务器</h4><p>项目中已经有.htaccess文件；</p>\r\n<h4 id=\"h4-nginx-\"><a name=\"Nginx服务器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Nginx服务器</h4><p>对于Nginx服务器，下面是一个供参考的配置：</p>\r\n<pre><code>server {\r\n    listen        80;\r\n    server_name www.zphal.com zphal.com;\r\n\r\n    ##########################\r\n    # In production require SSL\r\n    # listen 443 ssl default_server;\r\n\r\n    # ssl on;\r\n    # ssl_session_timeout  5m;\r\n    # ssl_protocols  SSLv2 SSLv3 TLSv1;\r\n    # ssl_ciphers  ALL:!ADH:!EXPORT56:RC4+RSA:+HIGH:+MEDIUM:+LOW:+SSLv2:+EXP;\r\n    # ssl_prefer_server_ciphers   on;\r\n\r\n    # These locations depend on where you store your certs\r\n    # ssl_certificate        /var/nginx/certs/default.cert;\r\n    # ssl_certificate_key    /var/nginx/certs/default.key;\r\n    ##########################\r\n\r\n    root /data/www/zPhal/public;\r\n    index index.php index.html index.htm;\r\n\r\n    charset utf-8;\r\n    client_max_body_size 100M;\r\n    fastcgi_read_timeout 1800;\r\n\r\n    location / {\r\n        # Matches URLS `$_GET[&#39;_url&#39;]`\r\n        try_files $uri $uri/ /index.php?_url=$uri&amp;$args;\r\n    }\r\n\r\n    location ~ \\.php$ {\r\n        try_files $uri =404;\r\n\r\n        #fastcgi_pass  unix:/var/run/php/php7.0-fpm.sock;\r\n        fastcgi_pass  php-fpm:9000;\r\n\r\n        fastcgi_index /index.php;\r\n\r\n        include fastcgi_params;\r\n        fastcgi_split_path_info       ^(.+\\.php)(/.+)$;\r\n        fastcgi_param PATH_INFO       $fastcgi_path_info;\r\n        fastcgi_param PATH_TRANSLATED /data/www/zPhal/public/$fastcgi_path_info;\r\n        fastcgi_param SCRIPT_FILENAME /data/www/zPhal/public/$fastcgi_script_name;\r\n    }\r\n\r\n    location ~ /\\.ht {\r\n        deny all;\r\n    }\r\n\r\n    location ~* \\.(js|css|png|jpg|jpeg|gif|ico)$ {\r\n        expires       max;\r\n        log_not_found off;\r\n        access_log    off;\r\n    }\r\n}\r\n</code></pre><h2 id=\"h2-u5F00u59CBu4F7Fu7528\"><a name=\"开始使用\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>开始使用</h2><p>一切准备就绪，就可以开始使用了。</p>\r\n<p>在项目路劲后加/admin可进入后台登录页面；初始账号为admin，密码为admin（线上环境请不要再使用初始账号，可以在后台进行修改）。</p>\r\n', '', 0, 'publish', 1, 0, '/article/61.html', 'https://www.goozp.com/uploads/cover/zphal-logo.png', 0, 189, '2018-01-13 02:39:15', '2018-01-13 02:39:15', '2018-01-18 16:11:03', NULL);
INSERT INTO `pt_post` VALUES (62, 10, 'article', 'Phalcon填坑手册：开发中会遇到的问题和解决方案（不断更新）', '本文将记录我在Phalcon开发过程中遇到的问题，以及如何如何解决。\r\n\r\n# 1. 正确地在控制器中获取参数\r\n一般情况下，GET/POST请求获取参数：\r\n```\r\n$this->request->get(参数名);\r\n$this->request->getPost(\"参数名\")\r\n```\r\n\r\n路由模式下route获取参数要用dispatcher->getParam();\r\nroute下定义好了参数名称可以直接通过参数名称来获取：\r\n```\r\nthis->dispatcher->getParam(\"参数名\");\r\n```\r\n\r\nroute没有定义好名称，只是规则中写了:params做匹配，可以在控制器中按顺序来获取：\r\n```\r\nclass NewsController extends Controller {\r\n    public function showAction($id, $testParam)\r\n    {\r\n        echo $id, \'|\' , $testParam;\r\n    }\r\n}\r\n```\r\n\r\n# 2. 为 url 定制路由\r\n**默认自动解析`/:controller/:action/:params`模式**：\r\n在实例化时，不加false参数：\r\n```\r\n$router = new Router();\r\n```\r\nurl将会自动进行`/:controller/:action/:params`参数的解析， 比如`https://www.goozp.com/login`将会解析成Login controller下的默认action。\r\n\r\n当使用路由时，保留默认解析模式有时候会导致解析混乱，比较建议采用**完全自定义路由模式**。\r\n完全自定义路由，在new时加上false：\r\n```\r\n$router = new Router(false);\r\n```\r\n不自动解析`/:controller/:action/:params`这些规则, 具体的路由匹配规则自己来编写，例如：\r\n```\r\n$router->add(\'/login\',\r\n    [\r\n        \'module\'     => \'admin\',\r\n        \'controller\' => \'login\',\r\n        \'action\'     => \'index\',\r\n    ]\r\n)->setName(\'login\');\r\n```\r\n这样不会因为自动解析而导致url混乱，但是所有url都要自己来定制路由规则。\r\n\r\n# 3. flash提示重写后输出不正确 (未解决)\r\n重写后输出的html标签是字符串，外面带\"\"\r\n\r\n# 4. Config 中 baseURI 的正确设置\r\n因为有Apache+.htaccess文件重写规则 或者 nginx配置到public/index.php的重写规则，我们不需要项目中的url带有/publc/index.php。\r\n但是默认是指到了/public/index.php中（比如$_SERVER[\"PHP_SELF\"]获取从根目录到当前页面本身的路径）; 所以，如果有Apache重写规则或者nginx配置到public/index.php的重写配置，我们需要把url设置为不带public/index.php的，于是就有了官方的这个设置：\r\n使用 $_SERVER[\"PHP_SELF\"]，并且正则去除/public/index.php\r\n```\r\n\'baseUri\'        => preg_replace(\'/public([\\/\\\\\\\\])index.php$/\', \'\', $_SERVER[\"PHP_SELF\"]),\r\n```\r\n这是动态写法，这种写法的问题在于 $_SERVER[\"PHP_SELF\"] 的不确定性，返回的值将根据 Apache 或 nginx 配置的 root，是否配置host或者域名，$_SERVER[\"PHP_SELF\"]会有不同的返回值。这样的话上面写法前面的正则并不是全部兼容的，所以这样写调试起来就稍麻烦。\r\n\r\n简单一点，用静态写法：\r\n设置host或者配置域名\r\n```\r\n\'baseUri\'        => \'/\',\r\n```\r\n如果是想在localhost下直接打开，则需要加上项目外层目录名，例如：\r\n```\r\n\'baseUri\'        => \'/zphal/\',\r\n```\r\n这样的话，我们在定义url服务的时候只需要把这个定义的配置传进去：\r\n```\r\n$di->setShared(\'url\', function () {\r\n    $config = $this->getConfig();\r\n\r\n    $url = new UrlResolver();\r\n    $url->setBaseUri($config->application->baseUri); // baseUri\r\n\r\n    return $url;\r\n});\r\n```\r\n\r\n以上写法的WebServer配置：\r\n- Apache：\r\n.hatccess按照官方配置就可以；配置host时配置到public下或者public外面一层的项目根目录也可以：\r\n```\r\n<VirtualHost *:80>\r\n    DocumentRoot \"D:\\phpStudy\\WWW\\zPhal\\public\"\r\n    ServerName goozp.com\r\n    ServerAlias\r\n  <Directory \"D:\\phpStudy\\WWW\\zPhal\\public\">\r\n      Options FollowSymLinks ExecCGI\r\n      AllowOverride All\r\n      Order allow,deny\r\n      Allow from all\r\n      Require all granted\r\n  </Directory>\r\n</VirtualHost>\r\n```\r\n- Nginx\r\n大概的配置如下，配置到public下，并定义rewrite规则：\r\n```\r\nserver {\r\n    listen        80;\r\n    server_name www.goozp.com goozp.com;\r\n\r\n    root /data/www/zPhal/public;\r\n    index index.php index.html index.htm;\r\n\r\n    charset utf-8;\r\n    client_max_body_size 100M;\r\n    fastcgi_read_timeout 1800;\r\n\r\n    location / {\r\n        # Matches URLS `$_GET[\'_url\']`\r\n        try_files $uri $uri/ /index.php?_url=$uri&$args;\r\n    }\r\n\r\n    location ~ \\.php$ {\r\n        try_files $uri =404;\r\n\r\n        #fastcgi_pass  unix:/var/run/php/php7.0-fpm.sock;\r\n        fastcgi_pass  php-fpm:9000;\r\n\r\n        fastcgi_index /index.php;\r\n\r\n        include fastcgi_params;\r\n        fastcgi_split_path_info       ^(.+\\.php)(/.+)$;\r\n        fastcgi_param PATH_INFO       $fastcgi_path_info;\r\n        fastcgi_param PATH_TRANSLATED /data/www/zPhal/public/$fastcgi_path_info;\r\n        fastcgi_param SCRIPT_FILENAME /data/www/zPhal/public/$fastcgi_script_name;\r\n    }\r\n\r\n    location ~ /\\.ht {\r\n        deny all;\r\n    }\r\n\r\n    location ~* \\.(js|css|png|jpg|jpeg|gif|ico)$ {\r\n        expires       max;\r\n        log_not_found off;\r\n        access_log    off;\r\n    }\r\n}\r\n```\r\n\r\n# 5. 事件管理器，fire写法不管用\r\n被手册误导，理解错误了。\r\n\r\n下面是 **错误** 的写法，在dispatcher中去定义了监听事件:\r\n```php\r\n$di->set(\'dispatcher\', function () {\r\n	// 创建一个事件管理器\r\n	$eventsManager = new EventsManager();\r\n\r\n	$media = new Media();\r\n\r\n	$media->setEventsManager($eventsManager);\r\n\r\n	// 监听分发器中使用插件产生的事件\r\n	$eventsManager->attach(\r\n		\"media\",\r\n		new AliYunOss()\r\n	);\r\n\r\n	$dispatcher = new Dispatcher();\r\n	$dispatcher->setDefaultNamespace(\'ZPhal\\Modules\\Admin\\Controllers\\\\\');\r\n	$dispatcher->setEventsManager($eventsManager); // 分配事件管理器到分发器\r\n\r\n	return $dispatcher;\r\n});\r\n```\r\n\r\n然而我想封装的是文件上传功能，跟 dispatcher分发器 没有任何关系，所以起不了作用还报错；应该注册一个返回DI容器的文件上传服务：\r\n```php\r\n$di->set(\'mediaUpload\',function (){\r\n	// 创建一个事件管理器\r\n	$eventsManager = new EventsManager();\r\n\r\n	$media = new Media();\r\n\r\n	$eventsManager->attach(\r\n		\"media\",\r\n		new AliYunOss()\r\n	);\r\n\r\n	$media->setEventsManager($eventsManager);\r\n\r\n	return $media;\r\n});\r\n```\r\n\r\n# 6.使用模型关联不起作用\r\n扔进去的对象报错；需要给关联的对象定义alias，通过alias来获取。\r\n如果是这样:\r\n```php\r\n$terms = new Terms();\r\n$terms->name = $name;\r\n$terms->slug = $slug;\r\n\r\n$termTaxonomy = new TermTaxonomy();\r\n$termTaxonomy->Terms  = $terms; // 这里\r\n$termTaxonomy->taxonomy = $type;\r\n\r\n$termTaxonomy->save();\r\n```\r\n在$termTaxonomy->Terms  = $terms；这里，Terms是TermTaxonomy Model中定义的关系的别名(alias)；\r\n定义方式如下，在model中：\r\n```php\r\n$this->belongsTo(\r\n    \"term_id\",\r\n    \"ZPhal\\\\Models\\\\Terms\",\r\n    \"term_id\",\r\n    [\r\n        \"alias\" => \"Terms\",\r\n    ]\r\n);\r\n```\r\n不起alias别名会报错。\r\n\r\n# 7. 插入数据时返回主键id\r\n通过`$model -> getWriteConnection() -> lastInsertId();`来获取：\r\n```\r\n$model = new model();\r\n\r\nif($model -> create($data)) {\r\n	$insertId = $model -> getWriteConnection() -> lastInsertId($model -> getSource());\r\n}\r\n```\r\n\r\n或者直接在执行之后拿id属性：\r\n```\r\n<?php\r\n$model = new model();\r\n\r\nif($model -> create($data)) {\r\n	$insertId = $model -> id;\r\n}\r\n```\r\n\r\n# 8. model事件 beforeCreate 和字段检查\r\n在 beforeCreate 事件中定义数据表字段的数据检查和数据赋值，不生效。\r\n\r\nbeforeCreate 在执行之前就会检查字段是否符合要求（validation），所以在beforecreate时再插入不行，会报错，需要在执行create前就传值,或者设置默认值。\r\n\r\n可以在 beforeValidation 时进行赋值检查的操作。\r\n\r\n#  9. 操作model保存时，save或update无效\r\n表现为save或者update失败，且不报错的问题。\r\n情况：主键设置为两个字段，更新时更新了其中一个字段。\r\n解决：不应该修改主键。\r\n参考：[https://stackoverflow.com/questions/3838414/can-we-update-primary-key-values-of-a-table](https://stackoverflow.com/questions/3838414/can-we-update-primary-key-values-of-a-table \"https://stackoverflow.com/questions/3838414/can-we-update-primary-key-values-of-a-table\")\r\n\r\n# 10. find()与findFirst()\r\n- find()与findFirst()返回值数据格式是不同的。\r\n- 加了 column 参数时的返回值object里时不完整的，所以无法使用save等方法，无法使用model关系。\r\n- 没有数据时，find()返回空数组，findfrist()返回false\r\n\r\n# 11. Phalcon\\Cache\\Backend\\Redis 的 queryKeys()出现以下错误：\r\n```\r\nCached keys need to be enabled to use this function (options[\'statsKey\'] == \'_PHCR\')!\r\n```\r\nRedis的默认配置有一个参数为‘_PHCR’前缀，所以queryKeys()时需要带上查询前缀。\r\n\r\n# 12 dispatcher->forward() 分发后原脚本仍然继续执行\r\n可以加上return阻断：\r\n```\r\n$this->dispatcher->forward([\r\n    \"controller\" => \"error\",\r\n    \"action\"    => \"route404\"\r\n]);\r\nreturn;\r\n```\r\n在分发后后面的代码将不再执行。\r\n\r\n# 13. 错误：Encryption key cannot be empty\r\n使用cookie时，默认会使用Crypt加密，而使用Crypt加密需要定义一个全局加密key。\r\n可以禁用cookie加密：\r\n```\r\n<?php\r\nuse Phalcon\\Http\\Response\\Cookies;\r\n\r\n$di->set(\r\n    \"cookies\",\r\n    function () {\r\n        $cookies = new Cookies();\r\n\r\n        $cookies->useEncryption(false);\r\n\r\n        return $cookies;\r\n    }\r\n);\r\n```\r\n\r\n或者设置一个key：\r\n```\r\n<?php\r\nuse Phalcon\\Crypt;\r\n\r\n$di->set(\r\n    \"crypt\",\r\n    function () {\r\n        $crypt = new Crypt();\r\n\r\n        $crypt->setKey(\'#1dj8$=dp?.ak//j1V$\'); // 使用你自己的key！\r\n\r\n        return $crypt;\r\n    }\r\n);\r\n```\r\n\r\n# 14. cache删除失败：queryKeys()之后foreach遍历循环delete()删除失败\r\n正常删除时：\r\n```\r\n$this->cache->delete($key)\r\n```\r\n如果设置了前缀，会在$key自动加上前缀。\r\n\r\n**queryKeys列出来的已经带上了前缀**，所以这样删除：\r\n```\r\n$keys = $this->cache->queryKeys();\r\n    foreach($keys as $key) {\r\n        $this->cache->delete($key)\r\n    }\r\n```\r\n传进去的key还会**自动再加一遍前缀**，就找不到缓存了，导致删除失败。\r\n\r\n解决方法：\r\n1. 用`$this->cache->flush()`清除所有缓存，但是会清除所有缓存，所以如果是memcache或者redis缓存可以设置一下statsKey，避免清除了所有缓存。\r\n2. 或者不使用前缀，就可以正常使用queryKeys()和delete()这条流程。\r\n', '<p>本文将记录我在Phalcon开发过程中遇到的问题，以及如何如何解决。</p>\r\n<h1 id=\"h1-1-\"><a name=\"1. 正确地在控制器中获取参数\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1. 正确地在控制器中获取参数</h1><p>一般情况下，GET/POST请求获取参数：</p>\r\n<pre><code>$this-&gt;request-&gt;get(参数名);\r\n$this-&gt;request-&gt;getPost(&quot;参数名&quot;)\r\n</code></pre><p>路由模式下route获取参数要用dispatcher-&gt;getParam();<br>route下定义好了参数名称可以直接通过参数名称来获取：</p>\r\n<pre><code>this-&gt;dispatcher-&gt;getParam(&quot;参数名&quot;);\r\n</code></pre><p>route没有定义好名称，只是规则中写了:params做匹配，可以在控制器中按顺序来获取：</p>\r\n<pre><code>class NewsController extends Controller {\r\n    public function showAction($id, $testParam)\r\n    {\r\n        echo $id, &#39;|&#39; , $testParam;\r\n    }\r\n}\r\n</code></pre><h1 id=\"h1-2-url-\"><a name=\"2. 为 url 定制路由\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2. 为 url 定制路由</h1><p><strong>默认自动解析<code>/:controller/:action/:params</code>模式</strong>：<br>在实例化时，不加false参数：</p>\r\n<pre><code>$router = new Router();\r\n</code></pre><p>url将会自动进行<code>/:controller/:action/:params</code>参数的解析， 比如<code>https://www.goozp.com/login</code>将会解析成Login controller下的默认action。</p>\r\n<p>当使用路由时，保留默认解析模式有时候会导致解析混乱，比较建议采用<strong>完全自定义路由模式</strong>。<br>完全自定义路由，在new时加上false：</p>\r\n<pre><code>$router = new Router(false);\r\n</code></pre><p>不自动解析<code>/:controller/:action/:params</code>这些规则, 具体的路由匹配规则自己来编写，例如：</p>\r\n<pre><code>$router-&gt;add(&#39;/login&#39;,\r\n    [\r\n        &#39;module&#39;     =&gt; &#39;admin&#39;,\r\n        &#39;controller&#39; =&gt; &#39;login&#39;,\r\n        &#39;action&#39;     =&gt; &#39;index&#39;,\r\n    ]\r\n)-&gt;setName(&#39;login&#39;);\r\n</code></pre><p>这样不会因为自动解析而导致url混乱，但是所有url都要自己来定制路由规则。</p>\r\n<h1 id=\"h1-3-flash-\"><a name=\"3. flash提示重写后输出不正确 (未解决)\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3. flash提示重写后输出不正确 (未解决)</h1><p>重写后输出的html标签是字符串，外面带””</p>\r\n<h1 id=\"h1-4-config-baseuri-\"><a name=\"4. Config 中 baseURI 的正确设置\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4. Config 中 baseURI 的正确设置</h1><p>因为有Apache+.htaccess文件重写规则 或者 nginx配置到public/index.php的重写规则，我们不需要项目中的url带有/publc/index.php。<br>但是默认是指到了/public/index.php中（比如$_SERVER[“PHP_SELF”]获取从根目录到当前页面本身的路径）; 所以，如果有Apache重写规则或者nginx配置到public/index.php的重写配置，我们需要把url设置为不带public/index.php的，于是就有了官方的这个设置：<br>使用 $_SERVER[“PHP_SELF”]，并且正则去除/public/index.php</p>\r\n<pre><code>&#39;baseUri&#39;        =&gt; preg_replace(&#39;/public([\\/\\\\\\\\])index.php$/&#39;, &#39;&#39;, $_SERVER[&quot;PHP_SELF&quot;]),\r\n</code></pre><p>这是动态写法，这种写法的问题在于 $_SERVER[“PHP_SELF”] 的不确定性，返回的值将根据 Apache 或 nginx 配置的 root，是否配置host或者域名，$_SERVER[“PHP_SELF”]会有不同的返回值。这样的话上面写法前面的正则并不是全部兼容的，所以这样写调试起来就稍麻烦。</p>\r\n<p>简单一点，用静态写法：<br>设置host或者配置域名</p>\r\n<pre><code>&#39;baseUri&#39;        =&gt; &#39;/&#39;,\r\n</code></pre><p>如果是想在localhost下直接打开，则需要加上项目外层目录名，例如：</p>\r\n<pre><code>&#39;baseUri&#39;        =&gt; &#39;/zphal/&#39;,\r\n</code></pre><p>这样的话，我们在定义url服务的时候只需要把这个定义的配置传进去：</p>\r\n<pre><code>$di-&gt;setShared(&#39;url&#39;, function () {\r\n    $config = $this-&gt;getConfig();\r\n\r\n    $url = new UrlResolver();\r\n    $url-&gt;setBaseUri($config-&gt;application-&gt;baseUri); // baseUri\r\n\r\n    return $url;\r\n});\r\n</code></pre><p>以上写法的WebServer配置：</p>\r\n<ul>\r\n<li>Apache：<br>.hatccess按照官方配置就可以；配置host时配置到public下或者public外面一层的项目根目录也可以：<pre><code>&lt;VirtualHost *:80&gt;\r\n  DocumentRoot &quot;D:\\phpStudy\\WWW\\zPhal\\public&quot;\r\n  ServerName goozp.com\r\n  ServerAlias\r\n&lt;Directory &quot;D:\\phpStudy\\WWW\\zPhal\\public&quot;&gt;\r\n    Options FollowSymLinks ExecCGI\r\n    AllowOverride All\r\n    Order allow,deny\r\n    Allow from all\r\n    Require all granted\r\n&lt;/Directory&gt;\r\n&lt;/VirtualHost&gt;\r\n</code></pre></li><li><p>Nginx<br>大概的配置如下，配置到public下，并定义rewrite规则：</p>\r\n<pre><code>server {\r\n  listen        80;\r\n  server_name www.goozp.com goozp.com;\r\n\r\n  root /data/www/zPhal/public;\r\n  index index.php index.html index.htm;\r\n\r\n  charset utf-8;\r\n  client_max_body_size 100M;\r\n  fastcgi_read_timeout 1800;\r\n\r\n  location / {\r\n      # Matches URLS `$_GET[&#39;_url&#39;]`\r\n      try_files $uri $uri/ /index.php?_url=$uri&amp;$args;\r\n  }\r\n\r\n  location ~ \\.php$ {\r\n      try_files $uri =404;\r\n\r\n      #fastcgi_pass  unix:/var/run/php/php7.0-fpm.sock;\r\n      fastcgi_pass  php-fpm:9000;\r\n\r\n      fastcgi_index /index.php;\r\n\r\n      include fastcgi_params;\r\n      fastcgi_split_path_info       ^(.+\\.php)(/.+)$;\r\n      fastcgi_param PATH_INFO       $fastcgi_path_info;\r\n      fastcgi_param PATH_TRANSLATED /data/www/zPhal/public/$fastcgi_path_info;\r\n      fastcgi_param SCRIPT_FILENAME /data/www/zPhal/public/$fastcgi_script_name;\r\n  }\r\n\r\n  location ~ /\\.ht {\r\n      deny all;\r\n  }\r\n\r\n  location ~* \\.(js|css|png|jpg|jpeg|gif|ico)$ {\r\n      expires       max;\r\n      log_not_found off;\r\n      access_log    off;\r\n  }\r\n}\r\n</code></pre></li></ul>\r\n<h1 id=\"h1-5-fire-\"><a name=\"5. 事件管理器，fire写法不管用\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5. 事件管理器，fire写法不管用</h1><p>被手册误导，理解错误了。</p>\r\n<p>下面是 <strong>错误</strong> 的写法，在dispatcher中去定义了监听事件:</p>\r\n<pre><code class=\"lang-php\">$di-&gt;set(&#39;dispatcher&#39;, function () {\r\n    // 创建一个事件管理器\r\n    $eventsManager = new EventsManager();\r\n\r\n    $media = new Media();\r\n\r\n    $media-&gt;setEventsManager($eventsManager);\r\n\r\n    // 监听分发器中使用插件产生的事件\r\n    $eventsManager-&gt;attach(\r\n        &quot;media&quot;,\r\n        new AliYunOss()\r\n    );\r\n\r\n    $dispatcher = new Dispatcher();\r\n    $dispatcher-&gt;setDefaultNamespace(&#39;ZPhal\\Modules\\Admin\\Controllers\\\\&#39;);\r\n    $dispatcher-&gt;setEventsManager($eventsManager); // 分配事件管理器到分发器\r\n\r\n    return $dispatcher;\r\n});\r\n</code></pre>\r\n<p>然而我想封装的是文件上传功能，跟 dispatcher分发器 没有任何关系，所以起不了作用还报错；应该注册一个返回DI容器的文件上传服务：</p>\r\n<pre><code class=\"lang-php\">$di-&gt;set(&#39;mediaUpload&#39;,function (){\r\n    // 创建一个事件管理器\r\n    $eventsManager = new EventsManager();\r\n\r\n    $media = new Media();\r\n\r\n    $eventsManager-&gt;attach(\r\n        &quot;media&quot;,\r\n        new AliYunOss()\r\n    );\r\n\r\n    $media-&gt;setEventsManager($eventsManager);\r\n\r\n    return $media;\r\n});\r\n</code></pre>\r\n<h1 id=\"h1-6-\"><a name=\"6.使用模型关联不起作用\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>6.使用模型关联不起作用</h1><p>扔进去的对象报错；需要给关联的对象定义alias，通过alias来获取。<br>如果是这样:</p>\r\n<pre><code class=\"lang-php\">$terms = new Terms();\r\n$terms-&gt;name = $name;\r\n$terms-&gt;slug = $slug;\r\n\r\n$termTaxonomy = new TermTaxonomy();\r\n$termTaxonomy-&gt;Terms  = $terms; // 这里\r\n$termTaxonomy-&gt;taxonomy = $type;\r\n\r\n$termTaxonomy-&gt;save();\r\n</code></pre>\r\n<p>在$termTaxonomy-&gt;Terms  = $terms；这里，Terms是TermTaxonomy Model中定义的关系的别名(alias)；<br>定义方式如下，在model中：</p>\r\n<pre><code class=\"lang-php\">$this-&gt;belongsTo(\r\n    &quot;term_id&quot;,\r\n    &quot;ZPhal\\\\Models\\\\Terms&quot;,\r\n    &quot;term_id&quot;,\r\n    [\r\n        &quot;alias&quot; =&gt; &quot;Terms&quot;,\r\n    ]\r\n);\r\n</code></pre>\r\n<p>不起alias别名会报错。</p>\r\n<h1 id=\"h1-7-id\"><a name=\"7. 插入数据时返回主键id\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>7. 插入数据时返回主键id</h1><p>通过<code>$model -&gt; getWriteConnection() -&gt; lastInsertId();</code>来获取：</p>\r\n<pre><code>$model = new model();\r\n\r\nif($model -&gt; create($data)) {\r\n    $insertId = $model -&gt; getWriteConnection() -&gt; lastInsertId($model -&gt; getSource());\r\n}\r\n</code></pre><p>或者直接在执行之后拿id属性：</p>\r\n<pre><code>&lt;?php\r\n$model = new model();\r\n\r\nif($model -&gt; create($data)) {\r\n    $insertId = $model -&gt; id;\r\n}\r\n</code></pre><h1 id=\"h1-8-model-beforecreate-\"><a name=\"8. model事件 beforeCreate 和字段检查\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>8. model事件 beforeCreate 和字段检查</h1><p>在 beforeCreate 事件中定义数据表字段的数据检查和数据赋值，不生效。</p>\r\n<p>beforeCreate 在执行之前就会检查字段是否符合要求（validation），所以在beforecreate时再插入不行，会报错，需要在执行create前就传值,或者设置默认值。</p>\r\n<p>可以在 beforeValidation 时进行赋值检查的操作。</p>\r\n<h1 id=\"h1-9-model-save-update-\"><a name=\"9. 操作model保存时，save或update无效\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>9. 操作model保存时，save或update无效</h1><p>表现为save或者update失败，且不报错的问题。<br>情况：主键设置为两个字段，更新时更新了其中一个字段。<br>解决：不应该修改主键。<br>参考：<a href=\"https://stackoverflow.com/questions/3838414/can-we-update-primary-key-values-of-a-table\" title=\"https://stackoverflow.com/questions/3838414/can-we-update-primary-key-values-of-a-table\">https://stackoverflow.com/questions/3838414/can-we-update-primary-key-values-of-a-table</a></p>\r\n<h1 id=\"h1-10-find-findfirst-\"><a name=\"10. find()与findFirst()\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>10. find()与findFirst()</h1><ul>\r\n<li>find()与findFirst()返回值数据格式是不同的。</li><li>加了 column 参数时的返回值object里时不完整的，所以无法使用save等方法，无法使用model关系。</li><li>没有数据时，find()返回空数组，findfrist()返回false</li></ul>\r\n<h1 id=\"h1-11-phalcon-cache-backend-redis-querykeys-\"><a name=\"11. Phalcon\\Cache\\Backend\\Redis 的 queryKeys()出现以下错误：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>11. Phalcon\\Cache\\Backend\\Redis 的 queryKeys()出现以下错误：</h1><pre><code>Cached keys need to be enabled to use this function (options[&#39;statsKey&#39;] == &#39;_PHCR&#39;)!\r\n</code></pre><p>Redis的默认配置有一个参数为‘_PHCR’前缀，所以queryKeys()时需要带上查询前缀。</p>\r\n<h1 id=\"h1-12-dispatcher-gt-forward-\"><a name=\"12 dispatcher-&gt;forward() 分发后原脚本仍然继续执行\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>12 dispatcher-&gt;forward() 分发后原脚本仍然继续执行</h1><p>可以加上return阻断：</p>\r\n<pre><code>$this-&gt;dispatcher-&gt;forward([\r\n    &quot;controller&quot; =&gt; &quot;error&quot;,\r\n    &quot;action&quot;    =&gt; &quot;route404&quot;\r\n]);\r\nreturn;\r\n</code></pre><p>在分发后后面的代码将不再执行。</p>\r\n<h1 id=\"h1-13-encryption-key-cannot-be-empty\"><a name=\"13. 错误：Encryption key cannot be empty\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>13. 错误：Encryption key cannot be empty</h1><p>使用cookie时，默认会使用Crypt加密，而使用Crypt加密需要定义一个全局加密key。<br>可以禁用cookie加密：</p>\r\n<pre><code>&lt;?php\r\nuse Phalcon\\Http\\Response\\Cookies;\r\n\r\n$di-&gt;set(\r\n    &quot;cookies&quot;,\r\n    function () {\r\n        $cookies = new Cookies();\r\n\r\n        $cookies-&gt;useEncryption(false);\r\n\r\n        return $cookies;\r\n    }\r\n);\r\n</code></pre><p>或者设置一个key：</p>\r\n<pre><code>&lt;?php\r\nuse Phalcon\\Crypt;\r\n\r\n$di-&gt;set(\r\n    &quot;crypt&quot;,\r\n    function () {\r\n        $crypt = new Crypt();\r\n\r\n        $crypt-&gt;setKey(&#39;#1dj8$=dp?.ak//j1V$&#39;); // 使用你自己的key！\r\n\r\n        return $crypt;\r\n    }\r\n);\r\n</code></pre><h1 id=\"h1-14-cache-querykeys-foreach-delete-\"><a name=\"14. cache删除失败：queryKeys()之后foreach遍历循环delete()删除失败\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>14. cache删除失败：queryKeys()之后foreach遍历循环delete()删除失败</h1><p>正常删除时：</p>\r\n<pre><code>$this-&gt;cache-&gt;delete($key)\r\n</code></pre><p>如果设置了前缀，会在$key自动加上前缀。</p>\r\n<p><strong>queryKeys列出来的已经带上了前缀</strong>，所以这样删除：</p>\r\n<pre><code>$keys = $this-&gt;cache-&gt;queryKeys();\r\n    foreach($keys as $key) {\r\n        $this-&gt;cache-&gt;delete($key)\r\n    }\r\n</code></pre><p>传进去的key还会<strong>自动再加一遍前缀</strong>，就找不到缓存了，导致删除失败。</p>\r\n<p>解决方法：</p>\r\n<ol>\r\n<li>用<code>$this-&gt;cache-&gt;flush()</code>清除所有缓存，但是会清除所有缓存，所以如果是memcache或者redis缓存可以设置一下statsKey，避免清除了所有缓存。</li><li>或者不使用前缀，就可以正常使用queryKeys()和delete()这条流程。</li></ol>\r\n', '', 0, 'publish', 1, 0, '/article/62.html', 'https://www.goozp.com/uploads/2018/01/php_phalcon_logo_1.jpg', 0, 392, '2018-01-14 14:53:42', '2018-01-14 14:53:42', '2018-01-18 16:10:52', NULL);
INSERT INTO `pt_post` VALUES (63, 10, 'article', '一个简单的PHP分页类样式封装', '# 1. 简介\r\n封装了一个分页类，方便以后取用。\r\n\r\n只是一个简单的封装，可以在这个基础上进行改造，优化代码啊，增加配置啊什么的。\r\n\r\n效果大概是这样：\r\n![](https://www.goozp.com/uploads/2018/01/fenye_class_1.png)\r\n\r\n往下点会变成：\r\n![](https://www.goozp.com/uploads/2018/01/fenye_class_2.png)\r\n\r\n# 2. 代码\r\n```\r\n/**\r\n * 自定义分页类\r\n * @param $totalNum int 总数量\r\n * @param $current int 当前页面\r\n * @param $limit int 一页多少个\r\n * @param $baseUrl string url\r\n * @param $pageParams array 额外参数\r\n * @return string\r\n */\r\npublic function getPagination($totalNum, $current, $limit, $baseUrl, $pageParams)\r\n{\r\n    $totalPage = intval(ceil($totalNum / $limit));//总页数\r\n\r\n    $params = \'\';\r\n    if (!empty($pageParams)){\r\n        foreach ($pageParams as $k => $v){\r\n            $params .= \'&\'.$k.\'=\'.$v;\r\n        }\r\n    }\r\n\r\n    $output =   \'<ul class=\"pagination\">\';\r\n    if ($totalPage < 10){\r\n        for ($i=1; $i<=$totalPage; $i++){\r\n            if ($current == $i){\r\n                $output .= \'<li class=\"active\"><a href=\"\'. $baseUrl .\'?page=\'. $i.$params .\'\">\'. $i .\'</a></li>\';\r\n            }else{\r\n                $output .= \'<li><a href=\"\'. $baseUrl .\'?page=\'. $i.$params .\'\">\'. $i .\'</a></li>\';\r\n            }\r\n        }\r\n    } else {\r\n        $next = $current+1;\r\n        $last = $current-1;\r\n        $nextnext = $current+2;\r\n        $lastlast = $current-2;\r\n        if ($current == 1){\r\n            for ($i=1; $i<=3; $i++){\r\n                if ($current == $i){\r\n                    $output .= \'<li class=\"active\"><a href=\"\'. $baseUrl .\'?page=\'. $i.$params .\'\">\'. $i .\'</a></li>\';\r\n                }else{\r\n                    $output .= \'<li><a href=\"\'. $baseUrl .\'?page=\'. $i.$params .\'\">\'. $i .\'</a></li>\';\r\n                }\r\n            }\r\n            $output .= \'<li class=\"disabled\"><a href=\"#\">...</a></li>\';\r\n            $output .= \'<li><a href=\"\'. $baseUrl .\'?page=\'. $totalPage.$params .\'\">\'. $totalPage .\'</a></li>\';\r\n            $output .= \'<li><a href=\"\'. $baseUrl .\'?page=\'. $next.$params .\'\">»</a></li>\';\r\n        } else {\r\n            if ($lastlast >= 1){\r\n                if ($lastlast == 1){\r\n                    $output .= \'<li><a href=\"\'. $baseUrl .\'?page=1\'.$params.\'\">1</a></li>\';\r\n                }else{\r\n                    $output .= \'<li><a href=\"\'. $baseUrl .\'?page=\'. $next.$params .\'\">«</a></li>\';\r\n                    $output .= \'<li><a href=\"\'. $baseUrl .\'?page=1\'.$params.\'\">1</a></li>\';\r\n                    $output .= \'<li class=\"disabled\"><a href=\"#\">...</a></li>\';\r\n                    $output .= \'<li><a href=\"\'. $baseUrl .\'?page=\'. $lastlast.$params .\'\">\'. $lastlast .\'</a></li>\';\r\n                }\r\n            }\r\n            if ($last >= 1) {\r\n                $output .= \'<li><a href=\"\'. $baseUrl .\'?page=\'. $last.$params .\'\">\'. $last .\'</a></li>\';\r\n            }\r\n\r\n            $output .= \'<li class=\"active\"><a href=\"\'. $baseUrl .\'?page=\'. $current.$params .\'\">\'. $current .\'</a></li>\';\r\n\r\n            if ($next <= $totalPage){\r\n                $output .= \'<li><a href=\"\'. $baseUrl .\'?page=\'. $next.$params .\'\">\'. $next .\'</a></li>\';\r\n            }\r\n\r\n            if ($nextnext <= $totalPage){\r\n                if ($nextnext == $totalPage){\r\n                    $output .= \'<li><a href=\"\'. $baseUrl .\'?page=\'. $totalPage.$params .\'\">\'. $totalPage .\'</a></li>\';\r\n                }else{\r\n                    $output .= \'<li><a href=\"\'. $baseUrl .\'?page=\'. $nextnext.$params .\'\">\'. $nextnext .\'</a></li>\';\r\n                    $output .= \'<li class=\"disabled\"><a href=\"#\">...</a></li>\';\r\n                    $output .= \'<li><a href=\"\'. $baseUrl .\'?page=\'. $totalPage.$params .\'\">\'. $totalPage .\'</a></li>\';\r\n                    $output .= \'<li><a href=\"\'. $baseUrl .\'?page=\'. $next.$params .\'\">»</a></li>\';\r\n                }\r\n            }\r\n        }\r\n    }\r\n    $output .=  \'</ul>\';\r\n\r\n    return $output;\r\n}\r\n```', '<h1 id=\"h1-1-\"><a name=\"1. 简介\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1. 简介</h1><p>封装了一个分页类，方便以后取用。</p>\r\n<p>只是一个简单的封装，可以在这个基础上进行改造，优化代码啊，增加配置啊什么的。</p>\r\n<p>效果大概是这样：<br><img src=\"https://www.goozp.com/uploads/2018/01/fenye_class_1.png\" alt=\"\"></p>\r\n<p>往下点会变成：<br><img src=\"https://www.goozp.com/uploads/2018/01/fenye_class_2.png\" alt=\"\"></p>\r\n<h1 id=\"h1-2-\"><a name=\"2. 代码\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2. 代码</h1><pre><code>/**\r\n * 自定义分页类\r\n * @param $totalNum int 总数量\r\n * @param $current int 当前页面\r\n * @param $limit int 一页多少个\r\n * @param $baseUrl string url\r\n * @param $pageParams array 额外参数\r\n * @return string\r\n */\r\npublic function getPagination($totalNum, $current, $limit, $baseUrl, $pageParams)\r\n{\r\n    $totalPage = intval(ceil($totalNum / $limit));//总页数\r\n\r\n    $params = &#39;&#39;;\r\n    if (!empty($pageParams)){\r\n        foreach ($pageParams as $k =&gt; $v){\r\n            $params .= &#39;&amp;&#39;.$k.&#39;=&#39;.$v;\r\n        }\r\n    }\r\n\r\n    $output =   &#39;&lt;ul class=&quot;pagination&quot;&gt;&#39;;\r\n    if ($totalPage &lt; 10){\r\n        for ($i=1; $i&lt;=$totalPage; $i++){\r\n            if ($current == $i){\r\n                $output .= &#39;&lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;&#39;. $baseUrl .&#39;?page=&#39;. $i.$params .&#39;&quot;&gt;&#39;. $i .&#39;&lt;/a&gt;&lt;/li&gt;&#39;;\r\n            }else{\r\n                $output .= &#39;&lt;li&gt;&lt;a href=&quot;&#39;. $baseUrl .&#39;?page=&#39;. $i.$params .&#39;&quot;&gt;&#39;. $i .&#39;&lt;/a&gt;&lt;/li&gt;&#39;;\r\n            }\r\n        }\r\n    } else {\r\n        $next = $current+1;\r\n        $last = $current-1;\r\n        $nextnext = $current+2;\r\n        $lastlast = $current-2;\r\n        if ($current == 1){\r\n            for ($i=1; $i&lt;=3; $i++){\r\n                if ($current == $i){\r\n                    $output .= &#39;&lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;&#39;. $baseUrl .&#39;?page=&#39;. $i.$params .&#39;&quot;&gt;&#39;. $i .&#39;&lt;/a&gt;&lt;/li&gt;&#39;;\r\n                }else{\r\n                    $output .= &#39;&lt;li&gt;&lt;a href=&quot;&#39;. $baseUrl .&#39;?page=&#39;. $i.$params .&#39;&quot;&gt;&#39;. $i .&#39;&lt;/a&gt;&lt;/li&gt;&#39;;\r\n                }\r\n            }\r\n            $output .= &#39;&lt;li class=&quot;disabled&quot;&gt;&lt;a href=&quot;#&quot;&gt;...&lt;/a&gt;&lt;/li&gt;&#39;;\r\n            $output .= &#39;&lt;li&gt;&lt;a href=&quot;&#39;. $baseUrl .&#39;?page=&#39;. $totalPage.$params .&#39;&quot;&gt;&#39;. $totalPage .&#39;&lt;/a&gt;&lt;/li&gt;&#39;;\r\n            $output .= &#39;&lt;li&gt;&lt;a href=&quot;&#39;. $baseUrl .&#39;?page=&#39;. $next.$params .&#39;&quot;&gt;»&lt;/a&gt;&lt;/li&gt;&#39;;\r\n        } else {\r\n            if ($lastlast &gt;= 1){\r\n                if ($lastlast == 1){\r\n                    $output .= &#39;&lt;li&gt;&lt;a href=&quot;&#39;. $baseUrl .&#39;?page=1&#39;.$params.&#39;&quot;&gt;1&lt;/a&gt;&lt;/li&gt;&#39;;\r\n                }else{\r\n                    $output .= &#39;&lt;li&gt;&lt;a href=&quot;&#39;. $baseUrl .&#39;?page=&#39;. $next.$params .&#39;&quot;&gt;«&lt;/a&gt;&lt;/li&gt;&#39;;\r\n                    $output .= &#39;&lt;li&gt;&lt;a href=&quot;&#39;. $baseUrl .&#39;?page=1&#39;.$params.&#39;&quot;&gt;1&lt;/a&gt;&lt;/li&gt;&#39;;\r\n                    $output .= &#39;&lt;li class=&quot;disabled&quot;&gt;&lt;a href=&quot;#&quot;&gt;...&lt;/a&gt;&lt;/li&gt;&#39;;\r\n                    $output .= &#39;&lt;li&gt;&lt;a href=&quot;&#39;. $baseUrl .&#39;?page=&#39;. $lastlast.$params .&#39;&quot;&gt;&#39;. $lastlast .&#39;&lt;/a&gt;&lt;/li&gt;&#39;;\r\n                }\r\n            }\r\n            if ($last &gt;= 1) {\r\n                $output .= &#39;&lt;li&gt;&lt;a href=&quot;&#39;. $baseUrl .&#39;?page=&#39;. $last.$params .&#39;&quot;&gt;&#39;. $last .&#39;&lt;/a&gt;&lt;/li&gt;&#39;;\r\n            }\r\n\r\n            $output .= &#39;&lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;&#39;. $baseUrl .&#39;?page=&#39;. $current.$params .&#39;&quot;&gt;&#39;. $current .&#39;&lt;/a&gt;&lt;/li&gt;&#39;;\r\n\r\n            if ($next &lt;= $totalPage){\r\n                $output .= &#39;&lt;li&gt;&lt;a href=&quot;&#39;. $baseUrl .&#39;?page=&#39;. $next.$params .&#39;&quot;&gt;&#39;. $next .&#39;&lt;/a&gt;&lt;/li&gt;&#39;;\r\n            }\r\n\r\n            if ($nextnext &lt;= $totalPage){\r\n                if ($nextnext == $totalPage){\r\n                    $output .= &#39;&lt;li&gt;&lt;a href=&quot;&#39;. $baseUrl .&#39;?page=&#39;. $totalPage.$params .&#39;&quot;&gt;&#39;. $totalPage .&#39;&lt;/a&gt;&lt;/li&gt;&#39;;\r\n                }else{\r\n                    $output .= &#39;&lt;li&gt;&lt;a href=&quot;&#39;. $baseUrl .&#39;?page=&#39;. $nextnext.$params .&#39;&quot;&gt;&#39;. $nextnext .&#39;&lt;/a&gt;&lt;/li&gt;&#39;;\r\n                    $output .= &#39;&lt;li class=&quot;disabled&quot;&gt;&lt;a href=&quot;#&quot;&gt;...&lt;/a&gt;&lt;/li&gt;&#39;;\r\n                    $output .= &#39;&lt;li&gt;&lt;a href=&quot;&#39;. $baseUrl .&#39;?page=&#39;. $totalPage.$params .&#39;&quot;&gt;&#39;. $totalPage .&#39;&lt;/a&gt;&lt;/li&gt;&#39;;\r\n                    $output .= &#39;&lt;li&gt;&lt;a href=&quot;&#39;. $baseUrl .&#39;?page=&#39;. $next.$params .&#39;&quot;&gt;»&lt;/a&gt;&lt;/li&gt;&#39;;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    $output .=  &#39;&lt;/ul&gt;&#39;;\r\n\r\n    return $output;\r\n}\r\n</code></pre>', '', 0, 'publish', 1, 0, '/article/63.html', '', 0, 128, '2018-01-14 19:31:32', '2018-01-14 19:31:32', '2018-01-16 16:05:00', NULL);
INSERT INTO `pt_post` VALUES (64, 10, 'article', 'workerman实现服务间通讯', '# 1. 目的\r\n有时候，我们需要数据在不同的服务之间进行流通，跨服务通讯；这个时候我们就需要将数据进行服务间的转发。\r\n\r\n# 2. 应用场景\r\n可能的应用场景有：\r\n- APP通过HTTP请求发送消息给服务器，服务器通过websocket推送给web客户端\r\n- Web客户端在web端进行操作（HTTP或websocket），操作数据通过TCP由服务器推送到移动端\r\n- ......\r\n\r\n在做物联网相关的项目，可能会用得比较多。\r\n\r\n# 3. 实现方法\r\n不同的业务场景会有不同的解决方案，这里我们就不谈那些服务器crontab定时消费，用Redis队列来消费了。现在就来看看用workerman来实现，服务间数据的消费。\r\n\r\n## 3.1 进程上再增加端口监听（一个进程监听两个端口协议）\r\n通过`Worker::listen()`在Worker进程启动后动态创建新的Worker实例，能够实现同一个进程监听多个端口，支持多种协议。这是最方便的方法，将本来进程间的通讯，转化为进程内的操作。\r\n\r\n代码实例：\r\n```php\r\n<?php\r\nuse Workerman\\Worker;\r\nrequire_once \'./Workerman/Autoloader.php\';\r\n\r\n//监听一个http端口\r\n$worker = new Worker(\'websocket://0.0.0.0:1234\');\r\n\r\n// 4个进程\r\n$worker->count = 4;\r\n\r\n// 每个进程启动后在当前进程新增一个Worker监听\r\n$worker->onWorkerStart = function($worker)\r\n{\r\n    $inner_worker = new Worker(\'http://0.0.0.0:2016\');\r\n\r\n    // 设置端口复用，可以创建监听相同端口的Worker（需要PHP>=7.0）\r\n    $inner_worker->reusePort = true;\r\n\r\n    $inner_worker->onMessage = function($connection, $data)\r\n    {\r\n        global $worker;\r\n\r\n        // 转发到所有的ws连接\r\n        $message = $data;\r\n        foreach($worker->conections as $con){\r\n            $con->send($message);\r\n        }\r\n    };\r\n\r\n    // 执行监听。正常监听不会报错\r\n    $inner_worker->listen();\r\n};\r\n\r\n$worker->onMessage = function($connection, $data)\r\n{\r\n    $message = $data;\r\n    $connection->send($message);\r\n};\r\n\r\n// 运行worker\r\nWorker::runAll();\r\n```\r\n同样地我们也可以从外部监听端口处转发里面发来的消息，只需要将要调用的worker定为global来共享就可以。\r\n\r\n需要注意的是，如果PHP版本小于7.0，则不支持在多个子进程中实例化相同端口的Worker，即端口复用，只有PHP版本大于7.0才能使用：`$inner_worker->reusePort = true;`。\r\n\r\n## 3.2 用Channel分布式通讯组件订阅发布\r\n这种方式是非阻塞式IO的。Channel组件需要到官网下载，是额外的拓展包。\r\n\r\n代码实例如下：\r\n首先需要开启一个Channel服务，：\r\n```\r\n<?php\r\nuse Workerman\\Worker;\r\n\r\nrequire_once __DIR__ . \'/vendor/workerman/Autoloader.php\';\r\nrequire_once __DIR__ . \'/vendor/channel/src/Server.php\'; // 引人channel服务端文件\r\n\r\n// 初始化一个Channel服务端\r\n$channel_server = new Channel\\Server(\'0.0.0.0\', 2206);\r\n\r\n// 如果不是在根目录启动，则运行runAll方法\r\nif(!defined(\'GLOBAL_START\'))\r\n{\r\n    Worker::runAll();\r\n}\r\n```\r\n\r\n定义Websocket服务，在worker启动时定义一个广播事件：\r\n```php\r\n<?php\r\nuse \\Workerman\\Worker;\r\nuse \\Workerman\\Lib\\Timer;\r\n\r\nrequire_once __DIR__ . \'/vendor/workerman/Autoloader.php\';\r\nrequire_once __DIR__ . \'/vendor/channel/src/Client.php\';\r\n\r\n\r\n$ws_worker = new Worker(DWS_IP . \':\' . DWS_PORT);\r\n$ws_worker->count = 1;\r\n$ws_worker->name = \'pusher\';\r\n\r\n$ws_worker->onWorkerStart = function($worker)\r\n{\r\n    // Channel客户端连接到Channel服务端\r\n    Channel\\Client::connect(\'127.0.0.1\', 2206);\r\n\r\n    // 订阅广播事件\r\n    $event_name = \'pusher\';\r\n    // 收到广播事件后向当前进程内所有客户端连接发送广播数据\r\n    Channel\\Client::on($event_name, function($event_data)use($worker){\r\n        $output = $event_data[\'content\'];\r\n\r\n        foreach($worker->connections as $connection)\r\n        {\r\n            $connection->send(json_encode($output));\r\n        }\r\n    });\r\n};\r\n\r\n$ws_worker->onConnect = function($connection){};\r\n\r\n$ws_worker->onMessage = function($connection, $data){};\r\n\r\n// 运行worker\r\nWorker::runAll();\r\n\r\n```\r\n\r\n定义监听HTTP端口，收到信息时调用广播事件：\r\n```php\r\n<?php\r\nuse \\Workerman\\Worker;\r\n\r\nrequire_once __DIR__ . \'/vendor/workerman/Autoloader.php\';\r\nrequire_once __DIR__ . \'/vendor/channel/src/Client.php\';\r\n\r\n// 创建一个Worker监听8080端口，使用http协议通讯\r\n$http_worker = new Worker(\'http://:127.0.0.1：8080\');\r\n$http_worker->name = \'receiver\';\r\n$http_worker->count = 4;\r\n\r\n$http_worker->onWorkerStart = function()\r\n{\r\n    // 连接到channel\r\n    Channel\\Client::connect(\'127.0.0.1\', 2206);\r\n};\r\n\r\n\r\n$http_worker->onConnect = function($connection){};\r\n\r\n$http_worker->onMessage = function($connection, $data){\r\n\r\n    // TODO 业务逻辑\r\n\r\n    // 通过广播事件向websocket服务推送广播数据\r\n    $event_name = \'pusher\';\r\n    Channel\\Client::publish($event_name, array(\r\n        \'content\'          => $new_file\r\n    ));\r\n\r\n    $output = json_encode([\'status\' => \'success\', \'message\' => \'新文件保存成功\', \'data\' => \'\' ]);\r\n\r\n    $connection->send($output);\r\n};\r\n\r\n// 运行worker\r\nWorker::runAll();\r\n```\r\n这是一个全局广播例子，我们还可以定义成指定对象广播。通过Channel我们都可以写一个简单的点对点聊天例子了。', '<h1 id=\"h1-1-\"><a name=\"1. 目的\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1. 目的</h1><p>有时候，我们需要数据在不同的服务之间进行流通，跨服务通讯；这个时候我们就需要将数据进行服务间的转发。</p>\r\n<h1 id=\"h1-2-\"><a name=\"2. 应用场景\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2. 应用场景</h1><p>可能的应用场景有：</p>\r\n<ul>\r\n<li>APP通过HTTP请求发送消息给服务器，服务器通过websocket推送给web客户端</li><li>Web客户端在web端进行操作（HTTP或websocket），操作数据通过TCP由服务器推送到移动端</li><li>……</li></ul>\r\n<p>在做物联网相关的项目，可能会用得比较多。</p>\r\n<h1 id=\"h1-3-\"><a name=\"3. 实现方法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3. 实现方法</h1><p>不同的业务场景会有不同的解决方案，这里我们就不谈那些服务器crontab定时消费，用Redis队列来消费了。现在就来看看用workerman来实现，服务间数据的消费。</p>\r\n<h2 id=\"h2-3-1-\"><a name=\"3.1 进程上再增加端口监听（一个进程监听两个端口协议）\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.1 进程上再增加端口监听（一个进程监听两个端口协议）</h2><p>通过<code>Worker::listen()</code>在Worker进程启动后动态创建新的Worker实例，能够实现同一个进程监听多个端口，支持多种协议。这是最方便的方法，将本来进程间的通讯，转化为进程内的操作。</p>\r\n<p>代码实例：</p>\r\n<pre><code class=\"lang-php\">&lt;?php\r\nuse Workerman\\Worker;\r\nrequire_once &#39;./Workerman/Autoloader.php&#39;;\r\n\r\n//监听一个http端口\r\n$worker = new Worker(&#39;websocket://0.0.0.0:1234&#39;);\r\n\r\n// 4个进程\r\n$worker-&gt;count = 4;\r\n\r\n// 每个进程启动后在当前进程新增一个Worker监听\r\n$worker-&gt;onWorkerStart = function($worker)\r\n{\r\n    $inner_worker = new Worker(&#39;http://0.0.0.0:2016&#39;);\r\n\r\n    // 设置端口复用，可以创建监听相同端口的Worker（需要PHP&gt;=7.0）\r\n    $inner_worker-&gt;reusePort = true;\r\n\r\n    $inner_worker-&gt;onMessage = function($connection, $data)\r\n    {\r\n        global $worker;\r\n\r\n        // 转发到所有的ws连接\r\n        $message = $data;\r\n        foreach($worker-&gt;conections as $con){\r\n            $con-&gt;send($message);\r\n        }\r\n    };\r\n\r\n    // 执行监听。正常监听不会报错\r\n    $inner_worker-&gt;listen();\r\n};\r\n\r\n$worker-&gt;onMessage = function($connection, $data)\r\n{\r\n    $message = $data;\r\n    $connection-&gt;send($message);\r\n};\r\n\r\n// 运行worker\r\nWorker::runAll();\r\n</code></pre>\r\n<p>同样地我们也可以从外部监听端口处转发里面发来的消息，只需要将要调用的worker定为global来共享就可以。</p>\r\n<p>需要注意的是，如果PHP版本小于7.0，则不支持在多个子进程中实例化相同端口的Worker，即端口复用，只有PHP版本大于7.0才能使用：<code>$inner_worker-&gt;reusePort = true;</code>。</p>\r\n<h2 id=\"h2-3-2-channel-\"><a name=\"3.2 用Channel分布式通讯组件订阅发布\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.2 用Channel分布式通讯组件订阅发布</h2><p>这种方式是非阻塞式IO的。Channel组件需要到官网下载，是额外的拓展包。</p>\r\n<p>代码实例如下：<br>首先需要开启一个Channel服务，：</p>\r\n<pre><code>&lt;?php\r\nuse Workerman\\Worker;\r\n\r\nrequire_once __DIR__ . &#39;/vendor/workerman/Autoloader.php&#39;;\r\nrequire_once __DIR__ . &#39;/vendor/channel/src/Server.php&#39;; // 引人channel服务端文件\r\n\r\n// 初始化一个Channel服务端\r\n$channel_server = new Channel\\Server(&#39;0.0.0.0&#39;, 2206);\r\n\r\n// 如果不是在根目录启动，则运行runAll方法\r\nif(!defined(&#39;GLOBAL_START&#39;))\r\n{\r\n    Worker::runAll();\r\n}\r\n</code></pre><p>定义Websocket服务，在worker启动时定义一个广播事件：</p>\r\n<pre><code class=\"lang-php\">&lt;?php\r\nuse \\Workerman\\Worker;\r\nuse \\Workerman\\Lib\\Timer;\r\n\r\nrequire_once __DIR__ . &#39;/vendor/workerman/Autoloader.php&#39;;\r\nrequire_once __DIR__ . &#39;/vendor/channel/src/Client.php&#39;;\r\n\r\n\r\n$ws_worker = new Worker(DWS_IP . &#39;:&#39; . DWS_PORT);\r\n$ws_worker-&gt;count = 1;\r\n$ws_worker-&gt;name = &#39;pusher&#39;;\r\n\r\n$ws_worker-&gt;onWorkerStart = function($worker)\r\n{\r\n    // Channel客户端连接到Channel服务端\r\n    Channel\\Client::connect(&#39;127.0.0.1&#39;, 2206);\r\n\r\n    // 订阅广播事件\r\n    $event_name = &#39;pusher&#39;;\r\n    // 收到广播事件后向当前进程内所有客户端连接发送广播数据\r\n    Channel\\Client::on($event_name, function($event_data)use($worker){\r\n        $output = $event_data[&#39;content&#39;];\r\n\r\n        foreach($worker-&gt;connections as $connection)\r\n        {\r\n            $connection-&gt;send(json_encode($output));\r\n        }\r\n    });\r\n};\r\n\r\n$ws_worker-&gt;onConnect = function($connection){};\r\n\r\n$ws_worker-&gt;onMessage = function($connection, $data){};\r\n\r\n// 运行worker\r\nWorker::runAll();\r\n</code></pre>\r\n<p>定义监听HTTP端口，收到信息时调用广播事件：</p>\r\n<pre><code class=\"lang-php\">&lt;?php\r\nuse \\Workerman\\Worker;\r\n\r\nrequire_once __DIR__ . &#39;/vendor/workerman/Autoloader.php&#39;;\r\nrequire_once __DIR__ . &#39;/vendor/channel/src/Client.php&#39;;\r\n\r\n// 创建一个Worker监听8080端口，使用http协议通讯\r\n$http_worker = new Worker(&#39;http://:127.0.0.1：8080&#39;);\r\n$http_worker-&gt;name = &#39;receiver&#39;;\r\n$http_worker-&gt;count = 4;\r\n\r\n$http_worker-&gt;onWorkerStart = function()\r\n{\r\n    // 连接到channel\r\n    Channel\\Client::connect(&#39;127.0.0.1&#39;, 2206);\r\n};\r\n\r\n\r\n$http_worker-&gt;onConnect = function($connection){};\r\n\r\n$http_worker-&gt;onMessage = function($connection, $data){\r\n\r\n    // TODO 业务逻辑\r\n\r\n    // 通过广播事件向websocket服务推送广播数据\r\n    $event_name = &#39;pusher&#39;;\r\n    Channel\\Client::publish($event_name, array(\r\n        &#39;content&#39;          =&gt; $new_file\r\n    ));\r\n\r\n    $output = json_encode([&#39;status&#39; =&gt; &#39;success&#39;, &#39;message&#39; =&gt; &#39;新文件保存成功&#39;, &#39;data&#39; =&gt; &#39;&#39; ]);\r\n\r\n    $connection-&gt;send($output);\r\n};\r\n\r\n// 运行worker\r\nWorker::runAll();\r\n</code></pre>\r\n<p>这是一个全局广播例子，我们还可以定义成指定对象广播。通过Channel我们都可以写一个简单的点对点聊天例子了。</p>\r\n', '', 0, 'publish', 1, 0, '/article/64.html', '', 0, 203, '2018-01-17 11:06:36', '2018-01-17 11:06:36', '2018-01-18 16:10:15', NULL);
INSERT INTO `pt_post` VALUES (65, 10, 'article', '数据结构的基本概念', '这是一篇数据结构的学习笔记，记录一下一些常见数据结构的概念。\r\n\r\n# 1. 什么是数据结构\r\n数据结构是以某种形式将数据组织在一起的集合，它不仅存储数据，还支持访问和处理数据的操作。\r\n即：数据结构 = 数据存储 + 数据操作\r\n\r\n# 2. 什么是算法\r\n数据结构是数据存储的方式，而算法就是处理数据的方法，数据结构是数据存储的方式，而算法就是处理数据的方法。\r\n\r\n# 3. 时间复杂度和空间复杂度\r\n## 3.1 时间复杂度\r\n算法的基本操作重复执行的次数是模块n的某一个函数f(n)，因此，算法的时间复杂度记做：T(n)=O(f(n))\r\n\r\n计算时间复杂度：\r\n- 先找出算法的基本操作\r\n- 然后根据相应的各语句确定它的执行次数\r\n- 再找出 T(n) 的同数量级（它的同数量级有以下：1，log(2)n，n，n log(2)n ，n的平方，n的三次方，2的n次方，n!）\r\n- 找出后，f(n) = 该数量级\r\n- 若 T(n)/f(n) 求极限可得到一常数c\r\n- 则时间复杂度T(n) = O(f(n))\r\n\r\n## 3.2 空间复杂度\r\n一个程序的空间复杂度是指运行完一个程序所需内存的大小。\r\n\r\n一个算法所需的存储空间用f(n)表示。\r\nS(n)=O(f(n))\r\n其中n为问题的规模，S(n)表示空间复杂度。\r\n\r\n# 4. 线性结构\r\n线性结构是n个数据元素的有序（次序）集合，它有下列几个特征：\r\n1. 集合中必存在唯一的一个\"第一个元素\"；\r\n2. 集合中必存在唯一的一个\"最后的元素\"；\r\n3. 除最后元素之外，其它数据元素均有**唯一**的\"后继\"；\r\n4. 除第一元素之外，其它数据元素均有**唯一**的\"前驱\"。\r\n\r\n## 4.1 线性表\r\n线性表是一个含有n≥0个结点的有限序列，对于其中的结点，有且仅有一个开始结点没有前驱但有一个后继结点，有且仅有一个终端结点没有后继但有一个前驱结点，其它的结点都有且仅有一个前驱和一个后继结点。\r\n\r\n一般地，一个线性表可以表示成一个线性序列：k1，k2，…，kn，其中k1是开始结点，kn是终端结点。\r\n\r\n### 4.1.1 线性表的顺序表示和实现\r\n如果第一个元素的在内存上的地址为a1，每个元素占用的空间是l，那么第n个元素的地址就是a1+(n-1) x l。\r\n\r\n| 内存中存储的地址 | 位置 |\r\n|---|---|\r\n|a1 | 1|\r\n|a1+l | 2|\r\n|a1+2l | 3 |\r\n|... |  ...|\r\n|a1 + (n-1) × l | n|\r\n只要确定了第一个元素的地址，那么我们可以对线性表中的任一元素随机存取。\r\n\r\n### 4.1.2 线性表的顺序表示和实现（链表）\r\n线性表的顺序存储结构是逻辑位置和物理位置都相邻，而链式存储结构是逻辑位置相邻，但物理位置不一定相邻，相比顺序存储结构，它不能随机存取，但在插入和删除操作时不需要移动元素，大大提高了增加和删除元素的效率。\r\n\r\n#### 线性链表/单链表\r\n通常链式存储结构会有一个个结点组成，结点中包含两个域一个是数据域，一个是指针域，**数据域中存储数据**，**指针域中存储下一个后继元素的地址**，如下图所示，这一个个结点组成链表，也称线性链表或单链表。\r\n\r\n内存中存储的地址 | 数据域 | 指针域\r\n---|---|---\r\n2 | Hello | 20\r\n8 | World | NULL\r\n18 | goozp | 8\r\n10 | zPhal | 18\r\n26 | 有意思 | 2\r\n\r\n单链表的逻辑结构图：\r\n![单链表](https://www.goozp.com/uploads/2018/01/%E5%8D%95%E9%93%BE%E8%A1%A8.png)\r\n\r\n#### 循环链表\r\n循环链表的特点是最后一个结点的指针指向头结点，形成一个环。\r\n![循环链表](https://www.goozp.com/uploads/2018/01/%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8.png)\r\n\r\n#### 双向链表\r\n双向链表的特点是结点中多了一个指向前驱元素的指针。\r\n![双向链表](https://www.goozp.com/uploads/2018/01/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.png)\r\n\r\n## 4.2 栈和队列\r\n其实栈和队列也是线性表，只是它们是操作受限的线性表。\r\n\r\n### 4.2.1 栈\r\n栈是只能在表尾进行插入或删除操作的线性表，通常我们称表尾端为栈顶，表头端为栈底。\r\n\r\n它是一种先进后出的线性表，既只能在表尾端插入元素，称为入栈，也只能在表尾端删除元素，称为退栈。\r\n![栈](https://www.goozp.com/uploads/2018/01/%E6%A0%88.png)\r\n\r\n栈既然也是线性表，那么它也有顺序存储结构和链式存储结构两种表示方法。\r\n\r\n### 4.2.2 队列\r\n队列刚好和栈相反，它是一种先进先出的线性表，只能在一端插入元素，在另一端删除元素。\r\n\r\n允许插入元素的一端称为队尾，允许删除元素的一端称为队头。\r\n![队列](https://www.goozp.com/uploads/2018/01/%E9%98%9F%E5%88%97.png)\r\n\r\n队列也一样有顺序和链式存储结构两种表示方法。\r\n\r\n\r\n# 5. 非线性结构\r\n## 5.1 树\r\n树是由n（n>=1）个有限节点组成一个具有层次关系的集合。\r\n\r\n一种树形结构：\r\n![树](https://www.goozp.com/uploads/2018/01/%E6%A0%91_%E6%99%AE%E9%80%9A.png)\r\n\r\n树的结构：\r\n- **节点的度**：一个节点含有的子树的个数称为该节点的度；\r\n- **叶节点或终端节点**：度为0的节点称为叶节点；\r\n- **非终端节点或分支节点**：度不为0的节点；\r\n- **双亲节点或父节点**：若一个节点含有子节点，则这个节点称为其子节点的父节点；\r\n- **孩子节点或子节点**：一个节点含有的子树的根节点称为该节点的子节点；\r\n- **兄弟节点**：具有相同父节点的节点互称为兄弟节点；\r\n- **树的度**：一棵树中，最大的节点的度称为树的度；\r\n- **节点的层次**：从根开始定义起，根为第1层，根的子节点为第2层，以此类推；\r\n- **树的高度或深度**：树中节点的最大层次；\r\n- **堂兄弟节点**：双亲在同一层的节点互为堂兄弟；\r\n- **节点的祖先**：从根到该节点所经分支上的所有节点；\r\n- **子孙**：以某节点为根的子树中任一节点都称为该节点的子孙。\r\n- **森林**：由m（m>=0）棵互不相交的树的集合称为森林；\r\n\r\n### 5.1.1 二叉树\r\n二叉树的特点是一个结点的直接子节点**最多**只能有两个，并且有左右之分。\r\n\r\n二叉树中有种常见的称为**完全二叉树**的结构，它的特点是除最后一层外每一层的结点数为 $$2i-1$$：\r\n![完全二叉树1](https://www.goozp.com/uploads/2018/01/%E6%A0%91_%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91.png)\r\n\r\n最后一层的结点数若不满足 $$2^i-1$$，那么最后一层的结点是自左向右排列的：\r\n![完全二叉树2](https://www.goozp.com/uploads/2018/01/%E6%A0%91_%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91_2.png)\r\n\r\n#### 堆\r\n堆是一种经过排序的完全二叉树，其中任一非叶子节点的值均不大于（或不小于）其左孩子和右孩子节点的值。\r\n\r\n最大堆和最小堆是二叉堆的两种形式。\r\n最大堆：根结点的键值是所有堆结点键值中最大者。\r\n![最大堆](https://www.goozp.com/uploads/2018/01/%E6%9C%80%E5%A4%A7%E5%A0%86.png)\r\n\r\n最小堆：根结点的键值是所有堆结点键值中最小者。\r\n![最小堆](https://www.goozp.com/uploads/2018/01/%E6%9C%80%E5%B0%8F%E5%A0%86.png)\r\n\r\n#### 二叉排序树\r\n叉排序树又称二叉查找树，亦称二叉搜索树。\r\n\r\n它或者是一棵空树；或者是具有下列性质的二叉树：\r\n1. 若左子树不空，则左子树上所有结点的值均小于它的根结点的值；\r\n2. 若右子树不空，则右子树上所有结点的值均大于它的根结点的值；\r\n3. 左、右子树也分别为二叉排序树；\r\n\r\n![二叉排序树](https://www.goozp.com/uploads/2018/01/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91.png)\r\n\r\n#### 平衡二叉树\r\n平衡二叉树又被称为AVL树。\r\n\r\n它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。\r\n![平衡二叉树](https://www.goozp.com/uploads/2018/01/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.png)\r\n\r\n#### 哈夫曼树\r\n哈夫曼树也称最优二叉树，它是带权路径长度最小的二叉树。\r\n\r\n哈夫曼树的构造步骤如下：\r\n假设有n个权值，则构造出的哈夫曼树有n个叶子结点。 n个权值分别设为 w1、w2、…、wn，则哈夫曼树的构造规则为：\r\n1. 将w1、w2、…、wn看成是有n 棵树的集合(每棵树仅有一个结点)；\r\n2. 在集合中选出两个根结点的权值最小的树合并，作为一棵新树的左、右子树，且新树的根结点权值为其左、右子树根结点权值之和；\r\n3. 从集合中删除选取的两棵树，并将新树加入集合；\r\n4. 重复第2、第3步，直到集合中只剩一棵树为止，该树即为所求得的哈夫曼树。\r\n\r\n## 5.2 图\r\n### 5.1 什么是图\r\n\r\n### 5.2 图的表示和实现\r\n表示图通常有四种方法--数组表示法、邻接表、十字链表和邻接多重表。\r\n\r\n### 5.3 图的表示和实现\r\n通常图的遍历有两种：深度优先搜索和广度优先搜索。\r\n\r\n**深度优先搜索**是树的先根遍历的推广，它的基本思想是：从图G的某个顶点v0出发，访问v0，然后选择一个与v0相邻且没被访问过的顶点vi访问，再从vi出发选择一个与vi相邻且未被访问的顶点vj进行访问，依次继续。如果当前被访问过的顶点的所有邻接顶点都已被访问，则退回到已被访问的顶点序列中最后一个拥有未被访问的相邻顶点的顶点w，从w出发按同样的方法向前遍历，直到图中所有顶点都被访问。\r\n\r\n**广度优先搜索**是树的按层次遍历的推广，它的基本思想是：首先访问初始点vi，并将其标记为已访问过，接着访问vi的所有未被访问过的邻接点vi1,vi2,…, vin，并均标记已访问过，然后再按照vi1,vi2,…, vin的次序，访问每一个顶点的所有未被访问过的邻接点，并均标记为已访问过，依次类推，直到图中所有和初始点vi有路径相通的顶点都被访问过为止。\r\n\r\n### 5.4 最小生成树\r\n一个有n个结点的连通图的生成树是原图的极小连通子图，且包含原图中的所有n个结点，并且有保持图连通的最少的边。最小生成树可以用kruskal（克鲁斯卡尔）算法或Prim（普里姆）算法求出。\r\n\r\n### 5.5 拓扑排序\r\n拓扑排序简单地说，就是在有向图中，想访问一个顶点需要先访问它的所有前驱顶点。它的执行步骤为：\r\n1. 在有向图中选一个没有前驱的顶点输出。\r\n2. 从图中删除该顶点和所有以它为尾的弧。 重复上述步骤直到所有顶点都输出或者图中不存在无前驱的顶点为止，后者说明图中有环。\r\n\r\n### 5.6 最短路径问题\r\n寻找图（由结点和路径组成的）中两结点之间的最短路径。', '<p>这是一篇数据结构的学习笔记，记录一下一些常见数据结构的概念。</p>\r\n<h1 id=\"h1-1-\"><a name=\"1. 什么是数据结构\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1. 什么是数据结构</h1><p>数据结构是以某种形式将数据组织在一起的集合，它不仅存储数据，还支持访问和处理数据的操作。<br>即：数据结构 = 数据存储 + 数据操作</p>\r\n<h1 id=\"h1-2-\"><a name=\"2. 什么是算法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2. 什么是算法</h1><p>数据结构是数据存储的方式，而算法就是处理数据的方法，数据结构是数据存储的方式，而算法就是处理数据的方法。</p>\r\n<h1 id=\"h1-3-\"><a name=\"3. 时间复杂度和空间复杂度\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3. 时间复杂度和空间复杂度</h1><h2 id=\"h2-3-1-\"><a name=\"3.1 时间复杂度\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.1 时间复杂度</h2><p>算法的基本操作重复执行的次数是模块n的某一个函数f(n)，因此，算法的时间复杂度记做：T(n)=O(f(n))</p>\r\n<p>计算时间复杂度：</p>\r\n<ul>\r\n<li>先找出算法的基本操作</li><li>然后根据相应的各语句确定它的执行次数</li><li>再找出 T(n) 的同数量级（它的同数量级有以下：1，log(2)n，n，n log(2)n ，n的平方，n的三次方，2的n次方，n!）</li><li>找出后，f(n) = 该数量级</li><li>若 T(n)/f(n) 求极限可得到一常数c</li><li>则时间复杂度T(n) = O(f(n))</li></ul>\r\n<h2 id=\"h2-3-2-\"><a name=\"3.2 空间复杂度\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.2 空间复杂度</h2><p>一个程序的空间复杂度是指运行完一个程序所需内存的大小。</p>\r\n<p>一个算法所需的存储空间用f(n)表示。<br>S(n)=O(f(n))<br>其中n为问题的规模，S(n)表示空间复杂度。</p>\r\n<h1 id=\"h1-4-\"><a name=\"4. 线性结构\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4. 线性结构</h1><p>线性结构是n个数据元素的有序（次序）集合，它有下列几个特征：</p>\r\n<ol>\r\n<li>集合中必存在唯一的一个”第一个元素”；</li><li>集合中必存在唯一的一个”最后的元素”；</li><li>除最后元素之外，其它数据元素均有<strong>唯一</strong>的”后继”；</li><li>除第一元素之外，其它数据元素均有<strong>唯一</strong>的”前驱”。</li></ol>\r\n<h2 id=\"h2-4-1-\"><a name=\"4.1 线性表\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.1 线性表</h2><p>线性表是一个含有n≥0个结点的有限序列，对于其中的结点，有且仅有一个开始结点没有前驱但有一个后继结点，有且仅有一个终端结点没有后继但有一个前驱结点，其它的结点都有且仅有一个前驱和一个后继结点。</p>\r\n<p>一般地，一个线性表可以表示成一个线性序列：k1，k2，…，kn，其中k1是开始结点，kn是终端结点。</p>\r\n<h3 id=\"h3-4-1-1-\"><a name=\"4.1.1 线性表的顺序表示和实现\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.1.1 线性表的顺序表示和实现</h3><p>如果第一个元素的在内存上的地址为a1，每个元素占用的空间是l，那么第n个元素的地址就是a1+(n-1) x l。</p>\r\n<table>\r\n<thead>\r\n<tr>\r\n<th>内存中存储的地址</th>\r\n<th>位置</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr>\r\n<td>a1</td>\r\n<td>1</td>\r\n</tr>\r\n<tr>\r\n<td>a1+l</td>\r\n<td>2</td>\r\n</tr>\r\n<tr>\r\n<td>a1+2l</td>\r\n<td>3</td>\r\n</tr>\r\n<tr>\r\n<td>…</td>\r\n<td>…</td>\r\n</tr>\r\n<tr>\r\n<td>a1 + (n-1) × l</td>\r\n<td>n</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<p>只要确定了第一个元素的地址，那么我们可以对线性表中的任一元素随机存取。</p>\r\n<h3 id=\"h3-4-1-2-\"><a name=\"4.1.2 线性表的顺序表示和实现（链表）\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.1.2 线性表的顺序表示和实现（链表）</h3><p>线性表的顺序存储结构是逻辑位置和物理位置都相邻，而链式存储结构是逻辑位置相邻，但物理位置不一定相邻，相比顺序存储结构，它不能随机存取，但在插入和删除操作时不需要移动元素，大大提高了增加和删除元素的效率。</p>\r\n<h4 id=\"h4--\"><a name=\"线性链表/单链表\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>线性链表/单链表</h4><p>通常链式存储结构会有一个个结点组成，结点中包含两个域一个是数据域，一个是指针域，<strong>数据域中存储数据</strong>，<strong>指针域中存储下一个后继元素的地址</strong>，如下图所示，这一个个结点组成链表，也称线性链表或单链表。</p>\r\n<table>\r\n<thead>\r\n<tr>\r\n<th>内存中存储的地址</th>\r\n<th>数据域</th>\r\n<th>指针域</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr>\r\n<td>2</td>\r\n<td>Hello</td>\r\n<td>20</td>\r\n</tr>\r\n<tr>\r\n<td>8</td>\r\n<td>World</td>\r\n<td>NULL</td>\r\n</tr>\r\n<tr>\r\n<td>18</td>\r\n<td>goozp</td>\r\n<td>8</td>\r\n</tr>\r\n<tr>\r\n<td>10</td>\r\n<td>zPhal</td>\r\n<td>18</td>\r\n</tr>\r\n<tr>\r\n<td>26</td>\r\n<td>有意思</td>\r\n<td>2</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<p>单链表的逻辑结构图：<br><img src=\"https://www.goozp.com/uploads/2018/01/%E5%8D%95%E9%93%BE%E8%A1%A8.png\" alt=\"单链表\"></p>\r\n<h4 id=\"h4-u5FAAu73AFu94FEu8868\"><a name=\"循环链表\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>循环链表</h4><p>循环链表的特点是最后一个结点的指针指向头结点，形成一个环。<br><img src=\"https://www.goozp.com/uploads/2018/01/%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8.png\" alt=\"循环链表\"></p>\r\n<h4 id=\"h4-u53CCu5411u94FEu8868\"><a name=\"双向链表\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>双向链表</h4><p>双向链表的特点是结点中多了一个指向前驱元素的指针。<br><img src=\"https://www.goozp.com/uploads/2018/01/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.png\" alt=\"双向链表\"></p>\r\n<h2 id=\"h2-4-2-\"><a name=\"4.2 栈和队列\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.2 栈和队列</h2><p>其实栈和队列也是线性表，只是它们是操作受限的线性表。</p>\r\n<h3 id=\"h3-4-2-1-\"><a name=\"4.2.1 栈\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.2.1 栈</h3><p>栈是只能在表尾进行插入或删除操作的线性表，通常我们称表尾端为栈顶，表头端为栈底。</p>\r\n<p>它是一种先进后出的线性表，既只能在表尾端插入元素，称为入栈，也只能在表尾端删除元素，称为退栈。<br><img src=\"https://www.goozp.com/uploads/2018/01/%E6%A0%88.png\" alt=\"栈\"></p>\r\n<p>栈既然也是线性表，那么它也有顺序存储结构和链式存储结构两种表示方法。</p>\r\n<h3 id=\"h3-4-2-2-\"><a name=\"4.2.2 队列\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.2.2 队列</h3><p>队列刚好和栈相反，它是一种先进先出的线性表，只能在一端插入元素，在另一端删除元素。</p>\r\n<p>允许插入元素的一端称为队尾，允许删除元素的一端称为队头。<br><img src=\"https://www.goozp.com/uploads/2018/01/%E9%98%9F%E5%88%97.png\" alt=\"队列\"></p>\r\n<p>队列也一样有顺序和链式存储结构两种表示方法。</p>\r\n<h1 id=\"h1-5-\"><a name=\"5. 非线性结构\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5. 非线性结构</h1><h2 id=\"h2-5-1-\"><a name=\"5.1 树\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.1 树</h2><p>树是由n（n&gt;=1）个有限节点组成一个具有层次关系的集合。</p>\r\n<p>一种树形结构：<br><img src=\"https://www.goozp.com/uploads/2018/01/%E6%A0%91_%E6%99%AE%E9%80%9A.png\" alt=\"树\"></p>\r\n<p>树的结构：</p>\r\n<ul>\r\n<li><strong>节点的度</strong>：一个节点含有的子树的个数称为该节点的度；</li><li><strong>叶节点或终端节点</strong>：度为0的节点称为叶节点；</li><li><strong>非终端节点或分支节点</strong>：度不为0的节点；</li><li><strong>双亲节点或父节点</strong>：若一个节点含有子节点，则这个节点称为其子节点的父节点；</li><li><strong>孩子节点或子节点</strong>：一个节点含有的子树的根节点称为该节点的子节点；</li><li><strong>兄弟节点</strong>：具有相同父节点的节点互称为兄弟节点；</li><li><strong>树的度</strong>：一棵树中，最大的节点的度称为树的度；</li><li><strong>节点的层次</strong>：从根开始定义起，根为第1层，根的子节点为第2层，以此类推；</li><li><strong>树的高度或深度</strong>：树中节点的最大层次；</li><li><strong>堂兄弟节点</strong>：双亲在同一层的节点互为堂兄弟；</li><li><strong>节点的祖先</strong>：从根到该节点所经分支上的所有节点；</li><li><strong>子孙</strong>：以某节点为根的子树中任一节点都称为该节点的子孙。</li><li><strong>森林</strong>：由m（m&gt;=0）棵互不相交的树的集合称为森林；</li></ul>\r\n<h3 id=\"h3-5-1-1-\"><a name=\"5.1.1 二叉树\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.1.1 二叉树</h3><p>二叉树的特点是一个结点的直接子节点<strong>最多</strong>只能有两个，并且有左右之分。</p>\r\n<p>二叉树中有种常见的称为<strong>完全二叉树</strong>的结构，它的特点是除最后一层外每一层的结点数为 <span class=\"editormd-tex\">2i-1</span>：<br><img src=\"https://www.goozp.com/uploads/2018/01/%E6%A0%91_%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91.png\" alt=\"完全二叉树1\"></p>\r\n<p>最后一层的结点数若不满足 <span class=\"editormd-tex\">2^i-1</span>，那么最后一层的结点是自左向右排列的：<br><img src=\"https://www.goozp.com/uploads/2018/01/%E6%A0%91_%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91_2.png\" alt=\"完全二叉树2\"></p>\r\n<h4 id=\"h4-u5806\"><a name=\"堆\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>堆</h4><p>堆是一种经过排序的完全二叉树，其中任一非叶子节点的值均不大于（或不小于）其左孩子和右孩子节点的值。</p>\r\n<p>最大堆和最小堆是二叉堆的两种形式。<br>最大堆：根结点的键值是所有堆结点键值中最大者。<br><img src=\"https://www.goozp.com/uploads/2018/01/%E6%9C%80%E5%A4%A7%E5%A0%86.png\" alt=\"最大堆\"></p>\r\n<p>最小堆：根结点的键值是所有堆结点键值中最小者。<br><img src=\"https://www.goozp.com/uploads/2018/01/%E6%9C%80%E5%B0%8F%E5%A0%86.png\" alt=\"最小堆\"></p>\r\n<h4 id=\"h4-u4E8Cu53C9u6392u5E8Fu6811\"><a name=\"二叉排序树\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二叉排序树</h4><p>叉排序树又称二叉查找树，亦称二叉搜索树。</p>\r\n<p>它或者是一棵空树；或者是具有下列性质的二叉树：</p>\r\n<ol>\r\n<li>若左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li><li>若右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li><li>左、右子树也分别为二叉排序树；</li></ol>\r\n<p><img src=\"https://www.goozp.com/uploads/2018/01/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91.png\" alt=\"二叉排序树\"></p>\r\n<h4 id=\"h4-u5E73u8861u4E8Cu53C9u6811\"><a name=\"平衡二叉树\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>平衡二叉树</h4><p>平衡二叉树又被称为AVL树。</p>\r\n<p>它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。<br><img src=\"https://www.goozp.com/uploads/2018/01/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.png\" alt=\"平衡二叉树\"></p>\r\n<h4 id=\"h4-u54C8u592Bu66FCu6811\"><a name=\"哈夫曼树\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>哈夫曼树</h4><p>哈夫曼树也称最优二叉树，它是带权路径长度最小的二叉树。</p>\r\n<p>哈夫曼树的构造步骤如下：<br>假设有n个权值，则构造出的哈夫曼树有n个叶子结点。 n个权值分别设为 w1、w2、…、wn，则哈夫曼树的构造规则为：</p>\r\n<ol>\r\n<li>将w1、w2、…、wn看成是有n 棵树的集合(每棵树仅有一个结点)；</li><li>在集合中选出两个根结点的权值最小的树合并，作为一棵新树的左、右子树，且新树的根结点权值为其左、右子树根结点权值之和；</li><li>从集合中删除选取的两棵树，并将新树加入集合；</li><li>重复第2、第3步，直到集合中只剩一棵树为止，该树即为所求得的哈夫曼树。</li></ol>\r\n<h2 id=\"h2-5-2-\"><a name=\"5.2 图\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.2 图</h2><h3 id=\"h3-5-1-\"><a name=\"5.1 什么是图\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.1 什么是图</h3><h3 id=\"h3-5-2-\"><a name=\"5.2 图的表示和实现\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.2 图的表示和实现</h3><p>表示图通常有四种方法—数组表示法、邻接表、十字链表和邻接多重表。</p>\r\n<h3 id=\"h3-5-3-\"><a name=\"5.3 图的表示和实现\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.3 图的表示和实现</h3><p>通常图的遍历有两种：深度优先搜索和广度优先搜索。</p>\r\n<p><strong>深度优先搜索</strong>是树的先根遍历的推广，它的基本思想是：从图G的某个顶点v0出发，访问v0，然后选择一个与v0相邻且没被访问过的顶点vi访问，再从vi出发选择一个与vi相邻且未被访问的顶点vj进行访问，依次继续。如果当前被访问过的顶点的所有邻接顶点都已被访问，则退回到已被访问的顶点序列中最后一个拥有未被访问的相邻顶点的顶点w，从w出发按同样的方法向前遍历，直到图中所有顶点都被访问。</p>\r\n<p><strong>广度优先搜索</strong>是树的按层次遍历的推广，它的基本思想是：首先访问初始点vi，并将其标记为已访问过，接着访问vi的所有未被访问过的邻接点vi1,vi2,…, vin，并均标记已访问过，然后再按照vi1,vi2,…, vin的次序，访问每一个顶点的所有未被访问过的邻接点，并均标记为已访问过，依次类推，直到图中所有和初始点vi有路径相通的顶点都被访问过为止。</p>\r\n<h3 id=\"h3-5-4-\"><a name=\"5.4 最小生成树\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.4 最小生成树</h3><p>一个有n个结点的连通图的生成树是原图的极小连通子图，且包含原图中的所有n个结点，并且有保持图连通的最少的边。最小生成树可以用kruskal（克鲁斯卡尔）算法或Prim（普里姆）算法求出。</p>\r\n<h3 id=\"h3-5-5-\"><a name=\"5.5 拓扑排序\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.5 拓扑排序</h3><p>拓扑排序简单地说，就是在有向图中，想访问一个顶点需要先访问它的所有前驱顶点。它的执行步骤为：</p>\r\n<ol>\r\n<li>在有向图中选一个没有前驱的顶点输出。</li><li>从图中删除该顶点和所有以它为尾的弧。 重复上述步骤直到所有顶点都输出或者图中不存在无前驱的顶点为止，后者说明图中有环。</li></ol>\r\n<h3 id=\"h3-5-6-\"><a name=\"5.6 最短路径问题\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.6 最短路径问题</h3><p>寻找图（由结点和路径组成的）中两结点之间的最短路径。</p>\r\n', '', 0, 'publish', 1, 0, '/article/65.html', '', 0, 115, '2018-01-23 06:43:04', '2018-01-23 06:43:04', '2018-01-23 06:43:04', NULL);
INSERT INTO `pt_post` VALUES (66, 10, 'article', 'LeetCode刷题之1：Two Sum（1）', '准备定期刷一刷LeetCode上的题目，并且做一做笔记，这是第一篇。算法实现将采用Go语言。\r\n\r\n# 1. 题目\r\nGiven an array of integers, return indices of the two numbers such that they add up to a specific target.\r\n\r\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\r\n\r\nExample:\r\n```\r\nGiven nums = [2, 7, 11, 15], target = 9,\r\n\r\nBecause nums[0] + nums[1] = 2 + 7 = 9,\r\nreturn [0, 1].\r\n```\r\n\r\n# 2. 中文分析\r\n给予一个包含整数的数组和一个目标值，返回数组其中两个相加等于目标值的成员的下标。\r\n\r\n# 3. 解答\r\n## 3.1 解法1\r\n暴力解法\r\n```go\r\nfunc twoSum(nums []int, target int) (output []int) {\r\n    size := len(nums)\r\n    for i := 0; i < size; i++ {\r\n        for j := i + 1; j < size; j++ {\r\n            if nums[i] + nums[j] == target {\r\n                output = []int{i, j}\r\n                return\r\n            }\r\n        }\r\n    }\r\n    return\r\n}\r\n```\r\n\r\n这个解的Runtime是: 85 ms\r\n时间复杂度：$$O(n^2)$$\r\n\r\n## 3.2 解法2\r\n通过go语言的map来做，相当于哈希表来做。\r\n```\r\nfunc twoSum(nums []int, target int)[]int {\r\n    m := make(map[int]int, len(nums))\r\n    for k, v := range nums {\r\n        m[v] = k\r\n    }\r\n\r\n    for i, v := range nums {\r\n        complement := target - v\r\n        if j, ok := m[complement]; ok && j!=i {\r\n            return []int{j, i}\r\n        }\r\n    }\r\n\r\n    return nil\r\n}\r\n```\r\n这个解的Runtime是: 10 ms\r\n时间复杂度：$$O(n)$$\r\n\r\n## 3.3 解法3\r\n类似于解法2，解法先生成map，而解法3一边对比一边生成，效率上差别不大\r\n```\r\nfunc twoSum(nums []int, target int)[]int {\r\n    m := make(map[int]int, len(nums))\r\n    for i, v := range nums {\r\n        if j, ok := m[v]; ok {\r\n            return []int{j, i}\r\n        } else {\r\n            m[target-v] = i\r\n        }\r\n    }\r\n\r\n    return nil\r\n}\r\n```\r\n这个解的Runtime是: 9 ms\r\n时间复杂度：$$O(n)$$\r\n\r\n', '<p>准备定期刷一刷LeetCode上的题目，并且做一做笔记，这是第一篇。算法实现将采用Go语言。</p>\r\n<h1 id=\"h1-1-\"><a name=\"1. 题目\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1. 题目</h1><p>Given an array of integers, return indices of the two numbers such that they add up to a specific target.</p>\r\n<p>You may assume that each input would have exactly one solution, and you may not use the same element twice.</p>\r\n<p>Example:</p>\r\n<pre><code>Given nums = [2, 7, 11, 15], target = 9,\r\n\r\nBecause nums[0] + nums[1] = 2 + 7 = 9,\r\nreturn [0, 1].\r\n</code></pre><h1 id=\"h1-2-\"><a name=\"2. 中文分析\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2. 中文分析</h1><p>给予一个包含整数的数组和一个目标值，返回数组其中两个相加等于目标值的成员的下标。</p>\r\n<h1 id=\"h1-3-\"><a name=\"3. 解答\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3. 解答</h1><h2 id=\"h2-3-1-1\"><a name=\"3.1 解法1\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.1 解法1</h2><p>暴力解法</p>\r\n<pre><code class=\"lang-go\">func twoSum(nums []int, target int) (output []int) {\r\n    size := len(nums)\r\n    for i := 0; i &lt; size; i++ {\r\n        for j := i + 1; j &lt; size; j++ {\r\n            if nums[i] + nums[j] == target {\r\n                output = []int{i, j}\r\n                return\r\n            }\r\n        }\r\n    }\r\n    return\r\n}\r\n</code></pre>\r\n<p>这个解的Runtime是: 85 ms<br>时间复杂度：<span class=\"editormd-tex\">O(n^2)</span></p>\r\n<h2 id=\"h2-3-2-2\"><a name=\"3.2 解法2\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.2 解法2</h2><p>通过go语言的map来做，相当于哈希表来做。</p>\r\n<pre><code>func twoSum(nums []int, target int)[]int {\r\n    m := make(map[int]int, len(nums))\r\n    for k, v := range nums {\r\n        m[v] = k\r\n    }\r\n\r\n    for i, v := range nums {\r\n        complement := target - v\r\n        if j, ok := m[complement]; ok &amp;&amp; j!=i {\r\n            return []int{j, i}\r\n        }\r\n    }\r\n\r\n    return nil\r\n}\r\n</code></pre><p>这个解的Runtime是: 10 ms<br>时间复杂度：<span class=\"editormd-tex\">O(n)</span></p>\r\n<h2 id=\"h2-3-3-3\"><a name=\"3.3 解法3\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.3 解法3</h2><p>类似于解法2，解法先生成map，而解法3一边对比一边生成，效率上差别不大</p>\r\n<pre><code>func twoSum(nums []int, target int)[]int {\r\n    m := make(map[int]int, len(nums))\r\n    for i, v := range nums {\r\n        if j, ok := m[v]; ok {\r\n            return []int{j, i}\r\n        } else {\r\n            m[target-v] = i\r\n        }\r\n    }\r\n\r\n    return nil\r\n}\r\n</code></pre><p>这个解的Runtime是: 9 ms<br>时间复杂度：<span class=\"editormd-tex\">O(n)</span></p>\r\n', '', 0, 'publish', 1, 0, '/article/66.html', '', 0, 107, '2018-01-24 06:17:34', '2018-01-24 06:17:34', '2018-01-24 06:22:38', NULL);
INSERT INTO `pt_post` VALUES (67, 10, 'article', 'Go语言内置类型和函数', 'Go语言中，有一些内置的类型和函数，不需要导入任何东西就可以使用，包括一些内置函数，初学Go，这些函数花几分钟记一记。\r\n官方参考资料：[Package builtin](https://golang.org/pkg/builtin/#error \"Package builtin\")\r\n\r\n# 1. 内置类型\r\n- Constants\r\n- Variables\r\n- type ComplexType\r\n- type FloatType\r\n- type IntegerType\r\n- type Type\r\n- type Type1\r\n- type bool\r\n- type byte\r\n- type complex128\r\n- type complex64\r\n- type error\r\n- type float32\r\n- type float64\r\n- type int\r\n- type int16\r\n- type int32\r\n- type int64\r\n- type int8\r\n- type rune\r\n- type string\r\n- type uint\r\n- type uint16\r\n- type uint32\r\n- type uint64\r\n- type uint8\r\n- type uintptr\r\n\r\n\r\nbyte 类型等价于 uint8 类型。\r\n\r\nrune 类型等价于 int32 类型。\r\n\r\n其中error类型是一个接口：\r\n```go\r\ntype error interface {\r\n	Error() string\r\n}\r\n```\r\n\r\n# 2. 内置函数\r\n## func append\r\n往slice切片中追加元素，返回更新后的slice。\r\n```\r\nfunc append(slice []Type, elems ...Type) []Type\r\n```\r\n\r\n示例：\r\n```\r\nslice = append(slice, elem1, elem2) // 追加slice\r\nslice = append(slice, anotherSlice...) // 合并slice\r\n```\r\n特殊例子：\r\n```\r\n// 往byte类型的slice中添加string类型\r\nslice = append([]byte(\"hello \"), \"world\"...)\r\n```\r\n\r\n## func cap\r\n根据类型返回容量\r\n```\r\nfunc cap(v Type) int\r\n```\r\n\r\nv的类型为以类型下时：\r\n- 数组：返回 v 元素的数量（相当于len(v)）\r\n- 数组指针：返回 *v 元素的数量（相当于len(v)）\r\n- 切片：可以达到的最大长度；如果 v 是 nil，cap(v) 返回 0\r\n- Channel通道：channel 的 buffer 容量；如果 v 是 nil，cap(v) 返回 0\r\n\r\n## func close\r\n关闭channel通道。应该在发送端关闭，而不是在接收端，防止阻塞。\r\n```\r\nfunc close(c chan<- Type)\r\n```\r\n\r\n以下操作对于关闭的channel会将ok设为false：\r\n```\r\nx, ok := <-c\r\n```\r\n\r\n## func complex\r\n通过两个浮点数创建一个复数。\r\n```\r\nfunc complex(r, i FloatType) ComplexType\r\n```\r\n实部和虚部要大小相同， 比如 float32 或者 float64。返回相对的合成类型；比如对于float32返回complex64, 对于float64返回complex128。\r\n\r\n## func copy\r\n复制一个切片。返回复制的元素数量。\r\n```\r\nfunc copy(dst, src []Type) int\r\n```\r\n\r\n## func delete\r\n删除map中指定key的元素。\r\n```\r\nfunc delete(m map[Type]Type1, key Type)\r\n```\r\n如果m是空的或者不存在key对于的元素，delete为空操作。\r\n\r\n## func real\r\n返回复数的实数部分。\r\n```\r\nfunc real(c ComplexType) FloatType\r\n```\r\n返回值的类型根据原始 c 的数据类型来返回。\r\n\r\n## func imag\r\n返回复数的虚数部分。\r\n```\r\nfunc imag(c ComplexType) FloatType\r\n```\r\n返回值的类型根据原始 c 的数据类型来返回。\r\n\r\n## func len\r\n根据类型返回 v 的长度。\r\n```\r\nfunc len(v Type) int\r\n```\r\n\r\nv为以下类型时：\r\n- 数组：v 中元素的数量\r\n- 数组指针：*v 中元素的数量（即使 v 是 nil）\r\n- 切片slice 或者 字典map：v 中元素的数量；如果 v 是 nil, len(v) 返回0.\r\n- 字符串：v 中 bytes 的数目\r\n- 通道Channel：channel buffer 队列中的元素数量；如果 v 是 nil, len(v) 返回0.\r\n\r\n## func make\r\n分配和申明 slice，map，或者 channel 对象。\r\n```\r\nfunc make(t Type, size ...IntegerType) Type\r\n```\r\n类似于 new ，第一个参数是一个类型，而不是一个值。\r\n与 new 不同的是 make 返回的类型与参数相同，而不是一个指针。\r\n\r\n具体的取决于要make的对象有所不同：\r\n- Slice：size 参数为 slice 的容量；可以再传一个整形参数定义容量；例如 make([]int, 0, 10) 分配了一个长度为0， 容量为10的切片。\r\ncapacity 10\r\n- Map: 可以省略size参数，因为会自动分配小的一个初始化大小。\r\n- Channel: channel 中定义的容量既是定义 channel 的 buffer 缓冲容量。如果设置为 0 或者省略，则通道不缓冲数据。\r\n\r\n## func new\r\n分配内存。\r\n```\r\nfunc new(Type) *Type\r\n```\r\n第一个参数是一个类型，而不是一个值。返回一个指针。\r\n\r\n## func panic\r\n在当前的goroutine中停止正常的执行。\r\n```\r\nfunc panic(v interface{})\r\n```\r\n例如当一个函数 F 调用 panic，正常的程序执行会立即终止，除了 defer 的内容会正常执行，然后返回给调用者。如果是 G 调用了 F，G 的正常执行也会被终止然后执行 defer 程序。以此类推，直到当前执行的 gorouting 停止。这时，程序终止并报告错误情况，包括恐慌的参数值。\r\n\r\n这个终止序列叫恐慌，可以通过内置函数 recover 来控制恐慌。\r\n\r\n## func recover\r\n在程序中用来控制恐慌的goroutine。\r\n```\r\nfunc recover() interface{}\r\n```\r\n在 defer 函数中调用recover可以停止恐慌序列从而重启正常的程序执行，并检索调用panic的错误值。\r\n\r\n如果在 deferr 函数外调用 recover，不会停止恐慌序列。在这种情况下，要么当goroutine没有恐慌时，要么如果提供给恐慌的参数为零，recover返回nil。 因此，recover的返回值提示该goroutine是否恐慌。\r\n\r\n## func print\r\n格式化特定的实现方式并将结果写入标准错误。\r\n```\r\nfunc print(args ...Type)\r\n```\r\n对于引导和调试有用，不应该保留在程序中。\r\n\r\n## func println\r\n类似于 print，但是 println 会在参数中加空格和添加换行符。\r\n```\r\nfunc println(args ...Type)\r\n```\r\n关于print，println 和 fmt.Println的关系参考：\r\n[what\'s the difference between fmt.Println() and println() in go](https://stackoverflow.com/questions/14680255/whats-the-difference-between-fmt-println-and-println-in-go \"what\'s the difference between fmt.Println() and println() in go\")\r\n\r\n\r\n', '<p>Go语言中，有一些内置的类型和函数，不需要导入任何东西就可以使用，包括一些内置函数，初学Go，这些函数花几分钟记一记。<br>官方参考资料：<a href=\"https://golang.org/pkg/builtin/#error\" title=\"Package builtin\">Package builtin</a></p>\r\n<h1 id=\"h1-1-\"><a name=\"1. 内置类型\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1. 内置类型</h1><ul>\r\n<li>Constants</li><li>Variables</li><li>type ComplexType</li><li>type FloatType</li><li>type IntegerType</li><li>type Type</li><li>type Type1</li><li>type bool</li><li>type byte</li><li>type complex128</li><li>type complex64</li><li>type error</li><li>type float32</li><li>type float64</li><li>type int</li><li>type int16</li><li>type int32</li><li>type int64</li><li>type int8</li><li>type rune</li><li>type string</li><li>type uint</li><li>type uint16</li><li>type uint32</li><li>type uint64</li><li>type uint8</li><li>type uintptr</li></ul>\r\n<p>byte 类型等价于 uint8 类型。</p>\r\n<p>rune 类型等价于 int32 类型。</p>\r\n<p>其中error类型是一个接口：</p>\r\n<pre><code class=\"lang-go\">type error interface {\r\n    Error() string\r\n}\r\n</code></pre>\r\n<h1 id=\"h1-2-\"><a name=\"2. 内置函数\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2. 内置函数</h1><h2 id=\"h2-func-append\"><a name=\"func append\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>func append</h2><p>往slice切片中追加元素，返回更新后的slice。</p>\r\n<pre><code>func append(slice []Type, elems ...Type) []Type\r\n</code></pre><p>示例：</p>\r\n<pre><code>slice = append(slice, elem1, elem2) // 追加slice\r\nslice = append(slice, anotherSlice...) // 合并slice\r\n</code></pre><p>特殊例子：</p>\r\n<pre><code>// 往byte类型的slice中添加string类型\r\nslice = append([]byte(&quot;hello &quot;), &quot;world&quot;...)\r\n</code></pre><h2 id=\"h2-func-cap\"><a name=\"func cap\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>func cap</h2><p>根据类型返回容量</p>\r\n<pre><code>func cap(v Type) int\r\n</code></pre><p>v的类型为以类型下时：</p>\r\n<ul>\r\n<li>数组：返回 v 元素的数量（相当于len(v)）</li><li>数组指针：返回 *v 元素的数量（相当于len(v)）</li><li>切片：可以达到的最大长度；如果 v 是 nil，cap(v) 返回 0</li><li>Channel通道：channel 的 buffer 容量；如果 v 是 nil，cap(v) 返回 0</li></ul>\r\n<h2 id=\"h2-func-close\"><a name=\"func close\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>func close</h2><p>关闭channel通道。应该在发送端关闭，而不是在接收端，防止阻塞。</p>\r\n<pre><code>func close(c chan&lt;- Type)\r\n</code></pre><p>以下操作对于关闭的channel会将ok设为false：</p>\r\n<pre><code>x, ok := &lt;-c\r\n</code></pre><h2 id=\"h2-func-complex\"><a name=\"func complex\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>func complex</h2><p>通过两个浮点数创建一个复数。</p>\r\n<pre><code>func complex(r, i FloatType) ComplexType\r\n</code></pre><p>实部和虚部要大小相同， 比如 float32 或者 float64。返回相对的合成类型；比如对于float32返回complex64, 对于float64返回complex128。</p>\r\n<h2 id=\"h2-func-copy\"><a name=\"func copy\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>func copy</h2><p>复制一个切片。返回复制的元素数量。</p>\r\n<pre><code>func copy(dst, src []Type) int\r\n</code></pre><h2 id=\"h2-func-delete\"><a name=\"func delete\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>func delete</h2><p>删除map中指定key的元素。</p>\r\n<pre><code>func delete(m map[Type]Type1, key Type)\r\n</code></pre><p>如果m是空的或者不存在key对于的元素，delete为空操作。</p>\r\n<h2 id=\"h2-func-real\"><a name=\"func real\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>func real</h2><p>返回复数的实数部分。</p>\r\n<pre><code>func real(c ComplexType) FloatType\r\n</code></pre><p>返回值的类型根据原始 c 的数据类型来返回。</p>\r\n<h2 id=\"h2-func-imag\"><a name=\"func imag\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>func imag</h2><p>返回复数的虚数部分。</p>\r\n<pre><code>func imag(c ComplexType) FloatType\r\n</code></pre><p>返回值的类型根据原始 c 的数据类型来返回。</p>\r\n<h2 id=\"h2-func-len\"><a name=\"func len\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>func len</h2><p>根据类型返回 v 的长度。</p>\r\n<pre><code>func len(v Type) int\r\n</code></pre><p>v为以下类型时：</p>\r\n<ul>\r\n<li>数组：v 中元素的数量</li><li>数组指针：*v 中元素的数量（即使 v 是 nil）</li><li>切片slice 或者 字典map：v 中元素的数量；如果 v 是 nil, len(v) 返回0.</li><li>字符串：v 中 bytes 的数目</li><li>通道Channel：channel buffer 队列中的元素数量；如果 v 是 nil, len(v) 返回0.</li></ul>\r\n<h2 id=\"h2-func-make\"><a name=\"func make\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>func make</h2><p>分配和申明 slice，map，或者 channel 对象。</p>\r\n<pre><code>func make(t Type, size ...IntegerType) Type\r\n</code></pre><p>类似于 new ，第一个参数是一个类型，而不是一个值。<br>与 new 不同的是 make 返回的类型与参数相同，而不是一个指针。</p>\r\n<p>具体的取决于要make的对象有所不同：</p>\r\n<ul>\r\n<li>Slice：size 参数为 slice 的容量；可以再传一个整形参数定义容量；例如 make([]int, 0, 10) 分配了一个长度为0， 容量为10的切片。<br>capacity 10</li><li>Map: 可以省略size参数，因为会自动分配小的一个初始化大小。</li><li>Channel: channel 中定义的容量既是定义 channel 的 buffer 缓冲容量。如果设置为 0 或者省略，则通道不缓冲数据。</li></ul>\r\n<h2 id=\"h2-func-new\"><a name=\"func new\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>func new</h2><p>分配内存。</p>\r\n<pre><code>func new(Type) *Type\r\n</code></pre><p>第一个参数是一个类型，而不是一个值。返回一个指针。</p>\r\n<h2 id=\"h2-func-panic\"><a name=\"func panic\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>func panic</h2><p>在当前的goroutine中停止正常的执行。</p>\r\n<pre><code>func panic(v interface{})\r\n</code></pre><p>例如当一个函数 F 调用 panic，正常的程序执行会立即终止，除了 defer 的内容会正常执行，然后返回给调用者。如果是 G 调用了 F，G 的正常执行也会被终止然后执行 defer 程序。以此类推，直到当前执行的 gorouting 停止。这时，程序终止并报告错误情况，包括恐慌的参数值。</p>\r\n<p>这个终止序列叫恐慌，可以通过内置函数 recover 来控制恐慌。</p>\r\n<h2 id=\"h2-func-recover\"><a name=\"func recover\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>func recover</h2><p>在程序中用来控制恐慌的goroutine。</p>\r\n<pre><code>func recover() interface{}\r\n</code></pre><p>在 defer 函数中调用recover可以停止恐慌序列从而重启正常的程序执行，并检索调用panic的错误值。</p>\r\n<p>如果在 deferr 函数外调用 recover，不会停止恐慌序列。在这种情况下，要么当goroutine没有恐慌时，要么如果提供给恐慌的参数为零，recover返回nil。 因此，recover的返回值提示该goroutine是否恐慌。</p>\r\n<h2 id=\"h2-func-print\"><a name=\"func print\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>func print</h2><p>格式化特定的实现方式并将结果写入标准错误。</p>\r\n<pre><code>func print(args ...Type)\r\n</code></pre><p>对于引导和调试有用，不应该保留在程序中。</p>\r\n<h2 id=\"h2-func-println\"><a name=\"func println\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>func println</h2><p>类似于 print，但是 println 会在参数中加空格和添加换行符。</p>\r\n<pre><code>func println(args ...Type)\r\n</code></pre><p>关于print，println 和 fmt.Println的关系参考：<br><a href=\"https://stackoverflow.com/questions/14680255/whats-the-difference-between-fmt-println-and-println-in-go\" title=\"what&#39;s the difference between fmt.Println() and println() in go\">what’s the difference between fmt.Println() and println() in go</a></p>\r\n', '', 0, 'publish', 1, 0, '/article/67.html', '', 0, 131, '2018-01-24 09:34:58', '2018-01-24 09:34:58', '2018-01-24 09:41:37', NULL);
INSERT INTO `pt_post` VALUES (68, 10, 'article', 'LeetCode刷题之2：Reverse Integer（7）', '# 1. 题目\r\nGiven a 32-bit signed integer, reverse digits of an integer.\r\n\r\n**Example 1:**\r\nInput: 123\r\nOutput:  321\r\n\r\n**Example 2:**\r\nInput: -123\r\nOutput: -321\r\n\r\n**Example 3:**\r\nInput: 120\r\nOutput: 21\r\n\r\n**Note:**\r\nAssume we are dealing with an environment which could only hold integers within the 32-bit signed integer range. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.\r\n\r\n# 2.分析\r\n## 2.1 中文分析\r\n反转Int，假设大小为32位，超过直接返回0。\r\n\r\n## 2.2 解题思路\r\n对int进行除10求余，进行循环，就可以逐个取出个、十、百、千......位上的数字。同时初始化一个结果值，不断将原数乘10并将取到的数字扔进来相加，最后可以获得反转后的数字。\r\n\r\n# 3. 解答\r\n一开始的解答：\r\n```\r\nfunc reverse(x int) int {\r\n    var n int\r\n    res := 0\r\n\r\n    for x != 0 {\r\n        n = x % 10\r\n        x = x / 10\r\n        res = res * 10 + n\r\n    }\r\n\r\n    // 超过32位存储范围直接返回0\r\n    if res > 2147483647 || res < -2147483647 {\r\n        return 0\r\n    }\r\n\r\n    return res\r\n}\r\n```\r\nRuntime: 13 ms\r\n\r\n上面的解法是正负不管直接处理，后来发现效率不加，于是进行优化，正负统一用正来处理最后再转化回来，最后的代码：\r\n```\r\nimport \"math\"\r\n\r\nfunc reverse(x int) int {\r\n    var res int\r\n\r\n    zf := true\r\n    if x < 0 {\r\n        zf = false\r\n        x = x * -1\r\n    }\r\n\r\n    for x != 0 {\r\n        res = res * 10 + x % 10\r\n        x = x / 10\r\n    }\r\n\r\n    // 超过32位存储范围直接返回0\r\n    if res > math.MaxInt32 || res < math.MinInt32 {\r\n        return 0\r\n    }\r\n\r\n    if !zf {\r\n        res = res * -1\r\n    }\r\n\r\n    return res\r\n}\r\n```\r\n这个解的Runtime是 8 ms。', '<h1 id=\"h1-1-\"><a name=\"1. 题目\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1. 题目</h1><p>Given a 32-bit signed integer, reverse digits of an integer.</p>\r\n<p><strong>Example 1:</strong><br>Input: 123<br>Output:  321</p>\r\n<p><strong>Example 2:</strong><br>Input: -123<br>Output: -321</p>\r\n<p><strong>Example 3:</strong><br>Input: 120<br>Output: 21</p>\r\n<p><strong>Note:</strong><br>Assume we are dealing with an environment which could only hold integers within the 32-bit signed integer range. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.</p>\r\n<h1 id=\"h1-2-\"><a name=\"2.分析\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.分析</h1><h2 id=\"h2-2-1-\"><a name=\"2.1 中文分析\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.1 中文分析</h2><p>反转Int，假设大小为32位，超过直接返回0。</p>\r\n<h2 id=\"h2-2-2-\"><a name=\"2.2 解题思路\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.2 解题思路</h2><p>对int进行除10求余，进行循环，就可以逐个取出个、十、百、千……位上的数字。同时初始化一个结果值，不断将原数乘10并将取到的数字扔进来相加，最后可以获得反转后的数字。</p>\r\n<h1 id=\"h1-3-\"><a name=\"3. 解答\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3. 解答</h1><p>一开始的解答：</p>\r\n<pre><code>func reverse(x int) int {\r\n    var n int\r\n    res := 0\r\n\r\n    for x != 0 {\r\n        n = x % 10\r\n        x = x / 10\r\n        res = res * 10 + n\r\n    }\r\n\r\n    // 超过32位存储范围直接返回0\r\n    if res &gt; 2147483647 || res &lt; -2147483647 {\r\n        return 0\r\n    }\r\n\r\n    return res\r\n}\r\n</code></pre><p>Runtime: 13 ms</p>\r\n<p>上面的解法是正负不管直接处理，后来发现效率不加，于是进行优化，正负统一用正来处理最后再转化回来，最后的代码：</p>\r\n<pre><code>import &quot;math&quot;\r\n\r\nfunc reverse(x int) int {\r\n    var res int\r\n\r\n    zf := true\r\n    if x &lt; 0 {\r\n        zf = false\r\n        x = x * -1\r\n    }\r\n\r\n    for x != 0 {\r\n        res = res * 10 + x % 10\r\n        x = x / 10\r\n    }\r\n\r\n    // 超过32位存储范围直接返回0\r\n    if res &gt; math.MaxInt32 || res &lt; math.MinInt32 {\r\n        return 0\r\n    }\r\n\r\n    if !zf {\r\n        res = res * -1\r\n    }\r\n\r\n    return res\r\n}\r\n</code></pre><p>这个解的Runtime是 8 ms。</p>\r\n', '', 0, 'publish', 1, 0, '/article/68.html', '', 0, 116, '2018-01-25 07:41:53', '2018-01-25 07:41:53', '2018-01-25 07:41:53', NULL);
INSERT INTO `pt_post` VALUES (69, 10, 'article', 'Nginx代理ssl转发https和wss请求', '# 1. 介绍\r\n本文主要介绍一下用Nginx代理来转发https和wss请求。\r\n\r\n# 2.使用场景\r\n什么情况下需要这种操作？\r\n比如，后台多台服务器做反向代理；\r\n比如，微信小程序，建立微信小程序的websocket连接，必须要使用wss，但是目前不支持自定义端口，在调用的时候会使用默认端口，这个时候就需要做个代理。\r\n\r\n# 3. 实现\r\nNginx配置如下：\r\n```\r\nserver {\r\n    listen 443; #https和wss协议默认端口\r\n\r\n	# ssl的相关配置\r\n    ssl on;\r\n    ssl_certificate /usr/local/nginx/conf/ssl/***.pem; // ssl pem文件\r\n	ssl_certificate_key /usr/local/nginx/conf/ssl/***.key; // ssl key文件\r\n    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;\r\n	ssl_ciphers EECDH+CHACHA20:EECDH+AES128:RSA+AES128:EECDH+AES256:RSA+AES256:EECDH+3DES:RSA+3DES:!MD5;\r\n	ssl_prefer_server_ciphers on;\r\n	ssl_buffer_size 1400;\r\n	add_header Strict-Transport-Security max-age=15768000;\r\n	add_header Cache-Control no-store;\r\n	ssl_stapling on;\r\n	ssl_stapling_verify on;\r\n\r\n	server_name www.goozp.com;\r\n\r\n    # 转发wss协议\r\n    location /wss {\r\n        proxy_pass http://127.0.0.1:2346;\r\n        proxy_http_version 1.1;\r\n        proxy_set_header Upgrade $http_upgrade;\r\n        proxy_set_header Connection \"Upgrade\";\r\n        proxy_set_header X-Real-IP $remote_addr;\r\n    }\r\n\r\n    # 转发https协议\r\n    location /{\r\n	    proxy_pass http://127.0.0.1:2345;\r\n	    proxy_set_header   X-Real-IP        $remote_addr;\r\n	    proxy_set_header   X-Forwarded-For  $proxy_add_x_forwarded_for;\r\n	    # add_header Access-Control-Allow-Origin *;\r\n    }\r\n}\r\n```\r\n这样，当我们访问 https://www.goozp.com 的时候实际上就转发到了内部的2345端口的http服务，而不需要 https://www.goozp.com:2345 。建立websocket连接时直接与 wss://www.goozp.com/wss 建立连接，会转发到内部2346端口的服务。\r\n\r\n# 4. 通讯原理\r\n假设服务端我们用workerman实现，因为最近我用workerman用得比较多。\r\n\r\n通讯原理及流程是：\r\n1. 客户端发起 wss/https 连接到 Nginx。\r\n2. Nginx 将 wss/https 协议的数据转换成 ws/http 协议并转发到 Workerman 的 websocket 协议端口。\r\n3. Workerman 收到数据后做业务逻辑处理。\r\n4. Workerman 给客户端发送消息时，则是反过来，数据经 Nginx 转换成 wss/https 协议然后发给客户端。\r\n\r\n这样就实现了 Nginx 代理 ssl 请求。', '<h1 id=\"h1-1-\"><a name=\"1. 介绍\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1. 介绍</h1><p>本文主要介绍一下用Nginx代理来转发https和wss请求。</p>\r\n<h1 id=\"h1-2-\"><a name=\"2.使用场景\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.使用场景</h1><p>什么情况下需要这种操作？<br>比如，后台多台服务器做反向代理；<br>比如，微信小程序，建立微信小程序的websocket连接，必须要使用wss，但是目前不支持自定义端口，在调用的时候会使用默认端口，这个时候就需要做个代理。</p>\r\n<h1 id=\"h1-3-\"><a name=\"3. 实现\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3. 实现</h1><p>Nginx配置如下：</p>\r\n<pre><code>server {\r\n    listen 443; #https和wss协议默认端口\r\n\r\n    # ssl的相关配置\r\n    ssl on;\r\n    ssl_certificate /usr/local/nginx/conf/ssl/***.pem; // ssl pem文件\r\n    ssl_certificate_key /usr/local/nginx/conf/ssl/***.key; // ssl key文件\r\n    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;\r\n    ssl_ciphers EECDH+CHACHA20:EECDH+AES128:RSA+AES128:EECDH+AES256:RSA+AES256:EECDH+3DES:RSA+3DES:!MD5;\r\n    ssl_prefer_server_ciphers on;\r\n    ssl_buffer_size 1400;\r\n    add_header Strict-Transport-Security max-age=15768000;\r\n    add_header Cache-Control no-store;\r\n    ssl_stapling on;\r\n    ssl_stapling_verify on;\r\n\r\n    server_name www.goozp.com;\r\n\r\n    # 转发wss协议\r\n    location /wss {\r\n        proxy_pass http://127.0.0.1:2346;\r\n        proxy_http_version 1.1;\r\n        proxy_set_header Upgrade $http_upgrade;\r\n        proxy_set_header Connection &quot;Upgrade&quot;;\r\n        proxy_set_header X-Real-IP $remote_addr;\r\n    }\r\n\r\n    # 转发https协议\r\n    location /{\r\n        proxy_pass http://127.0.0.1:2345;\r\n        proxy_set_header   X-Real-IP        $remote_addr;\r\n        proxy_set_header   X-Forwarded-For  $proxy_add_x_forwarded_for;\r\n        # add_header Access-Control-Allow-Origin *;\r\n    }\r\n}\r\n</code></pre><p>这样，当我们访问 <a href=\"https://www.goozp.com\">https://www.goozp.com</a> 的时候实际上就转发到了内部的2345端口的http服务，而不需要 <a href=\"https://www.goozp.com:2345\">https://www.goozp.com:2345</a> 。建立websocket连接时直接与 wss://www.goozp.com/wss 建立连接，会转发到内部2346端口的服务。</p>\r\n<h1 id=\"h1-4-\"><a name=\"4. 通讯原理\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4. 通讯原理</h1><p>假设服务端我们用workerman实现，因为最近我用workerman用得比较多。</p>\r\n<p>通讯原理及流程是：</p>\r\n<ol>\r\n<li>客户端发起 wss/https 连接到 Nginx。</li><li>Nginx 将 wss/https 协议的数据转换成 ws/http 协议并转发到 Workerman 的 websocket 协议端口。</li><li>Workerman 收到数据后做业务逻辑处理。</li><li>Workerman 给客户端发送消息时，则是反过来，数据经 Nginx 转换成 wss/https 协议然后发给客户端。</li></ol>\r\n<p>这样就实现了 Nginx 代理 ssl 请求。</p>\r\n', '', 0, 'publish', 1, 0, '/article/69.html', '', 0, 303, '2018-01-28 03:18:29', '2018-01-28 03:18:29', '2018-01-28 03:18:29', NULL);
INSERT INTO `pt_post` VALUES (70, 10, 'article', '分类整理Go语言常用的标准库', '# 1.字符串\r\n## 1. strings\r\n', '<h1 id=\"h1-1-\"><a name=\"1.字符串\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.字符串</h1><h2 id=\"h2-1-strings\"><a name=\"1. strings\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1. strings</h2>', '', 0, 'draft', 1, 0, '/article/70.html', '', 0, 0, NULL, '2018-01-31 12:59:00', '2018-01-31 12:59:00', NULL);
INSERT INTO `pt_post` VALUES (71, 10, 'article', 'LeetCode刷题之3：Palindrome Number（9）', '# 1. 题目\r\n## 1.1 英文\r\nDetermine whether an integer is a palindrome. Do this without extra space.\r\n\r\n**Some hints**:\r\n- Could negative integers be palindromes? (ie, -1)\r\n- If you are thinking of converting the integer to string, note the restriction of using extra space.\r\n- You could also try reversing an integer. However, if you have solved the problem \"Reverse Integer\", you know that the reversed integer might overflow. How would you handle such case?\r\n- There is a more generic way of solving this problem.\r\n\r\n## 1.2 中文\r\n检测一个整形是否是一个回文（从左往右看和从右往左看都相等的数），不要使用额外空间。\r\n\r\n**提示**：\r\n- 负数是否是回文？\r\n- 如果你想将整形转化成字符串，注意不要使用额外空间的限制。\r\n- 你可以尝试反转整形。然而，如果你解决了“反转整形”的问题，那你可能知道反转整形可能会导致溢出，你该如何控制这个情况。\r\n- 解决这个问题有一个更通用的方法。\r\n\r\n# 2. 解答\r\n接下来我们就来用这个更通用的方法来解决，Go语言实现。\r\n\r\n```go\r\nfunc isPalindrome(x int) bool {\r\n    // 小于0 或者 末尾是0而本身不是0 时，不符合情况\r\n    if x < 0 || ( x % 10 == 0 && x != 0 ){\r\n        return false\r\n    }\r\n\r\n    revertedNum := 0\r\n	// x大于revertedNum时说明还未过一半，继续循环\r\n    for x > revertedNum {\r\n        revertedNum = revertedNum * 10 + x % 10\r\n        x = x / 10\r\n    }\r\n\r\n	// 判断 x==revertedNum/10 的情况用在当长度为奇数时；比如1234321，最后得到的是123和1234\r\n    return x == revertedNum || x == revertedNum / 10\r\n}\r\n```\r\n时间复杂度：$$O(log_{10}n)$$\r\n空间复杂度：$$O(1)$$', '<h1 id=\"h1-1-\"><a name=\"1. 题目\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1. 题目</h1><h2 id=\"h2-1-1-\"><a name=\"1.1 英文\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.1 英文</h2><p>Determine whether an integer is a palindrome. Do this without extra space.</p>\r\n<p><strong>Some hints</strong>:</p>\r\n<ul>\r\n<li>Could negative integers be palindromes? (ie, -1)</li><li>If you are thinking of converting the integer to string, note the restriction of using extra space.</li><li>You could also try reversing an integer. However, if you have solved the problem “Reverse Integer”, you know that the reversed integer might overflow. How would you handle such case?</li><li>There is a more generic way of solving this problem.</li></ul>\r\n<h2 id=\"h2-1-2-\"><a name=\"1.2 中文\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.2 中文</h2><p>检测一个整形是否是一个回文（从左往右看和从右往左看都相等的数），不要使用额外空间。</p>\r\n<p><strong>提示</strong>：</p>\r\n<ul>\r\n<li>负数是否是回文？</li><li>如果你想将整形转化成字符串，注意不要使用额外空间的限制。</li><li>你可以尝试反转整形。然而，如果你解决了“反转整形”的问题，那你可能知道反转整形可能会导致溢出，你该如何控制这个情况。</li><li>解决这个问题有一个更通用的方法。</li></ul>\r\n<h1 id=\"h1-2-\"><a name=\"2. 解答\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2. 解答</h1><p>接下来我们就来用这个更通用的方法来解决，Go语言实现。</p>\r\n<pre><code class=\"lang-go\">func isPalindrome(x int) bool {\r\n    // 小于0 或者 末尾是0而本身不是0 时，不符合情况\r\n    if x &lt; 0 || ( x % 10 == 0 &amp;&amp; x != 0 ){\r\n        return false\r\n    }\r\n\r\n    revertedNum := 0\r\n    // x大于revertedNum时说明还未过一半，继续循环\r\n    for x &gt; revertedNum {\r\n        revertedNum = revertedNum * 10 + x % 10\r\n        x = x / 10\r\n    }\r\n\r\n    // 判断 x==revertedNum/10 的情况用在当长度为奇数时；比如1234321，最后得到的是123和1234\r\n    return x == revertedNum || x == revertedNum / 10\r\n}\r\n</code></pre>\r\n<p>时间复杂度：<span class=\"editormd-tex\">O(log_{10}n)</span><br>空间复杂度：<span class=\"editormd-tex\">O(1)</span></p>\r\n', '', 0, 'publish', 1, 0, '/article/71.html', '', 0, 141, '2018-02-01 09:01:37', '2018-02-01 09:01:37', '2018-02-05 08:12:42', NULL);
INSERT INTO `pt_post` VALUES (72, 10, 'article', 'Phalcon框架架构初识', '# 1. 认识 Phalcon\r\nPhalcon是一个C拓展方式的PHP框架，安装拓展成功即可使用，性能很高。\r\n\r\nPhalcon是一个高度解耦的框架。就像给了你一堆积木，你是拼成变形金刚呢还是芭比娃娃呢，随意打造。但是也提高了门槛，小白面对空文件夹不知道如何上手，因此官方有了phalcon-devtools工具帮你快速搭建框架；也有了包含了许多注册好的服务默认的工厂类FactoryDefault。\r\n\r\n这是一个提供了 MVC 模式的框架，上手需要了解一下Phalcon中使用模型，使用控制器，和使用视图的一些操作。\r\n\r\nPhalcon算是比较现代化的框架了，所以在使用之前先把命名空间，DI等等了解了。\r\n\r\n全栈框架，该有的都有了；但是不顺手的地方也可以自己打造，非常自由，简直放飞自我。\r\n\r\n**本文的目的就是对Phalcon的不同项目中的项目结构捋一遍，从而对Phalcon框架的框架架构有一个初步的认识；然而在实际开发中，我们的代码架构会更加复杂一些。**\r\n\r\n# 2. 开始入手\r\n## 2.1 安装\r\n- 先安装Phalcon；\r\n- 然后安装phalcon-devtools；我们通过phalcon-devtools构建一些项目demo来了解这个框架。刚上手时，phalcon-devtools这个工具特别有用。\r\n\r\n## 2.2 使用 phalcon-devtools\r\n学会使用phalcon-devtools在一开始学习的时候特别有用。\r\n在自动化创建一个项目时，phalcon-devtools工具提供了 cli, micro, simple, modules 四种模式的项目结构。将这四个看一遍就可以对整体架构有一定的认识。\r\n\r\n## 2.3 关于MVC架构\r\nGithub上有官方提供的MVC架构的例子：https://github.com/phalcon/mvc\r\n\r\n# 3. 微应用（micro类型项目）\r\n## 3.1 工具创建一个微应用\r\n命令行中执行以下语句创建一个micro类型的项目：\r\nphalcon create-project Phalcon-micro micro\r\n可以看到大概是这么个目录：\r\n```\r\nPhalcon-micro/\r\n    .phalcon/\r\n    app/\r\n        config/\r\n        migrations/\r\n        models/\r\n        views/\r\n        app.php\r\n    public/\r\n        css/\r\n        files/\r\n        img/\r\n        js/\r\n        temp/\r\n        .htaccess\r\n        index.php\r\n    .htaccess\r\n    index.html\r\n```\r\n微框架应用只需要书写极少的代码即可创建一个PHP应用，适用于书写小的应用， API或原型等。\r\n\r\n## 3.2 入口文件index.php\r\npublic/index.php文件内容解析：\r\n```php\r\n<?php\r\n\r\nuse Phalcon\\Di\\FactoryDefault; // 工厂默认DI\r\nuse Phalcon\\Mvc\\Micro; // 引入微应用\r\n\r\nerror_reporting(E_ALL); // 设置报错级别\r\n\r\ndefine(\'BASE_PATH\', dirname(__DIR__)); // 定义根目录\r\ndefine(\'APP_PATH\', BASE_PATH . \'/app\'); // 定义app目录\r\n\r\ntry {\r\n\r\n    /**\r\n     * FactoryDefault已经自动注册了提供全栈框架功能的服务。这些默认服务可以根据自己的习惯重写。\r\n     */\r\n    $di = new FactoryDefault(); // 实例化FactoryDefault\r\n\r\n    /**\r\n     * 包含service文件，即是用来注册服务的文件\r\n     */\r\n    include APP_PATH . \'/config/services.php\'; // 引入app/config/service.php\r\n\r\n    /**\r\n     * 容器中获取配置服务\r\n     */\r\n    $config = $di->getConfig();\r\n\r\n    /**\r\n     * 包含自动加载文件\r\n     */\r\n    include APP_PATH . \'/config/loader.php\'; // 引入app/config/loader.php\r\n\r\n    /**\r\n     * 实例化微应用，并传入容器示例\r\n     */\r\n    $app = new Micro($di);\r\n\r\n    /**\r\n     * 包含应用引导文件\r\n     */\r\n    include APP_PATH . \'/app.php\'; // 引入app/app.php\r\n\r\n    /**\r\n     * 执行控制请求\r\n     */\r\n    $app->handle();\r\n\r\n} catch (\\Exception $e) {\r\n      echo $e->getMessage() . \'<br>\';\r\n      echo \'<pre>\' . $e->getTraceAsString() . \'</pre>\';\r\n}\r\n\r\n```\r\n接下来根据入口文件的流程，来走一遍，config.php文件就不说了\r\n\r\n## 3.3 服务注册文件service.php\r\n```php\r\n<?php\r\n\r\nuse Phalcon\\Mvc\\View\\Simple as View;\r\nuse Phalcon\\Mvc\\Url as UrlResolver;\r\n\r\n/**\r\n * 单例模式(共享)的配置服务\r\n */\r\n$di->setShared(\'config\', function () {\r\n    return include APP_PATH . \"/config/config.php\";\r\n});\r\n\r\n/**\r\n * 设置视图组件(全局共享)\r\n */\r\n$di->setShared(\'view\', function () {\r\n    $config = $this->getConfig(); // 获取配置\r\n\r\n    $view = new View(); // 实例化视图\r\n    $view->setViewsDir($config->application->viewsDir); // 设置视图路径(从配置文件config.php中获取)\r\n    return $view; // 返回实例\r\n});\r\n\r\n/**\r\n * URL组件，用来生成应用所有类型的url\r\n */\r\n$di->setShared(\'url\', function () {\r\n    $config = $this->getConfig(); // 获取配置\r\n\r\n    $url = new UrlResolver(); // 实例化url类\r\n    $url->setBaseUri($config->application->baseUri); // 设置基URI(从配置文件config.php中获取)\r\n    return $url; // 返回url类示例\r\n});\r\n\r\n/**\r\n * 数据库连接，根据配置文件中的设置\r\n */\r\n$di->setShared(\'db\', function () {\r\n    $config = $this->getConfig(); // 获取配置\r\n\r\n    $class = \'Phalcon\\Db\\Adapter\\Pdo\\\\\' . $config->database->adapter; // 数据库类型(Mysql),根据类型定位到对应的数据库操作PDO类\r\n    $params = [\r\n        \'host\'     => $config->database->host,\r\n        \'username\' => $config->database->username,\r\n        \'password\' => $config->database->password,\r\n        \'dbname\'   => $config->database->dbname,\r\n        \'charset\'  => $config->database->charset\r\n    ]; // 读取其它配置\r\n\r\n    /* 如果数据库是Postgresql，注销掉charset参数 */\r\n    if ($config->database->adapter == \'Postgresql\') {\r\n        unset($params[\'charset\']);\r\n    }\r\n\r\n    $connection = new $class($params); // 实例化数据库实例\r\n\r\n    return $connection; // 返回数据库实例\r\n});\r\n```\r\n\r\n## 3.4 自动加载配置文件loader.php\r\n```php\r\n<?php\r\n\r\n/**\r\n * 注册自动加载\r\n */\r\n$loader = new \\Phalcon\\Loader();\r\n\r\n/* 这里自动加载了modelsDir路径(配置) */\r\n$loader->registerDirs(\r\n    [\r\n        $config->application->modelsDir\r\n    ]\r\n)->register();\r\n```\r\n\r\n## 3.5 应用引导文件app.php\r\n```php\r\n<?php\r\n/**\r\n * Local variables 本地变量\r\n * @var \\Phalcon\\Mvc\\Micro $app 微应用实例\r\n */\r\n\r\n/**\r\n * 在这里添加路由\r\n * 根目录默认index\r\n */\r\n$app->get(\'/\', function () {\r\n    echo $this[\'view\']->render(\'index\');\r\n});\r\n\r\n/**\r\n * 找不到时的操作(返回404)\r\n */\r\n$app->notFound(function () use($app) {\r\n    $app->response->setStatusCode(404, \"Not Found\")->sendHeaders(); // 设置状态码404\r\n    echo $app[\'view\']->render(\'404\'); // 转到404页面\r\n});\r\n```\r\n\r\n这样基本上这个微应用，Phalcon最简单的一种实现就跑起来了。\r\n\r\n## 3.6 小结\r\n一个内置的微应用，可以快速构建简单的应用。\r\n\r\n# 4. 简单的单模块应用（simple类型项目）\r\n## 4.1 大概的项目目录\r\n```\r\nPhalcon-simple/\r\n    app/\r\n        config/\r\n            config.php\r\n            loader.php\r\n            router.php\r\n            services.php\r\n        controllers/\r\n            ControllerBase.php\r\n            IndexController.php\r\n        library/\r\n        migrations/\r\n        models/\r\n        views/\r\n            index/\r\n                idnex.volt\r\n            index.volt\r\n    cache/\r\n    public/\r\n        css/\r\n        files/\r\n        img/\r\n        js/\r\n        temp/\r\n        .htaccess\r\n        index.php\r\n    .htaccess\r\n    .htrouter.php\r\n    index.html\r\n```\r\n\r\n## 4.2 index.php\r\n同样从index.php入口文件入手：\r\n```php\r\n<?php\r\nuse Phalcon\\Di\\FactoryDefault; // 工厂默认DI\r\n\r\nerror_reporting(E_ALL);\r\n\r\ndefine(\'BASE_PATH\', dirname(__DIR__)); // 定义入口根目录路径\r\ndefine(\'APP_PATH\', BASE_PATH . \'/app\'); // 定义app目录路径\r\n\r\ntry {\r\n\r\n    /**\r\n     * 实例化默认工厂DI，已经自动注册了很多提供全栈框架的服务\r\n     */\r\n    $di = new FactoryDefault();\r\n\r\n    /**\r\n     * 引入router路由文件\r\n     */\r\n    include APP_PATH . \'/config/router.php\';\r\n\r\n    /**\r\n     * 引入services服务注册文件\r\n     */\r\n    include APP_PATH . \'/config/services.php\';\r\n\r\n    /**\r\n     * 为下面的内置设置，获取配置服务\r\n     */\r\n    $config = $di->getConfig();\r\n\r\n    /**\r\n     * 包含自动加载loader.php文件\r\n     */\r\n    include APP_PATH . \'/config/loader.php\';\r\n\r\n    /**\r\n     * 加载请求控制\r\n     */\r\n    $application = new \\Phalcon\\Mvc\\Application($di);\r\n\r\n    echo str_replace([\"\\n\",\"\\r\",\"\\t\"], \'\', $application->handle()->getContent()); // 移除换行,回车,跳格\r\n\r\n} catch (\\Exception $e) {\r\n    echo $e->getMessage() . \'<br>\';\r\n    echo \'<pre>\' . $e->getTraceAsString() . \'</pre>\';\r\n}\r\n\r\n```\r\n\r\n## 4.3 router.php路由文件\r\n获取路由服务，定义路由，执行。\r\n```php\r\n<?php\r\n\r\n$router = $di->getRouter();\r\n\r\n// Define your routes here\r\n// 在这里定义路由\r\n\r\n$router->handle();\r\n\r\n```\r\n\r\n## 4.4 services.php服务注册文件\r\n```php\r\n<?php\r\n\r\nuse Phalcon\\Mvc\\View; // view层\r\nuse Phalcon\\Mvc\\View\\Engine\\Php as PhpEngine; // view层php引擎\r\nuse Phalcon\\Mvc\\Url as UrlResolver; // url组件\r\nuse Phalcon\\Mvc\\View\\Engine\\Volt as VoltEngine; // volt引擎\r\nuse Phalcon\\Mvc\\Model\\Metadata\\Memory as MetaDataAdapter; // 元数据适配器\r\nuse Phalcon\\Session\\Adapter\\Files as SessionAdapter; // session文件适配器\r\nuse Phalcon\\Flash\\Direct as Flash; // 闪存服务\r\n\r\n/**\r\n * 共享的配置服务\r\n */\r\n$di->setShared(\'config\', function () {\r\n    return include APP_PATH . \"/config/config.php\"; // 配置文件所在路径\r\n});\r\n\r\n/**\r\n * URL组件,用来生成所有类型的应用url\r\n */\r\n$di->setShared(\'url\', function () {\r\n    $config = $this->getConfig(); // 获取配置\r\n\r\n    $url = new UrlResolver(); // 实例化\r\n    $url->setBaseUri($config->application->baseUri); // 传入基URI\r\n\r\n    return $url; // 返回URL实例\r\n});\r\n\r\n/**\r\n * 设置视图组件\r\n */\r\n$di->setShared(\'view\', function () {\r\n    $config = $this->getConfig(); // 获取配置\r\n\r\n    $view = new View(); // 实例化\r\n    $view->setDI($this); // 设置为服务\r\n    $view->setViewsDir($config->application->viewsDir); // 传入views路径\r\n\r\n    // 注册模板引擎; 注册了.volt和.phtml结尾的文件\r\n    $view->registerEngines([\r\n        \'.volt\' => function ($view) {\r\n            $config = $this->getConfig(); // 获取配置\r\n\r\n            $volt = new VoltEngine($view, $this); // 实例化引擎\r\n\r\n            $volt->setOptions([\r\n                \'compiledPath\' => $config->application->cacheDir,\r\n                \'compiledSeparator\' => \'_\'\r\n            ]); // 设置参数;缓存路径和缓存文件连接符\r\n\r\n            return $volt; // 返回实例\r\n        },\r\n        \'.phtml\' => PhpEngine::class\r\n\r\n    ]);\r\n\r\n    return $view; // 返回实例\r\n});\r\n\r\n/**\r\n * 数据库连接\r\n */\r\n$di->setShared(\'db\', function () {\r\n    $config = $this->getConfig(); // 获取配置\r\n\r\n    $class = \'Phalcon\\Db\\Adapter\\Pdo\\\\\' . $config->database->adapter; //数据库类型(mysql)\r\n    $params = [\r\n        \'host\'     => $config->database->host,\r\n        \'username\' => $config->database->username,\r\n        \'password\' => $config->database->password,\r\n        \'dbname\'   => $config->database->dbname,\r\n        \'charset\'  => $config->database->charset\r\n    ];\r\n\r\n    /* 如果是Postgresql数据库,删除charset参数 */\r\n    if ($config->database->adapter == \'Postgresql\') {\r\n        unset($params[\'charset\']);\r\n    }\r\n\r\n    $connection = new $class($params); //实例化\r\n\r\n    return $connection; //返回连接实例\r\n});\r\n\r\n\r\n/**\r\n * 如果配置了元数据适配器就使用原数据适配器否则使用内存\r\n */\r\n$di->setShared(\'modelsMetadata\', function () {\r\n    return new MetaDataAdapter();\r\n});\r\n\r\n/**\r\n * 注册Bootstrap框架类中的会话闪存服务\r\n */\r\n$di->set(\'flash\', function () {\r\n    return new Flash([\r\n        \'error\'   => \'alert alert-danger\',\r\n        \'success\' => \'alert alert-success\',\r\n        \'notice\'  => \'alert alert-info\',\r\n        \'warning\' => \'alert alert-warning\'\r\n    ]);\r\n});\r\n\r\n/**\r\n * 启动session,当有组件请求session服务的时候\r\n */\r\n$di->setShared(\'session\', function () {\r\n    $session = new SessionAdapter(); // session适配器\r\n    $session->start();\r\n\r\n    return $session;\r\n});\r\n\r\n```\r\n可以看到simple项目已经使用了view层，引入了volt引擎，session服务等，甚至还注册前端bootstrap框架的class。\r\n\r\n## 4.5 loader.php自动加载文件\r\n```php\r\n<?php\r\n\r\n$loader = new \\Phalcon\\Loader();\r\n\r\n/**\r\n * 自动加载配置文件中定义好的路径\r\n */\r\n$loader->registerDirs(\r\n    [\r\n        $config->application->controllersDir,\r\n        $config->application->modelsDir\r\n    ]\r\n)->register();\r\n```\r\n\r\n## 4.6 controllers\r\ncontrollers下定义了一个ControllerBase类，和一个IndexController类：\r\nControllerBase.php\r\n```php\r\n<?php\r\n\r\nuse Phalcon\\Mvc\\Controller;\r\n\r\nclass ControllerBase extends Controller\r\n{\r\n\r\n}\r\n```\r\n\r\nIndexController.php\r\n```\r\n<?php\r\n\r\nclass IndexController extends ControllerBase\r\n{\r\n\r\n    public function indexAction()\r\n    {\r\n\r\n    }\r\n\r\n}\r\n```\r\n\r\n基本上simple这个项目就是一个简单的省略了modle的基本单模块项目。\r\n\r\n## 4.7 小结\r\n一个简单的单模块web应用。\r\n\r\n# 5. cli命令行应用（cli类型项目）\r\n## 5.1 大概的项目目录\r\n```\r\nPhalcon-cli/\r\n    app/\r\n        config/\r\n            config.php\r\n            loader.php\r\n            services.php\r\n        models/\r\n        tasks/\r\n            MainTask.php\r\n            VersionTask.php\r\n        bootstrap.php\r\n    public/\r\n        css/\r\n        js/\r\n    run\r\n```\r\ncli项目的架构看上去更加简单明了。\r\n\r\n## 5.2 run文件\r\nrun文件是用来执行项目的入口文件，只需要在命令行执行：\r\n```\r\nphp run\r\n```\r\n输出：\r\n```\r\nCongratulations! You are now flying with Phalcon CLI!\r\n```\r\n这是在MainTask.php中输出的内容。\r\n看一下run文件，就是执行了一段php代码，而这段代码只是引入的bootstrap引导文件：\r\n```\r\n#!/usr/bin/env php\r\n<?php\r\ninclude __DIR__ . \"/app/bootstrap.php\";\r\n```\r\n\r\n## 5.3 bootstrap.php引导程序\r\n```php\r\n<?php\r\n\r\nuse Phalcon\\Di\\FactoryDefault\\Cli as CliDi; //引入默认工厂DI的cli模式\r\nuse Phalcon\\Cli\\Console as ConsoleApp; // 引入用来创建cli应用的Console组件\r\n\r\ndefine(\'BASE_PATH\', dirname(__DIR__));\r\ndefine(\'APP_PATH\', BASE_PATH . \'/app\');\r\n\r\n/**\r\n * 实例化默认工厂DI的cli模式,自动加载提供了全栈框架的服务\r\n */\r\n$di = new CliDi();\r\n\r\n/**\r\n * 包含服务注册文件\r\n */\r\ninclude APP_PATH . \'/config/services.php\';\r\n\r\n/**\r\n * 获取配置服务中的配置\r\n */\r\n$config = $di->getConfig();\r\n\r\n/**\r\n * 包含自动加载\r\n */\r\ninclude APP_PATH . \'/config/loader.php\';\r\n\r\n/**\r\n * 创建一个console应用(cli)\r\n */\r\n$console = new ConsoleApp($di);\r\n\r\n/**\r\n * 处理console参数\r\n */\r\n$arguments = [];\r\n\r\nforeach ($argv as $k => $arg) {\r\n    if ($k == 1) {\r\n        $arguments[\'task\'] = $arg; // 第一个参数task类\r\n    } elseif ($k == 2) {\r\n        $arguments[\'action\'] = $arg; // 第二个参数action方法\r\n    } elseif ($k >= 3) {\r\n        $arguments[\'params\'][] = $arg; // 第三个参数,额外参数(数组)\r\n    }\r\n}\r\n\r\ntry {\r\n\r\n    /**\r\n     * Handle传入处理好的参数\r\n     */\r\n    $console->handle($arguments);\r\n\r\n    /**\r\n     * 如果配置中printNewLine设置了true,将会在末尾另起一行\r\n     *\r\n     * 仅仅只是为了在命令行中更直观的表现\r\n     */\r\n    if (isset($config[\"printNewLine\"]) && $config[\"printNewLine\"]) {\r\n        echo PHP_EOL; // 输出一个换行符\r\n    }\r\n\r\n} catch (Exception $e) {\r\n    echo $e->getMessage() . PHP_EOL;\r\n    echo $e->getTraceAsString() . PHP_EOL;\r\n    exit(255);\r\n}\r\n\r\n```\r\n\r\n## 5.4 service.php服务注册\r\n注册了配置服务和数据库服务：\r\n```php\r\n<?php\r\n\r\n/**\r\n * 注册共享配置服务\r\n */\r\n$di->setShared(\'config\', function () {\r\n    return include APP_PATH . \'/config/config.php\'; // 配置文件路径\r\n});\r\n\r\n/**\r\n * 数据库连接\r\n */\r\n$di->setShared(\'db\', function () {\r\n    $config = $this->getConfig(); // 获取配置\r\n\r\n    $class = \'Phalcon\\Db\\Adapter\\Pdo\\\\\' . $config->database->adapter; // 数据库类型(Mysql)\r\n\r\n    $params = [\r\n        \'host\'     => $config->database->host,\r\n        \'username\' => $config->database->username,\r\n        \'password\' => $config->database->password,\r\n        \'dbname\'   => $config->database->dbname,\r\n        \'charset\'  => $config->database->charset\r\n    ];\r\n\r\n    /* 如果数据库是Postgresql,删除charset变量 */\r\n    if ($config->database->adapter == \'Postgresql\') {\r\n        unset($params[\'charset\']);\r\n    }\r\n\r\n    $connection = new $class($params); // 数据库实例\r\n\r\n    return $connection; // 返回数据库实例\r\n});\r\n```\r\n\r\n## 5.5 loader.php自动加载\r\ncli项目与普通web项目不一样的是，自动加载了tasks目录和models目录，但实际上道理是一样的，task任务就好比是Controller。\r\n```php\r\n<?php\r\n$loader = new \\Phalcon\\Loader();\r\n$loader->registerDirs([\r\n    APP_PATH . \'/tasks\',\r\n    APP_PATH . \'/models\'\r\n]);\r\n$loader->register();\r\n```\r\n\r\n## 5.6 tasks目录\r\n看一下这个demo项目的两个task文件。  \r\nMainTask.php：\r\n```php\r\n<?php\r\n\r\nclass MainTask extends \\Phalcon\\Cli\\Task\r\n{\r\n    public function mainAction()\r\n    {\r\n        echo \"Congratulations! You are now flying with Phalcon CLI!\";\r\n    }\r\n}\r\n```\r\nVersionTask.php：\r\n```\r\n<?php\r\n\r\nclass VersionTask extends \\Phalcon\\Cli\\Task\r\n{\r\n    public function mainAction()\r\n    {\r\n        $config = $this->getDI()->get(\'config\'); //获取配置\r\n\r\n        echo $config[\'version\']; //输出版本\r\n    }\r\n}\r\n```\r\n都继承了 Phalcon\\Cli\\Task 类；MainTask 为系统默认类，类似于默认IndexController那么个意思。\r\n\r\n## 5.7 小结\r\n一个cli模式的demo，可以用来编写简单的cli脚本。\r\n\r\n# 6. 多模块项目（modules类型项目）\r\n## 6.1 项目目录\r\n这个多模块项目就文件稍微多一点了，可以看到这里有两个模块，一个是web项目，一个是cli项目。\r\n```\r\nPhalcon-modules\r\n    app/\r\n        common/\r\n            library/\r\n            models/\r\n        config/\r\n            config.php\r\n            loader.php\r\n            routes.php\r\n            services.php\r\n            services_cli.php\r\n            services_web.php\r\n        modules/\r\n            cli/\r\n                migrations/\r\n                tasks/\r\n                    MainTask.php\r\n                    VersionTask.php\r\n                Module.php\r\n            frontend/\r\n                controllers/\r\n                    ControllerBase.php\r\n                    IndexController.php\r\n                models/\r\n                views/\r\n                    index/\r\n                        index.volt\r\n                    index.volt\r\n                Module.php\r\n        bootstrap_cli.php\r\n        bootstrap_web.php\r\n    cache/\r\n        volt/\r\n    public/\r\n        css/\r\n        files/\r\n        img/\r\n        js/\r\n        temp/\r\n        .htaccess\r\n        index.php\r\n    .htaccess\r\n    .htrouter.php\r\n    index.html\r\n    run\r\n```\r\n大概地看一下文件，可以发现这个模块是simple项目和cli项目合并起来的一个项目，所以之前看过的内容我们就不重复关注了，我们还是重点放在整体架构分析和不同的地方。\r\n\r\n## 6.2 index.php入口文件\r\n依然是入口文件，不过这次这个入口文件变了：\r\n```php\r\n<?php\r\nrequire \'../app/bootstrap_web.php\';\r\n```\r\n只有这么一句，因为public入口下指引的应该是web项目，所以这里直接引入了web项目的指引程序文件bootstrap_web.php。\r\n基本相当于将各个模块的入口文件放到了app目录下，以bootstrap_开头命名：\r\n```\r\ncommon/\r\nconfig/\r\nmodules/\r\n    cli/\r\n        migrations/\r\n        tasks/\r\n        Module.php\r\n    frontend/\r\n        controllers/\r\n        models/\r\n        views/\r\n        Module.php\r\nbootstrap_cli.php\r\nbootstrap_web.php\r\n```\r\ncommon为公共的模块，公共类公共模型什么的放这里；config配置目录，与之前的区别是，services.php放公共服务文件，services_cli.php放cli模块的服务文件，services_web.php放web项模块的服务文件。modules则为两个模块的具体文件，区别是底下多了一个Module.php。\r\n\r\n## 6.3 config.php配置文件\r\n配置文件中的路径配置不再配置到Controller，model层面，只配置到外一层和公共模块下。\r\n```php\r\n\'application\' => [\r\n        \'appDir\'         => APP_PATH . \'/\',\r\n        \'modelsDir\'      => APP_PATH . \'/common/models/\',\r\n        \'migrationsDir\'  => APP_PATH . \'/migrations/\',\r\n        \'cacheDir\'       => BASE_PATH . \'/cache/\',\r\n        \'baseUri\'        => preg_replace(\'/public([\\/\\\\\\\\])index.php$/\', \'\', $_SERVER[\"PHP_SELF\"]),\r\n    ]\r\n```\r\n\r\n## 6.4 routes.php路由文件\r\n配置路由\r\n```php\r\n<?php\r\n\r\n$router = $di->getRouter();\r\n\r\nforeach ($application->getModules() as $key => $module) {\r\n    $namespace = preg_replace(\'/Module$/\', \'Controllers\', $module[\"className\"]);\r\n    $router->add(\'/\'.$key.\'/:params\', [\r\n        \'namespace\' => $namespace,\r\n        \'module\' => $key,\r\n        \'controller\' => \'index\',\r\n        \'action\' => \'index\',\r\n        \'params\' => 1\r\n    ])->setName($key);\r\n    $router->add(\'/\'.$key.\'/:controller/:params\', [\r\n        \'namespace\' => $namespace,\r\n        \'module\' => $key,\r\n        \'controller\' => 1,\r\n        \'action\' => \'index\',\r\n        \'params\' => 2\r\n    ]);\r\n    $router->add(\'/\'.$key.\'/:controller/:action/:params\', [\r\n        \'namespace\' => $namespace,\r\n        \'module\' => $key,\r\n        \'controller\' => 1,\r\n        \'action\' => 2,\r\n        \'params\' => 3\r\n    ]);\r\n}\r\n\r\n```\r\n\r\n## 6.5 loader.php自动加载文件\r\n```php\r\n<?php\r\n\r\nuse Phalcon\\Loader;\r\n\r\n$loader = new Loader();\r\n\r\n/**\r\n * 注册命名空间;common下的公共模型,库等\r\n */\r\n$loader->registerNamespaces([\r\n    \'PhalconModules\\Models\' => APP_PATH . \'/common/models/\',\r\n    \'PhalconModules\'        => APP_PATH . \'/common/library/\',\r\n]);\r\n\r\n/**\r\n * 注册模块下的类\r\n */\r\n$loader->registerClasses([\r\n    \'PhalconModules\\Modules\\Frontend\\Module\' => APP_PATH . \'/modules/frontend/Module.php\', // web模块的Module.php\r\n    \'PhalconModules\\Modules\\Cli\\Module\'      => APP_PATH . \'/modules/cli/Module.php\' // cli模块的Module.php\r\n]);\r\n\r\n$loader->register();\r\n```\r\n\r\n## 6.6 Module.php模块文件\r\n在单模块项目中的路径加载配置，服务加载配置等需要区别开不同模块的，都移到了Module.php文件，以实现 ModuleDefinitionInterface 模块定义接口的形式实现。\r\n比如Web模块的Module.php文件：\r\n```php\r\n<?php\r\nnamespace PhalconModules\\Modules\\Frontend;\r\n\r\nuse Phalcon\\DiInterface;\r\nuse Phalcon\\Loader;\r\nuse Phalcon\\Mvc\\View;\r\nuse Phalcon\\Mvc\\View\\Engine\\Php as PhpEngine;\r\nuse Phalcon\\Mvc\\ModuleDefinitionInterface;\r\n\r\nclass Module implements ModuleDefinitionInterface\r\n{\r\n    /**\r\n     * 注册模块的自动加载\r\n     *\r\n     * @param DiInterface $di\r\n     */\r\n    public function registerAutoloaders(DiInterface $di = null)\r\n    {\r\n        $loader = new Loader();\r\n\r\n        /* 在这里定义当前模块下的Controllers,Models等目录路径 */\r\n        $loader->registerNamespaces([\r\n            \'PhalconModules\\Modules\\Frontend\\Controllers\' => __DIR__ . \'/controllers/\',\r\n            \'PhalconModules\\Modules\\Frontend\\Models\' => __DIR__ . \'/models/\',\r\n        ]);\r\n\r\n        $loader->register();\r\n    }\r\n\r\n    /**\r\n     * 注册模块的服务\r\n     *\r\n     * @param DiInterface $di\r\n     */\r\n    public function registerServices(DiInterface $di)\r\n    {\r\n        /**\r\n         * 设置视图组件\r\n         */\r\n        $di->set(\'view\', function () {\r\n            $view = new View();\r\n            $view->setDI($this);\r\n            $view->setViewsDir(__DIR__ . \'/views/\'); // 视图路径\r\n\r\n            $view->registerEngines([\r\n                \'.volt\'  => \'voltShared\',\r\n                \'.phtml\' => PhpEngine::class\r\n            ]); // 注册视图引擎\r\n\r\n            return $view;\r\n        });\r\n    }\r\n}\r\n```\r\n\r\ncli模块的Module.php：\r\n```php\r\n<?php\r\nnamespace PhalconModules\\Modules\\Cli;\r\n\r\nuse Phalcon\\DiInterface;\r\nuse Phalcon\\Loader;\r\nuse Phalcon\\Mvc\\ModuleDefinitionInterface;\r\n\r\nclass Module implements ModuleDefinitionInterface\r\n{\r\n    /**\r\n     * 注册模块的自动加载\r\n     *\r\n     * @param DiInterface $di\r\n     */\r\n    public function registerAutoloaders(DiInterface $di = null)\r\n    {\r\n        $loader = new Loader();\r\n\r\n        $loader->registerNamespaces([\r\n            \'PhalconModules\\Modules\\Cli\\Tasks\' => __DIR__ . \'/tasks/\',\r\n        ]);\r\n\r\n        $loader->register();\r\n    }\r\n\r\n    /**\r\n     * 注册模块的服务\r\n     *\r\n     * @param DiInterface $di\r\n     */\r\n    public function registerServices(DiInterface $di)\r\n    {\r\n    }\r\n}\r\n\r\n```\r\n\r\n根据这样的一个套路，我们可以引入更多的模块。\r\n\r\n## 6.7 小结\r\n多模块的设计思路，按照这个套路，我们可以自由地搭建起我们的框架并应用到项目中。', '<h1 id=\"h1-1-phalcon\"><a name=\"1. 认识 Phalcon\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1. 认识 Phalcon</h1><p>Phalcon是一个C拓展方式的PHP框架，安装拓展成功即可使用，性能很高。</p>\r\n<p>Phalcon是一个高度解耦的框架。就像给了你一堆积木，你是拼成变形金刚呢还是芭比娃娃呢，随意打造。但是也提高了门槛，小白面对空文件夹不知道如何上手，因此官方有了phalcon-devtools工具帮你快速搭建框架；也有了包含了许多注册好的服务默认的工厂类FactoryDefault。</p>\r\n<p>这是一个提供了 MVC 模式的框架，上手需要了解一下Phalcon中使用模型，使用控制器，和使用视图的一些操作。</p>\r\n<p>Phalcon算是比较现代化的框架了，所以在使用之前先把命名空间，DI等等了解了。</p>\r\n<p>全栈框架，该有的都有了；但是不顺手的地方也可以自己打造，非常自由，简直放飞自我。</p>\r\n<p><strong>本文的目的就是对Phalcon的不同项目中的项目结构捋一遍，从而对Phalcon框架的框架架构有一个初步的认识；然而在实际开发中，我们的代码架构会更加复杂一些。</strong></p>\r\n<h1 id=\"h1-2-\"><a name=\"2. 开始入手\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2. 开始入手</h1><h2 id=\"h2-2-1-\"><a name=\"2.1 安装\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.1 安装</h2><ul>\r\n<li>先安装Phalcon；</li><li>然后安装phalcon-devtools；我们通过phalcon-devtools构建一些项目demo来了解这个框架。刚上手时，phalcon-devtools这个工具特别有用。</li></ul>\r\n<h2 id=\"h2-2-2-phalcon-devtools\"><a name=\"2.2 使用 phalcon-devtools\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.2 使用 phalcon-devtools</h2><p>学会使用phalcon-devtools在一开始学习的时候特别有用。<br>在自动化创建一个项目时，phalcon-devtools工具提供了 cli, micro, simple, modules 四种模式的项目结构。将这四个看一遍就可以对整体架构有一定的认识。</p>\r\n<h2 id=\"h2-2-3-mvc-\"><a name=\"2.3 关于MVC架构\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.3 关于MVC架构</h2><p>Github上有官方提供的MVC架构的例子：<a href=\"https://github.com/phalcon/mvc\">https://github.com/phalcon/mvc</a></p>\r\n<h1 id=\"h1-3-micro-\"><a name=\"3. 微应用（micro类型项目）\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3. 微应用（micro类型项目）</h1><h2 id=\"h2-3-1-\"><a name=\"3.1 工具创建一个微应用\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.1 工具创建一个微应用</h2><p>命令行中执行以下语句创建一个micro类型的项目：<br>phalcon create-project Phalcon-micro micro<br>可以看到大概是这么个目录：</p>\r\n<pre><code>Phalcon-micro/\r\n    .phalcon/\r\n    app/\r\n        config/\r\n        migrations/\r\n        models/\r\n        views/\r\n        app.php\r\n    public/\r\n        css/\r\n        files/\r\n        img/\r\n        js/\r\n        temp/\r\n        .htaccess\r\n        index.php\r\n    .htaccess\r\n    index.html\r\n</code></pre><p>微框架应用只需要书写极少的代码即可创建一个PHP应用，适用于书写小的应用， API或原型等。</p>\r\n<h2 id=\"h2-3-2-index-php\"><a name=\"3.2 入口文件index.php\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.2 入口文件index.php</h2><p>public/index.php文件内容解析：</p>\r\n<pre><code class=\"lang-php\">&lt;?php\r\n\r\nuse Phalcon\\Di\\FactoryDefault; // 工厂默认DI\r\nuse Phalcon\\Mvc\\Micro; // 引入微应用\r\n\r\nerror_reporting(E_ALL); // 设置报错级别\r\n\r\ndefine(&#39;BASE_PATH&#39;, dirname(__DIR__)); // 定义根目录\r\ndefine(&#39;APP_PATH&#39;, BASE_PATH . &#39;/app&#39;); // 定义app目录\r\n\r\ntry {\r\n\r\n    /**\r\n     * FactoryDefault已经自动注册了提供全栈框架功能的服务。这些默认服务可以根据自己的习惯重写。\r\n     */\r\n    $di = new FactoryDefault(); // 实例化FactoryDefault\r\n\r\n    /**\r\n     * 包含service文件，即是用来注册服务的文件\r\n     */\r\n    include APP_PATH . &#39;/config/services.php&#39;; // 引入app/config/service.php\r\n\r\n    /**\r\n     * 容器中获取配置服务\r\n     */\r\n    $config = $di-&gt;getConfig();\r\n\r\n    /**\r\n     * 包含自动加载文件\r\n     */\r\n    include APP_PATH . &#39;/config/loader.php&#39;; // 引入app/config/loader.php\r\n\r\n    /**\r\n     * 实例化微应用，并传入容器示例\r\n     */\r\n    $app = new Micro($di);\r\n\r\n    /**\r\n     * 包含应用引导文件\r\n     */\r\n    include APP_PATH . &#39;/app.php&#39;; // 引入app/app.php\r\n\r\n    /**\r\n     * 执行控制请求\r\n     */\r\n    $app-&gt;handle();\r\n\r\n} catch (\\Exception $e) {\r\n      echo $e-&gt;getMessage() . &#39;&lt;br&gt;&#39;;\r\n      echo &#39;&lt;pre&gt;&#39; . $e-&gt;getTraceAsString() . &#39;&lt;/pre&gt;&#39;;\r\n}\r\n</code></pre>\r\n<p>接下来根据入口文件的流程，来走一遍，config.php文件就不说了</p>\r\n<h2 id=\"h2-3-3-service-php\"><a name=\"3.3 服务注册文件service.php\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.3 服务注册文件service.php</h2><pre><code class=\"lang-php\">&lt;?php\r\n\r\nuse Phalcon\\Mvc\\View\\Simple as View;\r\nuse Phalcon\\Mvc\\Url as UrlResolver;\r\n\r\n/**\r\n * 单例模式(共享)的配置服务\r\n */\r\n$di-&gt;setShared(&#39;config&#39;, function () {\r\n    return include APP_PATH . &quot;/config/config.php&quot;;\r\n});\r\n\r\n/**\r\n * 设置视图组件(全局共享)\r\n */\r\n$di-&gt;setShared(&#39;view&#39;, function () {\r\n    $config = $this-&gt;getConfig(); // 获取配置\r\n\r\n    $view = new View(); // 实例化视图\r\n    $view-&gt;setViewsDir($config-&gt;application-&gt;viewsDir); // 设置视图路径(从配置文件config.php中获取)\r\n    return $view; // 返回实例\r\n});\r\n\r\n/**\r\n * URL组件，用来生成应用所有类型的url\r\n */\r\n$di-&gt;setShared(&#39;url&#39;, function () {\r\n    $config = $this-&gt;getConfig(); // 获取配置\r\n\r\n    $url = new UrlResolver(); // 实例化url类\r\n    $url-&gt;setBaseUri($config-&gt;application-&gt;baseUri); // 设置基URI(从配置文件config.php中获取)\r\n    return $url; // 返回url类示例\r\n});\r\n\r\n/**\r\n * 数据库连接，根据配置文件中的设置\r\n */\r\n$di-&gt;setShared(&#39;db&#39;, function () {\r\n    $config = $this-&gt;getConfig(); // 获取配置\r\n\r\n    $class = &#39;Phalcon\\Db\\Adapter\\Pdo\\\\&#39; . $config-&gt;database-&gt;adapter; // 数据库类型(Mysql),根据类型定位到对应的数据库操作PDO类\r\n    $params = [\r\n        &#39;host&#39;     =&gt; $config-&gt;database-&gt;host,\r\n        &#39;username&#39; =&gt; $config-&gt;database-&gt;username,\r\n        &#39;password&#39; =&gt; $config-&gt;database-&gt;password,\r\n        &#39;dbname&#39;   =&gt; $config-&gt;database-&gt;dbname,\r\n        &#39;charset&#39;  =&gt; $config-&gt;database-&gt;charset\r\n    ]; // 读取其它配置\r\n\r\n    /* 如果数据库是Postgresql，注销掉charset参数 */\r\n    if ($config-&gt;database-&gt;adapter == &#39;Postgresql&#39;) {\r\n        unset($params[&#39;charset&#39;]);\r\n    }\r\n\r\n    $connection = new $class($params); // 实例化数据库实例\r\n\r\n    return $connection; // 返回数据库实例\r\n});\r\n</code></pre>\r\n<h2 id=\"h2-3-4-loader-php\"><a name=\"3.4 自动加载配置文件loader.php\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.4 自动加载配置文件loader.php</h2><pre><code class=\"lang-php\">&lt;?php\r\n\r\n/**\r\n * 注册自动加载\r\n */\r\n$loader = new \\Phalcon\\Loader();\r\n\r\n/* 这里自动加载了modelsDir路径(配置) */\r\n$loader-&gt;registerDirs(\r\n    [\r\n        $config-&gt;application-&gt;modelsDir\r\n    ]\r\n)-&gt;register();\r\n</code></pre>\r\n<h2 id=\"h2-3-5-app-php\"><a name=\"3.5 应用引导文件app.php\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.5 应用引导文件app.php</h2><pre><code class=\"lang-php\">&lt;?php\r\n/**\r\n * Local variables 本地变量\r\n * @var \\Phalcon\\Mvc\\Micro $app 微应用实例\r\n */\r\n\r\n/**\r\n * 在这里添加路由\r\n * 根目录默认index\r\n */\r\n$app-&gt;get(&#39;/&#39;, function () {\r\n    echo $this[&#39;view&#39;]-&gt;render(&#39;index&#39;);\r\n});\r\n\r\n/**\r\n * 找不到时的操作(返回404)\r\n */\r\n$app-&gt;notFound(function () use($app) {\r\n    $app-&gt;response-&gt;setStatusCode(404, &quot;Not Found&quot;)-&gt;sendHeaders(); // 设置状态码404\r\n    echo $app[&#39;view&#39;]-&gt;render(&#39;404&#39;); // 转到404页面\r\n});\r\n</code></pre>\r\n<p>这样基本上这个微应用，Phalcon最简单的一种实现就跑起来了。</p>\r\n<h2 id=\"h2-3-6-\"><a name=\"3.6 小结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.6 小结</h2><p>一个内置的微应用，可以快速构建简单的应用。</p>\r\n<h1 id=\"h1-4-simple-\"><a name=\"4. 简单的单模块应用（simple类型项目）\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4. 简单的单模块应用（simple类型项目）</h1><h2 id=\"h2-4-1-\"><a name=\"4.1 大概的项目目录\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.1 大概的项目目录</h2><pre><code>Phalcon-simple/\r\n    app/\r\n        config/\r\n            config.php\r\n            loader.php\r\n            router.php\r\n            services.php\r\n        controllers/\r\n            ControllerBase.php\r\n            IndexController.php\r\n        library/\r\n        migrations/\r\n        models/\r\n        views/\r\n            index/\r\n                idnex.volt\r\n            index.volt\r\n    cache/\r\n    public/\r\n        css/\r\n        files/\r\n        img/\r\n        js/\r\n        temp/\r\n        .htaccess\r\n        index.php\r\n    .htaccess\r\n    .htrouter.php\r\n    index.html\r\n</code></pre><h2 id=\"h2-4-2-index-php\"><a name=\"4.2 index.php\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.2 index.php</h2><p>同样从index.php入口文件入手：</p>\r\n<pre><code class=\"lang-php\">&lt;?php\r\nuse Phalcon\\Di\\FactoryDefault; // 工厂默认DI\r\n\r\nerror_reporting(E_ALL);\r\n\r\ndefine(&#39;BASE_PATH&#39;, dirname(__DIR__)); // 定义入口根目录路径\r\ndefine(&#39;APP_PATH&#39;, BASE_PATH . &#39;/app&#39;); // 定义app目录路径\r\n\r\ntry {\r\n\r\n    /**\r\n     * 实例化默认工厂DI，已经自动注册了很多提供全栈框架的服务\r\n     */\r\n    $di = new FactoryDefault();\r\n\r\n    /**\r\n     * 引入router路由文件\r\n     */\r\n    include APP_PATH . &#39;/config/router.php&#39;;\r\n\r\n    /**\r\n     * 引入services服务注册文件\r\n     */\r\n    include APP_PATH . &#39;/config/services.php&#39;;\r\n\r\n    /**\r\n     * 为下面的内置设置，获取配置服务\r\n     */\r\n    $config = $di-&gt;getConfig();\r\n\r\n    /**\r\n     * 包含自动加载loader.php文件\r\n     */\r\n    include APP_PATH . &#39;/config/loader.php&#39;;\r\n\r\n    /**\r\n     * 加载请求控制\r\n     */\r\n    $application = new \\Phalcon\\Mvc\\Application($di);\r\n\r\n    echo str_replace([&quot;\\n&quot;,&quot;\\r&quot;,&quot;\\t&quot;], &#39;&#39;, $application-&gt;handle()-&gt;getContent()); // 移除换行,回车,跳格\r\n\r\n} catch (\\Exception $e) {\r\n    echo $e-&gt;getMessage() . &#39;&lt;br&gt;&#39;;\r\n    echo &#39;&lt;pre&gt;&#39; . $e-&gt;getTraceAsString() . &#39;&lt;/pre&gt;&#39;;\r\n}\r\n</code></pre>\r\n<h2 id=\"h2-4-3-router-php-\"><a name=\"4.3 router.php路由文件\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.3 router.php路由文件</h2><p>获取路由服务，定义路由，执行。</p>\r\n<pre><code class=\"lang-php\">&lt;?php\r\n\r\n$router = $di-&gt;getRouter();\r\n\r\n// Define your routes here\r\n// 在这里定义路由\r\n\r\n$router-&gt;handle();\r\n</code></pre>\r\n<h2 id=\"h2-4-4-services-php-\"><a name=\"4.4 services.php服务注册文件\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.4 services.php服务注册文件</h2><pre><code class=\"lang-php\">&lt;?php\r\n\r\nuse Phalcon\\Mvc\\View; // view层\r\nuse Phalcon\\Mvc\\View\\Engine\\Php as PhpEngine; // view层php引擎\r\nuse Phalcon\\Mvc\\Url as UrlResolver; // url组件\r\nuse Phalcon\\Mvc\\View\\Engine\\Volt as VoltEngine; // volt引擎\r\nuse Phalcon\\Mvc\\Model\\Metadata\\Memory as MetaDataAdapter; // 元数据适配器\r\nuse Phalcon\\Session\\Adapter\\Files as SessionAdapter; // session文件适配器\r\nuse Phalcon\\Flash\\Direct as Flash; // 闪存服务\r\n\r\n/**\r\n * 共享的配置服务\r\n */\r\n$di-&gt;setShared(&#39;config&#39;, function () {\r\n    return include APP_PATH . &quot;/config/config.php&quot;; // 配置文件所在路径\r\n});\r\n\r\n/**\r\n * URL组件,用来生成所有类型的应用url\r\n */\r\n$di-&gt;setShared(&#39;url&#39;, function () {\r\n    $config = $this-&gt;getConfig(); // 获取配置\r\n\r\n    $url = new UrlResolver(); // 实例化\r\n    $url-&gt;setBaseUri($config-&gt;application-&gt;baseUri); // 传入基URI\r\n\r\n    return $url; // 返回URL实例\r\n});\r\n\r\n/**\r\n * 设置视图组件\r\n */\r\n$di-&gt;setShared(&#39;view&#39;, function () {\r\n    $config = $this-&gt;getConfig(); // 获取配置\r\n\r\n    $view = new View(); // 实例化\r\n    $view-&gt;setDI($this); // 设置为服务\r\n    $view-&gt;setViewsDir($config-&gt;application-&gt;viewsDir); // 传入views路径\r\n\r\n    // 注册模板引擎; 注册了.volt和.phtml结尾的文件\r\n    $view-&gt;registerEngines([\r\n        &#39;.volt&#39; =&gt; function ($view) {\r\n            $config = $this-&gt;getConfig(); // 获取配置\r\n\r\n            $volt = new VoltEngine($view, $this); // 实例化引擎\r\n\r\n            $volt-&gt;setOptions([\r\n                &#39;compiledPath&#39; =&gt; $config-&gt;application-&gt;cacheDir,\r\n                &#39;compiledSeparator&#39; =&gt; &#39;_&#39;\r\n            ]); // 设置参数;缓存路径和缓存文件连接符\r\n\r\n            return $volt; // 返回实例\r\n        },\r\n        &#39;.phtml&#39; =&gt; PhpEngine::class\r\n\r\n    ]);\r\n\r\n    return $view; // 返回实例\r\n});\r\n\r\n/**\r\n * 数据库连接\r\n */\r\n$di-&gt;setShared(&#39;db&#39;, function () {\r\n    $config = $this-&gt;getConfig(); // 获取配置\r\n\r\n    $class = &#39;Phalcon\\Db\\Adapter\\Pdo\\\\&#39; . $config-&gt;database-&gt;adapter; //数据库类型(mysql)\r\n    $params = [\r\n        &#39;host&#39;     =&gt; $config-&gt;database-&gt;host,\r\n        &#39;username&#39; =&gt; $config-&gt;database-&gt;username,\r\n        &#39;password&#39; =&gt; $config-&gt;database-&gt;password,\r\n        &#39;dbname&#39;   =&gt; $config-&gt;database-&gt;dbname,\r\n        &#39;charset&#39;  =&gt; $config-&gt;database-&gt;charset\r\n    ];\r\n\r\n    /* 如果是Postgresql数据库,删除charset参数 */\r\n    if ($config-&gt;database-&gt;adapter == &#39;Postgresql&#39;) {\r\n        unset($params[&#39;charset&#39;]);\r\n    }\r\n\r\n    $connection = new $class($params); //实例化\r\n\r\n    return $connection; //返回连接实例\r\n});\r\n\r\n\r\n/**\r\n * 如果配置了元数据适配器就使用原数据适配器否则使用内存\r\n */\r\n$di-&gt;setShared(&#39;modelsMetadata&#39;, function () {\r\n    return new MetaDataAdapter();\r\n});\r\n\r\n/**\r\n * 注册Bootstrap框架类中的会话闪存服务\r\n */\r\n$di-&gt;set(&#39;flash&#39;, function () {\r\n    return new Flash([\r\n        &#39;error&#39;   =&gt; &#39;alert alert-danger&#39;,\r\n        &#39;success&#39; =&gt; &#39;alert alert-success&#39;,\r\n        &#39;notice&#39;  =&gt; &#39;alert alert-info&#39;,\r\n        &#39;warning&#39; =&gt; &#39;alert alert-warning&#39;\r\n    ]);\r\n});\r\n\r\n/**\r\n * 启动session,当有组件请求session服务的时候\r\n */\r\n$di-&gt;setShared(&#39;session&#39;, function () {\r\n    $session = new SessionAdapter(); // session适配器\r\n    $session-&gt;start();\r\n\r\n    return $session;\r\n});\r\n</code></pre>\r\n<p>可以看到simple项目已经使用了view层，引入了volt引擎，session服务等，甚至还注册前端bootstrap框架的class。</p>\r\n<h2 id=\"h2-4-5-loader-php-\"><a name=\"4.5 loader.php自动加载文件\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.5 loader.php自动加载文件</h2><pre><code class=\"lang-php\">&lt;?php\r\n\r\n$loader = new \\Phalcon\\Loader();\r\n\r\n/**\r\n * 自动加载配置文件中定义好的路径\r\n */\r\n$loader-&gt;registerDirs(\r\n    [\r\n        $config-&gt;application-&gt;controllersDir,\r\n        $config-&gt;application-&gt;modelsDir\r\n    ]\r\n)-&gt;register();\r\n</code></pre>\r\n<h2 id=\"h2-4-6-controllers\"><a name=\"4.6 controllers\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.6 controllers</h2><p>controllers下定义了一个ControllerBase类，和一个IndexController类：<br>ControllerBase.php</p>\r\n<pre><code class=\"lang-php\">&lt;?php\r\n\r\nuse Phalcon\\Mvc\\Controller;\r\n\r\nclass ControllerBase extends Controller\r\n{\r\n\r\n}\r\n</code></pre>\r\n<p>IndexController.php</p>\r\n<pre><code>&lt;?php\r\n\r\nclass IndexController extends ControllerBase\r\n{\r\n\r\n    public function indexAction()\r\n    {\r\n\r\n    }\r\n\r\n}\r\n</code></pre><p>基本上simple这个项目就是一个简单的省略了modle的基本单模块项目。</p>\r\n<h2 id=\"h2-4-7-\"><a name=\"4.7 小结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.7 小结</h2><p>一个简单的单模块web应用。</p>\r\n<h1 id=\"h1-5-cli-cli-\"><a name=\"5. cli命令行应用（cli类型项目）\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5. cli命令行应用（cli类型项目）</h1><h2 id=\"h2-5-1-\"><a name=\"5.1 大概的项目目录\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.1 大概的项目目录</h2><pre><code>Phalcon-cli/\r\n    app/\r\n        config/\r\n            config.php\r\n            loader.php\r\n            services.php\r\n        models/\r\n        tasks/\r\n            MainTask.php\r\n            VersionTask.php\r\n        bootstrap.php\r\n    public/\r\n        css/\r\n        js/\r\n    run\r\n</code></pre><p>cli项目的架构看上去更加简单明了。</p>\r\n<h2 id=\"h2-5-2-run-\"><a name=\"5.2 run文件\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.2 run文件</h2><p>run文件是用来执行项目的入口文件，只需要在命令行执行：</p>\r\n<pre><code>php run\r\n</code></pre><p>输出：</p>\r\n<pre><code>Congratulations! You are now flying with Phalcon CLI!\r\n</code></pre><p>这是在MainTask.php中输出的内容。<br>看一下run文件，就是执行了一段php代码，而这段代码只是引入的bootstrap引导文件：</p>\r\n<pre><code>#!/usr/bin/env php\r\n&lt;?php\r\ninclude __DIR__ . &quot;/app/bootstrap.php&quot;;\r\n</code></pre><h2 id=\"h2-5-3-bootstrap-php-\"><a name=\"5.3 bootstrap.php引导程序\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.3 bootstrap.php引导程序</h2><pre><code class=\"lang-php\">&lt;?php\r\n\r\nuse Phalcon\\Di\\FactoryDefault\\Cli as CliDi; //引入默认工厂DI的cli模式\r\nuse Phalcon\\Cli\\Console as ConsoleApp; // 引入用来创建cli应用的Console组件\r\n\r\ndefine(&#39;BASE_PATH&#39;, dirname(__DIR__));\r\ndefine(&#39;APP_PATH&#39;, BASE_PATH . &#39;/app&#39;);\r\n\r\n/**\r\n * 实例化默认工厂DI的cli模式,自动加载提供了全栈框架的服务\r\n */\r\n$di = new CliDi();\r\n\r\n/**\r\n * 包含服务注册文件\r\n */\r\ninclude APP_PATH . &#39;/config/services.php&#39;;\r\n\r\n/**\r\n * 获取配置服务中的配置\r\n */\r\n$config = $di-&gt;getConfig();\r\n\r\n/**\r\n * 包含自动加载\r\n */\r\ninclude APP_PATH . &#39;/config/loader.php&#39;;\r\n\r\n/**\r\n * 创建一个console应用(cli)\r\n */\r\n$console = new ConsoleApp($di);\r\n\r\n/**\r\n * 处理console参数\r\n */\r\n$arguments = [];\r\n\r\nforeach ($argv as $k =&gt; $arg) {\r\n    if ($k == 1) {\r\n        $arguments[&#39;task&#39;] = $arg; // 第一个参数task类\r\n    } elseif ($k == 2) {\r\n        $arguments[&#39;action&#39;] = $arg; // 第二个参数action方法\r\n    } elseif ($k &gt;= 3) {\r\n        $arguments[&#39;params&#39;][] = $arg; // 第三个参数,额外参数(数组)\r\n    }\r\n}\r\n\r\ntry {\r\n\r\n    /**\r\n     * Handle传入处理好的参数\r\n     */\r\n    $console-&gt;handle($arguments);\r\n\r\n    /**\r\n     * 如果配置中printNewLine设置了true,将会在末尾另起一行\r\n     *\r\n     * 仅仅只是为了在命令行中更直观的表现\r\n     */\r\n    if (isset($config[&quot;printNewLine&quot;]) &amp;&amp; $config[&quot;printNewLine&quot;]) {\r\n        echo PHP_EOL; // 输出一个换行符\r\n    }\r\n\r\n} catch (Exception $e) {\r\n    echo $e-&gt;getMessage() . PHP_EOL;\r\n    echo $e-&gt;getTraceAsString() . PHP_EOL;\r\n    exit(255);\r\n}\r\n</code></pre>\r\n<h2 id=\"h2-5-4-service-php-\"><a name=\"5.4 service.php服务注册\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.4 service.php服务注册</h2><p>注册了配置服务和数据库服务：</p>\r\n<pre><code class=\"lang-php\">&lt;?php\r\n\r\n/**\r\n * 注册共享配置服务\r\n */\r\n$di-&gt;setShared(&#39;config&#39;, function () {\r\n    return include APP_PATH . &#39;/config/config.php&#39;; // 配置文件路径\r\n});\r\n\r\n/**\r\n * 数据库连接\r\n */\r\n$di-&gt;setShared(&#39;db&#39;, function () {\r\n    $config = $this-&gt;getConfig(); // 获取配置\r\n\r\n    $class = &#39;Phalcon\\Db\\Adapter\\Pdo\\\\&#39; . $config-&gt;database-&gt;adapter; // 数据库类型(Mysql)\r\n\r\n    $params = [\r\n        &#39;host&#39;     =&gt; $config-&gt;database-&gt;host,\r\n        &#39;username&#39; =&gt; $config-&gt;database-&gt;username,\r\n        &#39;password&#39; =&gt; $config-&gt;database-&gt;password,\r\n        &#39;dbname&#39;   =&gt; $config-&gt;database-&gt;dbname,\r\n        &#39;charset&#39;  =&gt; $config-&gt;database-&gt;charset\r\n    ];\r\n\r\n    /* 如果数据库是Postgresql,删除charset变量 */\r\n    if ($config-&gt;database-&gt;adapter == &#39;Postgresql&#39;) {\r\n        unset($params[&#39;charset&#39;]);\r\n    }\r\n\r\n    $connection = new $class($params); // 数据库实例\r\n\r\n    return $connection; // 返回数据库实例\r\n});\r\n</code></pre>\r\n<h2 id=\"h2-5-5-loader-php-\"><a name=\"5.5 loader.php自动加载\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.5 loader.php自动加载</h2><p>cli项目与普通web项目不一样的是，自动加载了tasks目录和models目录，但实际上道理是一样的，task任务就好比是Controller。</p>\r\n<pre><code class=\"lang-php\">&lt;?php\r\n$loader = new \\Phalcon\\Loader();\r\n$loader-&gt;registerDirs([\r\n    APP_PATH . &#39;/tasks&#39;,\r\n    APP_PATH . &#39;/models&#39;\r\n]);\r\n$loader-&gt;register();\r\n</code></pre>\r\n<h2 id=\"h2-5-6-tasks-\"><a name=\"5.6 tasks目录\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.6 tasks目录</h2><p>看一下这个demo项目的两个task文件。<br>MainTask.php：</p>\r\n<pre><code class=\"lang-php\">&lt;?php\r\n\r\nclass MainTask extends \\Phalcon\\Cli\\Task\r\n{\r\n    public function mainAction()\r\n    {\r\n        echo &quot;Congratulations! You are now flying with Phalcon CLI!&quot;;\r\n    }\r\n}\r\n</code></pre>\r\n<p>VersionTask.php：</p>\r\n<pre><code>&lt;?php\r\n\r\nclass VersionTask extends \\Phalcon\\Cli\\Task\r\n{\r\n    public function mainAction()\r\n    {\r\n        $config = $this-&gt;getDI()-&gt;get(&#39;config&#39;); //获取配置\r\n\r\n        echo $config[&#39;version&#39;]; //输出版本\r\n    }\r\n}\r\n</code></pre><p>都继承了 Phalcon\\Cli\\Task 类；MainTask 为系统默认类，类似于默认IndexController那么个意思。</p>\r\n<h2 id=\"h2-5-7-\"><a name=\"5.7 小结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.7 小结</h2><p>一个cli模式的demo，可以用来编写简单的cli脚本。</p>\r\n<h1 id=\"h1-6-modules-\"><a name=\"6. 多模块项目（modules类型项目）\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>6. 多模块项目（modules类型项目）</h1><h2 id=\"h2-6-1-\"><a name=\"6.1 项目目录\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>6.1 项目目录</h2><p>这个多模块项目就文件稍微多一点了，可以看到这里有两个模块，一个是web项目，一个是cli项目。</p>\r\n<pre><code>Phalcon-modules\r\n    app/\r\n        common/\r\n            library/\r\n            models/\r\n        config/\r\n            config.php\r\n            loader.php\r\n            routes.php\r\n            services.php\r\n            services_cli.php\r\n            services_web.php\r\n        modules/\r\n            cli/\r\n                migrations/\r\n                tasks/\r\n                    MainTask.php\r\n                    VersionTask.php\r\n                Module.php\r\n            frontend/\r\n                controllers/\r\n                    ControllerBase.php\r\n                    IndexController.php\r\n                models/\r\n                views/\r\n                    index/\r\n                        index.volt\r\n                    index.volt\r\n                Module.php\r\n        bootstrap_cli.php\r\n        bootstrap_web.php\r\n    cache/\r\n        volt/\r\n    public/\r\n        css/\r\n        files/\r\n        img/\r\n        js/\r\n        temp/\r\n        .htaccess\r\n        index.php\r\n    .htaccess\r\n    .htrouter.php\r\n    index.html\r\n    run\r\n</code></pre><p>大概地看一下文件，可以发现这个模块是simple项目和cli项目合并起来的一个项目，所以之前看过的内容我们就不重复关注了，我们还是重点放在整体架构分析和不同的地方。</p>\r\n<h2 id=\"h2-6-2-index-php-\"><a name=\"6.2 index.php入口文件\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>6.2 index.php入口文件</h2><p>依然是入口文件，不过这次这个入口文件变了：</p>\r\n<pre><code class=\"lang-php\">&lt;?php\r\nrequire &#39;../app/bootstrap_web.php&#39;;\r\n</code></pre>\r\n<p>只有这么一句，因为public入口下指引的应该是web项目，所以这里直接引入了web项目的指引程序文件bootstrap<em>web.php。<br>基本相当于将各个模块的入口文件放到了app目录下，以bootstrap</em>开头命名：</p>\r\n<pre><code>common/\r\nconfig/\r\nmodules/\r\n    cli/\r\n        migrations/\r\n        tasks/\r\n        Module.php\r\n    frontend/\r\n        controllers/\r\n        models/\r\n        views/\r\n        Module.php\r\nbootstrap_cli.php\r\nbootstrap_web.php\r\n</code></pre><p>common为公共的模块，公共类公共模型什么的放这里；config配置目录，与之前的区别是，services.php放公共服务文件，services_cli.php放cli模块的服务文件，services_web.php放web项模块的服务文件。modules则为两个模块的具体文件，区别是底下多了一个Module.php。</p>\r\n<h2 id=\"h2-6-3-config-php-\"><a name=\"6.3 config.php配置文件\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>6.3 config.php配置文件</h2><p>配置文件中的路径配置不再配置到Controller，model层面，只配置到外一层和公共模块下。</p>\r\n<pre><code class=\"lang-php\">&#39;application&#39; =&gt; [\r\n        &#39;appDir&#39;         =&gt; APP_PATH . &#39;/&#39;,\r\n        &#39;modelsDir&#39;      =&gt; APP_PATH . &#39;/common/models/&#39;,\r\n        &#39;migrationsDir&#39;  =&gt; APP_PATH . &#39;/migrations/&#39;,\r\n        &#39;cacheDir&#39;       =&gt; BASE_PATH . &#39;/cache/&#39;,\r\n        &#39;baseUri&#39;        =&gt; preg_replace(&#39;/public([\\/\\\\\\\\])index.php$/&#39;, &#39;&#39;, $_SERVER[&quot;PHP_SELF&quot;]),\r\n    ]\r\n</code></pre>\r\n<h2 id=\"h2-6-4-routes-php-\"><a name=\"6.4 routes.php路由文件\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>6.4 routes.php路由文件</h2><p>配置路由</p>\r\n<pre><code class=\"lang-php\">&lt;?php\r\n\r\n$router = $di-&gt;getRouter();\r\n\r\nforeach ($application-&gt;getModules() as $key =&gt; $module) {\r\n    $namespace = preg_replace(&#39;/Module$/&#39;, &#39;Controllers&#39;, $module[&quot;className&quot;]);\r\n    $router-&gt;add(&#39;/&#39;.$key.&#39;/:params&#39;, [\r\n        &#39;namespace&#39; =&gt; $namespace,\r\n        &#39;module&#39; =&gt; $key,\r\n        &#39;controller&#39; =&gt; &#39;index&#39;,\r\n        &#39;action&#39; =&gt; &#39;index&#39;,\r\n        &#39;params&#39; =&gt; 1\r\n    ])-&gt;setName($key);\r\n    $router-&gt;add(&#39;/&#39;.$key.&#39;/:controller/:params&#39;, [\r\n        &#39;namespace&#39; =&gt; $namespace,\r\n        &#39;module&#39; =&gt; $key,\r\n        &#39;controller&#39; =&gt; 1,\r\n        &#39;action&#39; =&gt; &#39;index&#39;,\r\n        &#39;params&#39; =&gt; 2\r\n    ]);\r\n    $router-&gt;add(&#39;/&#39;.$key.&#39;/:controller/:action/:params&#39;, [\r\n        &#39;namespace&#39; =&gt; $namespace,\r\n        &#39;module&#39; =&gt; $key,\r\n        &#39;controller&#39; =&gt; 1,\r\n        &#39;action&#39; =&gt; 2,\r\n        &#39;params&#39; =&gt; 3\r\n    ]);\r\n}\r\n</code></pre>\r\n<h2 id=\"h2-6-5-loader-php-\"><a name=\"6.5 loader.php自动加载文件\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>6.5 loader.php自动加载文件</h2><pre><code class=\"lang-php\">&lt;?php\r\n\r\nuse Phalcon\\Loader;\r\n\r\n$loader = new Loader();\r\n\r\n/**\r\n * 注册命名空间;common下的公共模型,库等\r\n */\r\n$loader-&gt;registerNamespaces([\r\n    &#39;PhalconModules\\Models&#39; =&gt; APP_PATH . &#39;/common/models/&#39;,\r\n    &#39;PhalconModules&#39;        =&gt; APP_PATH . &#39;/common/library/&#39;,\r\n]);\r\n\r\n/**\r\n * 注册模块下的类\r\n */\r\n$loader-&gt;registerClasses([\r\n    &#39;PhalconModules\\Modules\\Frontend\\Module&#39; =&gt; APP_PATH . &#39;/modules/frontend/Module.php&#39;, // web模块的Module.php\r\n    &#39;PhalconModules\\Modules\\Cli\\Module&#39;      =&gt; APP_PATH . &#39;/modules/cli/Module.php&#39; // cli模块的Module.php\r\n]);\r\n\r\n$loader-&gt;register();\r\n</code></pre>\r\n<h2 id=\"h2-6-6-module-php-\"><a name=\"6.6 Module.php模块文件\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>6.6 Module.php模块文件</h2><p>在单模块项目中的路径加载配置，服务加载配置等需要区别开不同模块的，都移到了Module.php文件，以实现 ModuleDefinitionInterface 模块定义接口的形式实现。<br>比如Web模块的Module.php文件：</p>\r\n<pre><code class=\"lang-php\">&lt;?php\r\nnamespace PhalconModules\\Modules\\Frontend;\r\n\r\nuse Phalcon\\DiInterface;\r\nuse Phalcon\\Loader;\r\nuse Phalcon\\Mvc\\View;\r\nuse Phalcon\\Mvc\\View\\Engine\\Php as PhpEngine;\r\nuse Phalcon\\Mvc\\ModuleDefinitionInterface;\r\n\r\nclass Module implements ModuleDefinitionInterface\r\n{\r\n    /**\r\n     * 注册模块的自动加载\r\n     *\r\n     * @param DiInterface $di\r\n     */\r\n    public function registerAutoloaders(DiInterface $di = null)\r\n    {\r\n        $loader = new Loader();\r\n\r\n        /* 在这里定义当前模块下的Controllers,Models等目录路径 */\r\n        $loader-&gt;registerNamespaces([\r\n            &#39;PhalconModules\\Modules\\Frontend\\Controllers&#39; =&gt; __DIR__ . &#39;/controllers/&#39;,\r\n            &#39;PhalconModules\\Modules\\Frontend\\Models&#39; =&gt; __DIR__ . &#39;/models/&#39;,\r\n        ]);\r\n\r\n        $loader-&gt;register();\r\n    }\r\n\r\n    /**\r\n     * 注册模块的服务\r\n     *\r\n     * @param DiInterface $di\r\n     */\r\n    public function registerServices(DiInterface $di)\r\n    {\r\n        /**\r\n         * 设置视图组件\r\n         */\r\n        $di-&gt;set(&#39;view&#39;, function () {\r\n            $view = new View();\r\n            $view-&gt;setDI($this);\r\n            $view-&gt;setViewsDir(__DIR__ . &#39;/views/&#39;); // 视图路径\r\n\r\n            $view-&gt;registerEngines([\r\n                &#39;.volt&#39;  =&gt; &#39;voltShared&#39;,\r\n                &#39;.phtml&#39; =&gt; PhpEngine::class\r\n            ]); // 注册视图引擎\r\n\r\n            return $view;\r\n        });\r\n    }\r\n}\r\n</code></pre>\r\n<p>cli模块的Module.php：</p>\r\n<pre><code class=\"lang-php\">&lt;?php\r\nnamespace PhalconModules\\Modules\\Cli;\r\n\r\nuse Phalcon\\DiInterface;\r\nuse Phalcon\\Loader;\r\nuse Phalcon\\Mvc\\ModuleDefinitionInterface;\r\n\r\nclass Module implements ModuleDefinitionInterface\r\n{\r\n    /**\r\n     * 注册模块的自动加载\r\n     *\r\n     * @param DiInterface $di\r\n     */\r\n    public function registerAutoloaders(DiInterface $di = null)\r\n    {\r\n        $loader = new Loader();\r\n\r\n        $loader-&gt;registerNamespaces([\r\n            &#39;PhalconModules\\Modules\\Cli\\Tasks&#39; =&gt; __DIR__ . &#39;/tasks/&#39;,\r\n        ]);\r\n\r\n        $loader-&gt;register();\r\n    }\r\n\r\n    /**\r\n     * 注册模块的服务\r\n     *\r\n     * @param DiInterface $di\r\n     */\r\n    public function registerServices(DiInterface $di)\r\n    {\r\n    }\r\n}\r\n</code></pre>\r\n<p>根据这样的一个套路，我们可以引入更多的模块。</p>\r\n<h2 id=\"h2-6-7-\"><a name=\"6.7 小结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>6.7 小结</h2><p>多模块的设计思路，按照这个套路，我们可以自由地搭建起我们的框架并应用到项目中。</p>\r\n', '', 0, 'publish', 1, 0, '/article/72.html', '', 0, 216, '2018-02-06 02:25:40', '2018-02-06 02:25:40', '2018-02-06 02:25:40', NULL);
INSERT INTO `pt_post` VALUES (73, 10, 'article', 'Workerman中维护心跳包（Websocket为例）', '# 1. 什么是心跳\r\n其实简单的说就是：客户端隔一段时间就给服务端发送消息，用来告诉服务端这个连接没有断，是正常的，从而维护长连接的持久性。\r\n\r\n如果不加心跳包，有的服务器节点（防火墙）会自动把一定时间之内没有数据交互的连接给断掉；而且这中间指不定会有什么乱七八糟的比如机器断电、网线拔出这些幺蛾子出现导致客户端断线。\r\n\r\n但是类似断网这种**极端情况**导致客户端断开连接，服务端是不知道的。因为客户端在正常情况下主动断开会向服务端发送一个tcp的fin包。\r\n> 什么是FIN包？\r\nFIN包表示发送端已经达到数据末尾，也就是说双方的数据传送完成，没有数据可以传送了。\r\n发送FIN标志 位的TCP数据包后，连接将被断开。\r\n这个标志的数据包也经常被用于进行端口扫描。\r\n\r\n然而极端情况下，客户端没有机会发这个包，就会导致服务端并不知道客户端断掉了。\r\n\r\n# 2. 长连接必须加心跳\r\n长连接，只要是长连接，长时间不通讯肯定会被防火墙干掉然后断开，服务在非可控情况下断开是非常不好的情况；所以长连接无论如何都要加上心跳包。\r\n\r\n# 3. 心跳实例\r\n接下来以workerman建立websocket连接为实例。\r\n## 3.1 前端JavaScript代码\r\n在onopen连接建立的时候，定义一个定时器，每10秒钟发送一个包，包的内容随意。\r\n```javascript\r\nvar ws = new WebSocket(\"ws://www.goozp.com\");\r\n\r\n//连接websocket\r\nws.onopen = function () {\r\n	setInterval(function () {\r\n		ws.send(\'Hello!\');\r\n	}, 10000)\r\n};\r\n```\r\n一般发送心跳包的间隔在60秒以内。\r\n\r\n## 3.2 Workerman中处理断线\r\n此处参考：[官方文档：心跳](http://doc.workerman.net/315282 \"官方文档：心跳\")\r\n\r\n可以先定义一些常量在之后用到，方便配置：\r\n```\r\ndefine(\'HEARTBEAT_TIME\', 30); // 定义一个心跳间隔30秒\r\ndefine(\'CHECK_HEARTBEAT_TIME\', 1); // 检查连接的间隔时间\r\n```\r\n\r\n当接收到信息时，我们就记录下接收到信息的时间：\r\n```php\r\n$worker->onMessage = function($connection, $msg) {\r\n    // 给connection临时设置一个lastMessageTime属性，用来记录上次收到消息的时间\r\n    $connection->lastMessageTime = time();\r\n\r\n    // TODO 其它业务逻辑...\r\n};\r\n```\r\n\r\n在进程启动后设置一个定时器，每隔一段时间遍历一遍当前worker的所有连接\r\n```php\r\n// 进程启动后设置一个每秒运行一次的定时器\r\n$worker->onWorkerStart = function($worker) {\r\n    Timer::add(CHECK_HEARTBEAT_TIME, function()use($worker){\r\n        $time_now = time();\r\n        foreach($worker->connections as $connection) {\r\n            // 有可能该connection还没收到过消息，则lastMessageTime设置为当前时间\r\n            if (empty($connection->lastMessageTime)) {\r\n                $connection->lastMessageTime = $time_now;\r\n                continue;\r\n            }\r\n\r\n            // 上次通讯时间间隔大于心跳间隔，则认为客户端已经下线，关闭连接\r\n            if ($time_now - $connection->lastMessageTime > HEARTBEAT_TIME) {\r\n                $connection->close();\r\n            }\r\n        }\r\n    });\r\n};\r\n```\r\n这样，结合前端的心跳包，我们就可以做到维持连接的长久，以及踢出设置时间段内未使用的废弃连接。\r\n', '<h1 id=\"h1-1-\"><a name=\"1. 什么是心跳\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1. 什么是心跳</h1><p>其实简单的说就是：客户端隔一段时间就给服务端发送消息，用来告诉服务端这个连接没有断，是正常的，从而维护长连接的持久性。</p>\r\n<p>如果不加心跳包，有的服务器节点（防火墙）会自动把一定时间之内没有数据交互的连接给断掉；而且这中间指不定会有什么乱七八糟的比如机器断电、网线拔出这些幺蛾子出现导致客户端断线。</p>\r\n<p>但是类似断网这种<strong>极端情况</strong>导致客户端断开连接，服务端是不知道的。因为客户端在正常情况下主动断开会向服务端发送一个tcp的fin包。</p>\r\n<blockquote>\r\n<p>什么是FIN包？<br>FIN包表示发送端已经达到数据末尾，也就是说双方的数据传送完成，没有数据可以传送了。<br>发送FIN标志 位的TCP数据包后，连接将被断开。<br>这个标志的数据包也经常被用于进行端口扫描。</p>\r\n</blockquote>\r\n<p>然而极端情况下，客户端没有机会发这个包，就会导致服务端并不知道客户端断掉了。</p>\r\n<h1 id=\"h1-2-\"><a name=\"2. 长连接必须加心跳\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2. 长连接必须加心跳</h1><p>长连接，只要是长连接，长时间不通讯肯定会被防火墙干掉然后断开，服务在非可控情况下断开是非常不好的情况；所以长连接无论如何都要加上心跳包。</p>\r\n<h1 id=\"h1-3-\"><a name=\"3. 心跳实例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3. 心跳实例</h1><p>接下来以workerman建立websocket连接为实例。</p>\r\n<h2 id=\"h2-3-1-javascript-\"><a name=\"3.1 前端JavaScript代码\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.1 前端JavaScript代码</h2><p>在onopen连接建立的时候，定义一个定时器，每10秒钟发送一个包，包的内容随意。</p>\r\n<pre><code class=\"lang-javascript\">var ws = new WebSocket(&quot;ws://www.goozp.com&quot;);\r\n\r\n//连接websocket\r\nws.onopen = function () {\r\n    setInterval(function () {\r\n        ws.send(&#39;Hello!&#39;);\r\n    }, 10000)\r\n};\r\n</code></pre>\r\n<p>一般发送心跳包的间隔在60秒以内。</p>\r\n<h2 id=\"h2-3-2-workerman-\"><a name=\"3.2 Workerman中处理断线\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.2 Workerman中处理断线</h2><p>此处参考：<a href=\"http://doc.workerman.net/315282\" title=\"官方文档：心跳\">官方文档：心跳</a></p>\r\n<p>可以先定义一些常量在之后用到，方便配置：</p>\r\n<pre><code>define(&#39;HEARTBEAT_TIME&#39;, 30); // 定义一个心跳间隔30秒\r\ndefine(&#39;CHECK_HEARTBEAT_TIME&#39;, 1); // 检查连接的间隔时间\r\n</code></pre><p>当接收到信息时，我们就记录下接收到信息的时间：</p>\r\n<pre><code class=\"lang-php\">$worker-&gt;onMessage = function($connection, $msg) {\r\n    // 给connection临时设置一个lastMessageTime属性，用来记录上次收到消息的时间\r\n    $connection-&gt;lastMessageTime = time();\r\n\r\n    // TODO 其它业务逻辑...\r\n};\r\n</code></pre>\r\n<p>在进程启动后设置一个定时器，每隔一段时间遍历一遍当前worker的所有连接</p>\r\n<pre><code class=\"lang-php\">// 进程启动后设置一个每秒运行一次的定时器\r\n$worker-&gt;onWorkerStart = function($worker) {\r\n    Timer::add(CHECK_HEARTBEAT_TIME, function()use($worker){\r\n        $time_now = time();\r\n        foreach($worker-&gt;connections as $connection) {\r\n            // 有可能该connection还没收到过消息，则lastMessageTime设置为当前时间\r\n            if (empty($connection-&gt;lastMessageTime)) {\r\n                $connection-&gt;lastMessageTime = $time_now;\r\n                continue;\r\n            }\r\n\r\n            // 上次通讯时间间隔大于心跳间隔，则认为客户端已经下线，关闭连接\r\n            if ($time_now - $connection-&gt;lastMessageTime &gt; HEARTBEAT_TIME) {\r\n                $connection-&gt;close();\r\n            }\r\n        }\r\n    });\r\n};\r\n</code></pre>\r\n<p>这样，结合前端的心跳包，我们就可以做到维持连接的长久，以及踢出设置时间段内未使用的废弃连接。</p>\r\n', '', 0, 'publish', 1, 0, '/article/73.html', '', 0, 188, '2018-02-06 03:33:12', '2018-02-06 03:33:12', '2018-02-06 03:33:12', NULL);
INSERT INTO `pt_post` VALUES (74, 10, 'article', 'LeetCode刷题之4：Valid Parentheses（20）', '# 1. 题目\r\n## 1.1 英文\r\nGiven a string containing **just** the characters `\'(\'`, `\')\'`, `\'{\'`, `\'}\'`, `\'[\'` and `\']\'`, determine if the input string is valid.\r\n\r\nThe brackets must close in the correct order, `\"()\"` and `\"()[]{}\"` are all valid but `\"(]\"` and `\"([)]\"` are not.\r\n\r\n## 1.2 中文\r\n给予一个包含`\'(\'`, `\')\'`, `\'{\'`, `\'}\'`, `\'[\'` 和 `\']\'`的字符串，检查该字符串是否有效；括弧必须正确地用另一边关闭，就像`\"()\"` and `\"()[]{}\"`，不能`\"(]\"`或者`\"([)]\"`。\r\n\r\n# 2. 解答\r\n看到这道题，第一反应就是用栈来做，将匹配的左括弧压栈然后匹配。\r\n\r\n用简单的方式来实现。\r\n接下来用go语言来实现，利用切片做一个类似栈的中间存储，匹配最后一个就可以。因为括弧就只有这三种，所以事先利用字典定义好括弧的集合用于匹配。\r\n```go\r\nvar OpenP map[byte]byte = map[byte]byte{\'(\':\')\' , \'[\':\']\', \'{\':\'}\'}\r\nvar CloseP map[byte]byte = map[byte]byte{\')\':\'(\' , \']\':\'[\', \'}\':\'{\'}\r\n\r\nfunc isValid(s string) bool {\r\n    buf := make([]byte, 0, len(s))\r\n\r\n    for i := 0; i < len(s); i++ {\r\n        c := s[i]\r\n\r\n        // 如果是左半部分；存进切片中\r\n        if _, ok := OpenP[c]; ok{\r\n            buf = append(buf,c)\r\n            continue\r\n        }\r\n\r\n        // 如果不是左半部分，进行判断\r\n        openOne := CloseP[c] // c对应的前半部分\r\n        bufLen := len(buf)\r\n        // buf中没有，或者 最后一个buf[bufLen-1]和当前c对应的前半部分不匹配；\r\n        if len(buf) <= 0 || buf[bufLen-1] != openOne{\r\n            return false\r\n        }\r\n\r\n        // 匹配到了，切割切片，将c和c对应的前半部分（最后一个）切掉\r\n        buf = buf[:bufLen-1]\r\n    }\r\n\r\n    // 最后buf不应该有东西\r\n    return len(buf)==0\r\n}\r\n```', '<h1 id=\"h1-1-\"><a name=\"1. 题目\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1. 题目</h1><h2 id=\"h2-1-1-\"><a name=\"1.1 英文\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.1 英文</h2><p>Given a string containing <strong>just</strong> the characters <code>&#39;(&#39;</code>, <code>&#39;)&#39;</code>, <code>&#39;{&#39;</code>, <code>&#39;}&#39;</code>, <code>&#39;[&#39;</code> and <code>&#39;]&#39;</code>, determine if the input string is valid.</p>\r\n<p>The brackets must close in the correct order, <code>&quot;()&quot;</code> and <code>&quot;()[]{}&quot;</code> are all valid but <code>&quot;(]&quot;</code> and <code>&quot;([)]&quot;</code> are not.</p>\r\n<h2 id=\"h2-1-2-\"><a name=\"1.2 中文\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.2 中文</h2><p>给予一个包含<code>&#39;(&#39;</code>, <code>&#39;)&#39;</code>, <code>&#39;{&#39;</code>, <code>&#39;}&#39;</code>, <code>&#39;[&#39;</code> 和 <code>&#39;]&#39;</code>的字符串，检查该字符串是否有效；括弧必须正确地用另一边关闭，就像<code>&quot;()&quot;</code> and <code>&quot;()[]{}&quot;</code>，不能<code>&quot;(]&quot;</code>或者<code>&quot;([)]&quot;</code>。</p>\r\n<h1 id=\"h1-2-\"><a name=\"2. 解答\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2. 解答</h1><p>看到这道题，第一反应就是用栈来做，将匹配的左括弧压栈然后匹配。</p>\r\n<p>用简单的方式来实现。<br>接下来用go语言来实现，利用切片做一个类似栈的中间存储，匹配最后一个就可以。因为括弧就只有这三种，所以事先利用字典定义好括弧的集合用于匹配。</p>\r\n<pre><code class=\"lang-go\">var OpenP map[byte]byte = map[byte]byte{&#39;(&#39;:&#39;)&#39; , &#39;[&#39;:&#39;]&#39;, &#39;{&#39;:&#39;}&#39;}\r\nvar CloseP map[byte]byte = map[byte]byte{&#39;)&#39;:&#39;(&#39; , &#39;]&#39;:&#39;[&#39;, &#39;}&#39;:&#39;{&#39;}\r\n\r\nfunc isValid(s string) bool {\r\n    buf := make([]byte, 0, len(s))\r\n\r\n    for i := 0; i &lt; len(s); i++ {\r\n        c := s[i]\r\n\r\n        // 如果是左半部分；存进切片中\r\n        if _, ok := OpenP[c]; ok{\r\n            buf = append(buf,c)\r\n            continue\r\n        }\r\n\r\n        // 如果不是左半部分，进行判断\r\n        openOne := CloseP[c] // c对应的前半部分\r\n        bufLen := len(buf)\r\n        // buf中没有，或者 最后一个buf[bufLen-1]和当前c对应的前半部分不匹配；\r\n        if len(buf) &lt;= 0 || buf[bufLen-1] != openOne{\r\n            return false\r\n        }\r\n\r\n        // 匹配到了，切割切片，将c和c对应的前半部分（最后一个）切掉\r\n        buf = buf[:bufLen-1]\r\n    }\r\n\r\n    // 最后buf不应该有东西\r\n    return len(buf)==0\r\n}\r\n</code></pre>\r\n', '', 0, 'publish', 1, 0, '/article/74.html', '', 0, 176, '2018-02-06 06:42:19', '2018-02-06 06:42:19', '2018-02-07 06:42:30', NULL);
INSERT INTO `pt_post` VALUES (75, 10, 'article', 'LeetCode刷题之5：Longest Substring Without Repeating Characters（3）', '# 1. 题目\r\n## 1.1 英文\r\nGiven a string, find the length of the longest substring without repeating characters.\r\n\r\n**Examples:**\r\n\r\nGiven `\"abcabcbb\"`, the answer is `\"abc\"`, which the length is 3.\r\n\r\nGiven `\"bbbbb\"`, the answer is `\"b\"`, with the length of 1.\r\n\r\nGiven `\"pwwkew\"`, the answer is `\"wke\"`, with the length of 3. Note that the answer must be a substring, `\"pwke\"` is a subsequence and not a substring.\r\n\r\n## 1.2 中文\r\n给予一个字符串，找出它的**最长**不含有重复字符的子串，返回长度。\r\n\r\n**例如**：\r\n字符串是`\"abcabcbb\"`，答案就是`\"abc\"`，长度是3。\r\n字符串是`\"bbbbb\"`，答案就是`\"b\"`，长度是1。\r\n字符串是`\"pwwkew\"`，答案就是`\"wke\"`，长度是3；注意必须是原字符串的子串，比如`\"pwke\"`符合规则但并不是子串。\r\n\r\n# 2. 解答\r\n以下是解法分析，使用Go语言来实现：\r\n\r\n按顺序遍历字符串的字符，定义一个 lastOccurred 记录字母上次出现的位置，定义一个 start 记录符合规则的字符串的起始位置。\r\n\r\n如果字母上次出现超过了 start ，说明重复出现了，不符合，start重新赋值\r\n```go\r\nfunc lengthOfLongestSubstring(s string) int {\r\n    lastOccurred := make(map[rune]int)\r\n    start := 0\r\n    maxLength := 0\r\n\r\n    for i, ch := range []rune(s) {\r\n        if lastI, ok := lastOccurred[ch]; ok && lastI >= start {\r\n            start = lastOccurred[ch] + 1\r\n        }\r\n\r\n        if i - start + 1 > maxLength {\r\n            maxLength = i - start + 1\r\n        }\r\n\r\n        lastOccurred[ch] = i\r\n    }\r\n\r\n    return maxLength\r\n}\r\n```', '<h1 id=\"h1-1-\"><a name=\"1. 题目\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1. 题目</h1><h2 id=\"h2-1-1-\"><a name=\"1.1 英文\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.1 英文</h2><p>Given a string, find the length of the longest substring without repeating characters.</p>\r\n<p><strong>Examples:</strong></p>\r\n<p>Given <code>&quot;abcabcbb&quot;</code>, the answer is <code>&quot;abc&quot;</code>, which the length is 3.</p>\r\n<p>Given <code>&quot;bbbbb&quot;</code>, the answer is <code>&quot;b&quot;</code>, with the length of 1.</p>\r\n<p>Given <code>&quot;pwwkew&quot;</code>, the answer is <code>&quot;wke&quot;</code>, with the length of 3. Note that the answer must be a substring, <code>&quot;pwke&quot;</code> is a subsequence and not a substring.</p>\r\n<h2 id=\"h2-1-2-\"><a name=\"1.2 中文\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.2 中文</h2><p>给予一个字符串，找出它的<strong>最长</strong>不含有重复字符的子串，返回长度。</p>\r\n<p><strong>例如</strong>：<br>字符串是<code>&quot;abcabcbb&quot;</code>，答案就是<code>&quot;abc&quot;</code>，长度是3。<br>字符串是<code>&quot;bbbbb&quot;</code>，答案就是<code>&quot;b&quot;</code>，长度是1。<br>字符串是<code>&quot;pwwkew&quot;</code>，答案就是<code>&quot;wke&quot;</code>，长度是3；注意必须是原字符串的子串，比如<code>&quot;pwke&quot;</code>符合规则但并不是子串。</p>\r\n<h1 id=\"h1-2-\"><a name=\"2. 解答\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2. 解答</h1><p>以下是解法分析，使用Go语言来实现：</p>\r\n<p>按顺序遍历字符串的字符，定义一个 lastOccurred 记录字母上次出现的位置，定义一个 start 记录符合规则的字符串的起始位置。</p>\r\n<p>如果字母上次出现超过了 start ，说明重复出现了，不符合，start重新赋值</p>\r\n<pre><code class=\"lang-go\">func lengthOfLongestSubstring(s string) int {\r\n    lastOccurred := make(map[rune]int)\r\n    start := 0\r\n    maxLength := 0\r\n\r\n    for i, ch := range []rune(s) {\r\n        if lastI, ok := lastOccurred[ch]; ok &amp;&amp; lastI &gt;= start {\r\n            start = lastOccurred[ch] + 1\r\n        }\r\n\r\n        if i - start + 1 &gt; maxLength {\r\n            maxLength = i - start + 1\r\n        }\r\n\r\n        lastOccurred[ch] = i\r\n    }\r\n\r\n    return maxLength\r\n}\r\n</code></pre>\r\n', '', 0, 'publish', 1, 0, '/article/75.html', '', 0, 225, '2018-02-07 06:42:19', '2018-02-07 06:42:19', '2018-02-07 07:16:08', NULL);
INSERT INTO `pt_post` VALUES (76, 10, 'article', 'Centos安装Docker环境', '# 1. 准备工作\r\n- 需要 CentOS7 及以上的版本\r\n- 新版本的 Docker 分为 Docker CE 和 Docker EE，Docker EE是收费的企业版，所以我们安装 CE 版；旧版本的 Docker 叫 `docker` 或者 `docker-engine`；如果安装了旧版本，需要先删除掉，通过命令：\r\n```\r\n$ sudo yum remove docker \\\r\n                  docker-common \\\r\n                  docker-selinux \\\r\n                  docker-engine\r\n```\r\n\r\n# 2. 安装 Docker CE\r\n## 2.1 安装必要的包\r\n```\r\n$ sudo yum install -y yum-utils \\\r\n  device-mapper-persistent-data \\\r\n  lvm2\r\n```\r\n\r\n## 2.2 设置版本库地址\r\n用来获取当前的稳定版本\r\n```\r\n$ sudo yum-config-manager \\\r\n    --add-repo \\\r\n    https://download.docker.com/linux/centos/docker-ce.repo\r\n```\r\n\r\n## 2.3 安装 Docker\r\n更新 yum 包索引：\r\n```\r\n$ sudo yum makecache fast\r\n```\r\n\r\n### 2.3.1 安装最新版\r\n一般情况我们就用这个，安装最新版 docker-ce：\r\n```\r\nsudo yum install docker-ce\r\n```\r\n\r\n### 2.3.2 安装特定的版本\r\n可以指定安装要安装的版本。\r\n\r\n通过以下命令查看版本列表：\r\n```\r\nyum list docker-ce --showduplicates | sort -r\r\n```\r\n然后选择要安装的版本进行安装。\r\n```\r\nsudo yum install <FULLY-QUALIFIED-PACKAGE-NAME>\r\n```\r\n`<FULLY-QUALIFIED-PACKAGE-NAME>` 为版本的完整包名。\r\n\r\n## 2.4 启动 Docker\r\n命令：\r\n```\r\n$ sudo systemctl start docker\r\n```\r\n\r\n## 2.5 测试是否成功\r\n查看版本：\r\n```\r\n$ docker version\r\n```\r\n输出：\r\n```\r\nClient:\r\n Version:	17.12.0-ce\r\n API version:	1.35\r\n Go version:	go1.9.2\r\n Git commit:	c97c6d6\r\n Built:	Wed Dec 27 20:10:14 2017\r\n OS/Arch:	linux/amd64\r\nCannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?\r\n```\r\n\r\n运行一个hello-world容器：\r\n```\r\n$ sudo docker run hello-world\r\n```\r\n输出：\r\n```\r\nUnable to find image \'hello-world:latest\' locally\r\nlatest: Pulling from library/hello-world\r\nca4f61b1923c: Pull complete \r\nDigest: sha256:66ef312bbac49c39a89aa9bcc3cb4f3c9e7de3788c944158df3ee0176d32b751\r\nStatus: Downloaded newer image for hello-world:latest\r\n\r\nHello from Docker!\r\nThis message shows that your installation appears to be working correctly.\r\n\r\nTo generate this message, Docker took the following steps:\r\n 1. The Docker client contacted the Docker daemon.\r\n 2. The Docker daemon pulled the \"hello-world\" image from the Docker Hub.\r\n    (amd64)\r\n 3. The Docker daemon created a new container from that image which runs the\r\n    executable that produces the output you are currently reading.\r\n 4. The Docker daemon streamed that output to the Docker client, which sent it\r\n    to your terminal.\r\n\r\nTo try something more ambitious, you can run an Ubuntu container with:\r\n $ docker run -it ubuntu bash\r\n\r\nShare images, automate workflows, and more with a free Docker ID:\r\n https://cloud.docker.com/\r\n\r\nFor more examples and ideas, visit:\r\n https://docs.docker.com/engine/userguide/\r\n```\r\n提示没有镜像，然后远程拉取镜像，最后输出“Hello from Docker!......”等内容，表示安装成功可以正常使用了。\r\n\r\n## 2.6 其它安装方式\r\n这是通过yum仓库安装的方式，其它方式参考 [Get Docker CE for CentOS](https://docs.docker.com/install/linux/docker-ce/centos/#upgrade-docker-ce \"Get Docker CE for CentOS\")，还可以通过安装包，通过脚本进行安装。\r\n\r\n## 2.7 如何卸载\r\n通过：\r\n```\r\n$ sudo yum remove docker-ce\r\n```\r\n卸载 Docker。\r\n\r\n卸载后容器，镜像，配置等文件不会自动删除，要手动删除：\r\n```\r\n$ sudo rm -rf /var/lib/docker\r\n```\r\n\r\n# 3. 安装 Docker-compose\r\nDocker-compose 是一个 Dockerfile 的管理工具。通过编写 docker-compose.yml 文件就可以几个简单的指令管理所有的 Dockerfile 文件。\r\n\r\n## 3.1 通过pip安装\r\n安装方法：\r\n```\r\n$ sudo yum install python-pip\r\n$ sudo pip install docker-compose\r\n```\r\n\r\n卸载方法：\r\n```\r\n$ sudo pip uninstall docker-compose\r\n```\r\n\r\n## 3.2 二进制安装\r\n通过curl下载docker-compose：\r\n```\r\n$ sudo curl -L https://github.com/docker/compose/releases/download/1.19.0/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose\r\n```\r\n其中1.19.0位版本，可以修改为要下载的版本。\r\n\r\n添加二进制可执行权限：\r\n```\r\n$ sudo chmod +x /usr/local/bin/docker-compose\r\n```\r\n\r\n这样就好了，查看一下版本：\r\n```\r\n$ docker-compose --version\r\ndocker-compose version 1.19.0, build 9e633ef\r\n```\r\n这样 docker-compose 就安装完成了。\r\n\r\n卸载方法：\r\n```\r\n$ sudo rm /usr/local/bin/docker-compose\r\n```', '<h1 id=\"h1-1-\"><a name=\"1. 准备工作\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1. 准备工作</h1><ul>\r\n<li>需要 CentOS7 及以上的版本</li><li>新版本的 Docker 分为 Docker CE 和 Docker EE，Docker EE是收费的企业版，所以我们安装 CE 版；旧版本的 Docker 叫 <code>docker</code> 或者 <code>docker-engine</code>；如果安装了旧版本，需要先删除掉，通过命令：<pre><code>$ sudo yum remove docker \\\r\n                docker-common \\\r\n                docker-selinux \\\r\n                docker-engine\r\n</code></pre></li></ul>\r\n<h1 id=\"h1-2-docker-ce\"><a name=\"2. 安装 Docker CE\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2. 安装 Docker CE</h1><h2 id=\"h2-2-1-\"><a name=\"2.1 安装必要的包\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.1 安装必要的包</h2><pre><code>$ sudo yum install -y yum-utils \\\r\n  device-mapper-persistent-data \\\r\n  lvm2\r\n</code></pre><h2 id=\"h2-2-2-\"><a name=\"2.2 设置版本库地址\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.2 设置版本库地址</h2><p>用来获取当前的稳定版本</p>\r\n<pre><code>$ sudo yum-config-manager \\\r\n    --add-repo \\\r\n    https://download.docker.com/linux/centos/docker-ce.repo\r\n</code></pre><h2 id=\"h2-2-3-docker\"><a name=\"2.3 安装 Docker\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.3 安装 Docker</h2><p>更新 yum 包索引：</p>\r\n<pre><code>$ sudo yum makecache fast\r\n</code></pre><h3 id=\"h3-2-3-1-\"><a name=\"2.3.1 安装最新版\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.3.1 安装最新版</h3><p>一般情况我们就用这个，安装最新版 docker-ce：</p>\r\n<pre><code>sudo yum install docker-ce\r\n</code></pre><h3 id=\"h3-2-3-2-\"><a name=\"2.3.2 安装特定的版本\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.3.2 安装特定的版本</h3><p>可以指定安装要安装的版本。</p>\r\n<p>通过以下命令查看版本列表：</p>\r\n<pre><code>yum list docker-ce --showduplicates | sort -r\r\n</code></pre><p>然后选择要安装的版本进行安装。</p>\r\n<pre><code>sudo yum install &lt;FULLY-QUALIFIED-PACKAGE-NAME&gt;\r\n</code></pre><p><code>&lt;FULLY-QUALIFIED-PACKAGE-NAME&gt;</code> 为版本的完整包名。</p>\r\n<h2 id=\"h2-2-4-docker\"><a name=\"2.4 启动 Docker\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.4 启动 Docker</h2><p>命令：</p>\r\n<pre><code>$ sudo systemctl start docker\r\n</code></pre><h2 id=\"h2-2-5-\"><a name=\"2.5 测试是否成功\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.5 测试是否成功</h2><p>查看版本：</p>\r\n<pre><code>$ docker version\r\n</code></pre><p>输出：</p>\r\n<pre><code>Client:\r\n Version:    17.12.0-ce\r\n API version:    1.35\r\n Go version:    go1.9.2\r\n Git commit:    c97c6d6\r\n Built:    Wed Dec 27 20:10:14 2017\r\n OS/Arch:    linux/amd64\r\nCannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?\r\n</code></pre><p>运行一个hello-world容器：</p>\r\n<pre><code>$ sudo docker run hello-world\r\n</code></pre><p>输出：</p>\r\n<pre><code>Unable to find image &#39;hello-world:latest&#39; locally\r\nlatest: Pulling from library/hello-world\r\nca4f61b1923c: Pull complete \r\nDigest: sha256:66ef312bbac49c39a89aa9bcc3cb4f3c9e7de3788c944158df3ee0176d32b751\r\nStatus: Downloaded newer image for hello-world:latest\r\n\r\nHello from Docker!\r\nThis message shows that your installation appears to be working correctly.\r\n\r\nTo generate this message, Docker took the following steps:\r\n 1. The Docker client contacted the Docker daemon.\r\n 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub.\r\n    (amd64)\r\n 3. The Docker daemon created a new container from that image which runs the\r\n    executable that produces the output you are currently reading.\r\n 4. The Docker daemon streamed that output to the Docker client, which sent it\r\n    to your terminal.\r\n\r\nTo try something more ambitious, you can run an Ubuntu container with:\r\n $ docker run -it ubuntu bash\r\n\r\nShare images, automate workflows, and more with a free Docker ID:\r\n https://cloud.docker.com/\r\n\r\nFor more examples and ideas, visit:\r\n https://docs.docker.com/engine/userguide/\r\n</code></pre><p>提示没有镜像，然后远程拉取镜像，最后输出“Hello from Docker!……”等内容，表示安装成功可以正常使用了。</p>\r\n<h2 id=\"h2-2-6-\"><a name=\"2.6 其它安装方式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.6 其它安装方式</h2><p>这是通过yum仓库安装的方式，其它方式参考 <a href=\"https://docs.docker.com/install/linux/docker-ce/centos/#upgrade-docker-ce\" title=\"Get Docker CE for CentOS\">Get Docker CE for CentOS</a>，还可以通过安装包，通过脚本进行安装。</p>\r\n<h2 id=\"h2-2-7-\"><a name=\"2.7 如何卸载\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.7 如何卸载</h2><p>通过：</p>\r\n<pre><code>$ sudo yum remove docker-ce\r\n</code></pre><p>卸载 Docker。</p>\r\n<p>卸载后容器，镜像，配置等文件不会自动删除，要手动删除：</p>\r\n<pre><code>$ sudo rm -rf /var/lib/docker\r\n</code></pre><h1 id=\"h1-3-docker-compose\"><a name=\"3. 安装 Docker-compose\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3. 安装 Docker-compose</h1><p>Docker-compose 是一个 Dockerfile 的管理工具。通过编写 docker-compose.yml 文件就可以几个简单的指令管理所有的 Dockerfile 文件。</p>\r\n<h2 id=\"h2-3-1-pip-\"><a name=\"3.1 通过pip安装\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.1 通过pip安装</h2><p>安装方法：</p>\r\n<pre><code>$ sudo yum install python-pip\r\n$ sudo pip install docker-compose\r\n</code></pre><p>卸载方法：</p>\r\n<pre><code>$ sudo pip uninstall docker-compose\r\n</code></pre><h2 id=\"h2-3-2-\"><a name=\"3.2 二进制安装\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.2 二进制安装</h2><p>通过curl下载docker-compose：</p>\r\n<pre><code>$ sudo curl -L https://github.com/docker/compose/releases/download/1.19.0/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose\r\n</code></pre><p>其中1.19.0位版本，可以修改为要下载的版本。</p>\r\n<p>添加二进制可执行权限：</p>\r\n<pre><code>$ sudo chmod +x /usr/local/bin/docker-compose\r\n</code></pre><p>这样就好了，查看一下版本：</p>\r\n<pre><code>$ docker-compose --version\r\ndocker-compose version 1.19.0, build 9e633ef\r\n</code></pre><p>这样 docker-compose 就安装完成了。</p>\r\n<p>卸载方法：</p>\r\n<pre><code>$ sudo rm /usr/local/bin/docker-compose\r\n</code></pre>', '', 0, 'publish', 1, 0, '/article/76.html', 'https://www.goozp.com/uploads/2018/02/install_docker_in_centos.png', 0, 284, '2018-02-08 04:00:07', '2018-02-08 04:00:07', '2018-02-10 19:14:31', NULL);
INSERT INTO `pt_post` VALUES (77, 10, 'article', '徒手用 Docker 构建自己的 PHP 开发环境', '# 1. 前言\r\n## 1.1 为什么要用 Docker ？\r\n是否有这样的场景，你搞了一个项目，在本地开发时需要搭建环境，放到线上时也需要搭建环境，到公司想暗戳戳玩一下要搭建环境，不搭还不行，因为你的环境依赖还挺多。这个时候如果有了Docker，只需要在机器上装个Docker，放上写好的Dickerfile，一行命令就自动完成这个事，方便又高效，岂不是很爽？\r\n\r\n## 1.2 准备\r\n接下来，本文介绍如何搭建一个PHP的开发环境，将用 [zPhal-dockerfiles](https://github.com/ZpGuo/zPhal-dockerfiles \"zPhal-dockerfiles\") 做为例子，这是我为我的博客系统准备的一套Dockerfile。\r\n\r\n现在不管是windows，mac还是linux，docker都可以很好支持，包括Windows系统，在win10系统下Docker for Windows 其实还是挺不错的，就是比较吃内存。\r\n\r\n通过Docker命令行，我们可以做很多事情，拉取镜像，运行容器，容器内执行命令等，但是现在，我们要用更加简单粗暴的方式，编写好dockerfiles文件，然后通过docker-compose管理好这些文件，简化操作流程。\r\n> 什么是Dockerfile？\r\nDockerfile是由一系列命令和参数构成的脚本，这些命令应用于拉取的基础镜像并最终创建一个新的镜像，通过Dockerfile我们可以创建一个你需要的镜像，里面是包含了你要安装的软件，相当于是提前定制好要安装的拓展，执行的命令等，然后一键执行，极大地简化操作流程。\r\n\r\n按照本文来搭建环境，你需要：\r\n- 首先了解一下Docker以及Docker的一些基本操作，还有docker-compose是什么。\r\n- 然后需要安装 Docker 和 docker-compose，我将使用 docker-compose 来管理我的 dockerfiles。\r\n\r\n注意，编写 dockerfile 是活的，不是死的，每个人写出来的 dockerfile 都会不一样，取决于你的需求。\r\n\r\nDocker的官方文档非常清楚，虽然是英文，但是基本上什么都有，有问题上文档翻是非常明智的：[Docker Documentation](https://docs.docker.com/ \"Docker Documentation\")\r\n\r\n# 2. 开始编写\r\n接下来都是以 [zPhal-dockerfiles](https://github.com/ZpGuo/zPhal-dockerfiles \"zPhal-dockerfiles\") 为例子，完整的可以点链接进去看，下面的只是片段。\r\n\r\n## 2.1 预览\r\n首先，我们来看一下，我创建的这个dockerfile项目，我大概分成了下面的目录（当然这个是自己定的，并不是要求这么去排版你的文件）：\r\n```\r\nzPhal-dockerfiles\r\n	app/\r\n		index.php\r\n		phpinfo.php\r\n	data/\r\n		.gitignore\r\n	files/\r\n		mysql/\r\n			conf.d/\r\n				mysql-file.cnf\r\n			Dockerfile\r\n		nginx/\r\n			conf.d/\r\n				default.conf\r\n				zphal.conf\r\n			Dockerfile\r\n			nginx.conf\r\n		php/\r\n			pkg/\r\n				.gitignore\r\n			Dockerfile\r\n			php.ini\r\n			php-dev.ini\r\n			php-fpm.conf\r\n		redis/\r\n			Dockerfile\r\n		docker-compose.yml\r\n	logs/\r\n	.gitgnore\r\n	README.md\r\n```\r\n在这个项目里，我用到PHP，MySQL，Nginx，Redis；以及Composer，Phalcon拓展等。\r\n\r\n总的来说，我们做这件事有三个流程：编写好各个软件的dockerfile；编写好配置文件；通过docker-compose处理所有的dockerfile，包括将配置配置文件扔进去 dockerfile 文件将构建的镜像中。\r\n\r\n## 2.2 编写 Dockerfile 文件\r\n### 2.2.1 PHP\r\n下面是PHP的Dockerfile：\r\n```\r\nFROM php:7.2-fpm\r\nMAINTAINER goozp \"gzp@goozp.com\"\r\n\r\n# 设置时区\r\nENV TZ=Asia/Shanghai\r\nRUN ln -snf /usr/share/zoneinfo/$TZ /etc/localtime && echo $TZ > /etc/timezone\r\n\r\n# 更新安装依赖包和PHP核心拓展\r\nRUN apt-get update && apt-get install -y \\\r\n        git \\\r\n        libfreetype6-dev \\\r\n        libjpeg62-turbo-dev \\\r\n        libpng-dev \\\r\n	&& docker-php-ext-configure gd --with-freetype-dir=/usr/include/ --with-jpeg-dir=/usr/include/ \\\r\n	&& docker-php-ext-install -j$(nproc) gd \\\r\n        && docker-php-ext-install zip \\\r\n        && docker-php-ext-install pdo_mysql \\\r\n        && docker-php-ext-install opcache \\\r\n        && docker-php-ext-install mysqli \\\r\n        && rm -r /var/lib/apt/lists/*\r\n\r\n# 将预先下载好的拓展包从宿主机拷贝进去\r\nCOPY ./pkg/redis.tgz /home/redis.tgz\r\nCOPY ./pkg/cphalcon.tar.gz /home/cphalcon.tar.gz\r\n\r\n# 安装 PECL 拓展，这里我们安装的是Redis\r\nRUN pecl install /home/redis.tgz && echo \"extension=redis.so\" > /usr/local/etc/php/conf.d/redis.ini\r\n\r\n# 安装第三方拓展，这里是 Phalcon 拓展\r\nRUN cd /home \\\r\n    && tar -zxvf cphalcon.tar.gz \\\r\n    && mv cphalcon-* phalcon \\\r\n    && cd phalcon/build \\\r\n    && ./install \\\r\n    && echo \"extension=phalcon.so\" > /usr/local/etc/php/conf.d/phalcon.ini\r\n\r\n# 安装 Composer\r\nENV COMPOSER_HOME /root/composer\r\nRUN curl -sS https://getcomposer.org/installer | php -- --install-dir=/usr/local/bin --filename=composer\r\nENV PATH $COMPOSER_HOME/vendor/bin:$PATH\r\n\r\nRUN rm -f /home/redis.tgz \\\r\n        rm -f /home/cphalcon.tar.gz \r\n\r\nWORKDIR /data\r\n\r\n# Write Permission\r\nRUN usermod -u 1000 www-data\r\n```\r\n第一行定义了基础镜像，这里我们用了PHP7.2的fpm版本，这里第二行定义了一个维护者。\r\n\r\n接下来定义了时区，在每一个dockerfile都定义了这一句，主要是为了使所有的容器的时间都与宿主机同步，其实我们可以在docker-composer.yml文件中这么定义：\r\n```\r\nservices:\r\n  php-fpm:\r\n    volumes:\r\n      - /etc/localtime:/etc/localtime:ro\r\n```\r\n但是在非linux系统，比如Windows中运行时，我们不能取到/etc/localtime，为了更大兼容所有平台，我把时间同步写到dockerfile中。\r\n\r\n接下来安装一些拓展，其实安装拓展的过程类似于我们徒手在linux中安装PHP拓展，值得一提的是composer。我将Composer直接安装在了php-fpm的镜像中，其实官方也提供了Composer的镜像，拉取composer镜像执行也可以达到目的，因为我们使用composer只是为了执行composer命令来管理我们的包，如果composer单独是一个容器的话，我们在不用时，还可以将容器关掉；但是在这里，我直接将composer装进php-fpm镜像中，主要是我的项目安装了一些PHP拓展，在编写composer.json文件时，我定义了extension的依赖，这样composer执行时会检查环境是否安装了这些依赖，所有如果我直接用composer镜像的话，还需要把我用的拓展安装到镜像里，就麻烦多了，所以我直接在php镜像中就把这个事做了，其实没什么区别，取决于你怎么用。\r\n\r\n### 2.2.2 Nginx\r\n下面是 Nginx 的 dockerfile：\r\n```\r\nFROM nginx:1.12\r\n\r\n# set timezome\r\nENV TZ=Asia/Shanghai\r\nRUN ln -snf /usr/share/zoneinfo/$TZ /etc/localtime && echo $TZ > /etc/timezone\r\n```\r\n这个就简单多了，我只设置了一个时间。因为我不需要安装其它的东西，可以直接使用官方的镜像。\r\n\r\n当然，我们需要修改配置文件，只要事先写好配置文件就行，最后在 docker-compose.yml 文件中，将配置文件扔进去，这个下面会讲，包括PHP的配置文件，MySQL的配置文件，都是一样的。\r\n\r\n### 2.2.3 MySQL\r\n下面是 MySQL 的 dockerfile：\r\n```\r\nFROM mysql:5.7\r\n\r\n# set timezome\r\nENV TZ=Asia/Shanghai\r\nRUN ln -snf /usr/share/zoneinfo/$TZ /etc/localtime && echo $TZ > /etc/timezone\r\n```\r\nMySQL也没有什么特别之处，直接使用官方的镜像。\r\n\r\n### 2.2.4 Redis\r\n下面是 Redis 的，也直接使用官方镜像：\r\n```\r\nFROM redis:3.2\r\n\r\n# set timezome\r\nENV TZ=Asia/Shanghai\r\nRUN ln -snf /usr/share/zoneinfo/$TZ /etc/localtime && echo $TZ > /etc/timezone\r\n```\r\n\r\n## 2.3 编写配置文件\r\n如何处理配置文件呢，我将配置文件进行归类，PHP的配置文件放在PHP目录下，Nginx的配置放在Nginx目录下，至于要不要再新建一个子文件夹就看情况了，比如conf.d文件夹。\r\n\r\n下面以Nginx配置文件为例，首先nginx目录是这样的：\r\n```\r\nnginx/\r\n	conf.d/\r\n		default.conf\r\n		zphal.conf\r\n	Dockerfile\r\n	nginx.conf\r\n```\r\n除了nginx.conf外，还有一个子文件夹conf.d用来存放所有的域名配置文件，在linux下搭建过php环境的应该都比较熟悉。这些配置文件就是我们到时候要传进去容器中的文件，我们并不会在宿主机使用这些文件。\r\n\r\n所以需要注意的最重要一点就是，**配置文件中出现的路径是容器内环境的路径，而不是宿主机的路径**，每一个容器内都有一个运行环境，都是一台微型小系统，这些路径都是容器内的路径。我们可以通过**挂载**与容器内通讯来同步文件，在命令行启动容器也需要挂载文件路径，而现在挂载这一步我们也用docker-compose来解决。\r\n\r\n下面是一个配置文件示例：\r\n```\r\nserver {\r\n    listen   80 default;\r\n    index index.html index.htm;\r\n    server_name localhost docker;\r\n\r\n    root /data/www;\r\n    index index.php index.html index.htm;\r\n    location / {\r\n        try_files $uri $uri/ /index.html;\r\n    }\r\n\r\n    location ~ \\.php {\r\n        include fastcgi_params;\r\n        fastcgi_pass   php-fpm:9000;\r\n        fastcgi_index  index.php;\r\n        fastcgi_param  SCRIPT_FILENAME  /data/www/$fastcgi_script_name;\r\n    }\r\n}\r\n```\r\n而`root /data/www`中，`/data/www`路径，是到时候nginx容器的路径，而不是当前在操作的宿主机的路径，所以到时候我们要挂载web程序放的位置到这个路径。\r\n\r\n## 2.4 编写 docker-compose.yml\r\n在php，nginx等目录的同级，我们创建一个 docker-compose.yml，我们在执行 docker-compose 相关命令时，会自动找到这个文件，并根据里面的内容来执行。\r\n\r\n接上面 nginx 的例子，我们先谈挂载，因为这是最重要的一步。在 docker-compose.yml 中，nginx 的部分：\r\n```\r\nnginx:\r\n    build: ./nginx\r\n    depends_on:\r\n      - php-fpm\r\n    links:\r\n      - php-fpm:php-fpm\r\n    volumes:\r\n      - ../app:/data/www:rw\r\n      - ./nginx/conf.d:/etc/nginx/conf.d:ro\r\n      - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro\r\n      - ../logs/nginx:/var/log/nginx\r\n    ports:\r\n      - \"80:80\"\r\n      - \"8080:8080\"\r\n      - \"443:443\"\r\n    restart: always\r\n    command: nginx -g \'daemon off;\'\r\n```\r\n有一个 volumes 参数，这里就是我们要挂载的目录的相关配置，第一条我们将`../app`挂载到`/data/www`之中，也是我们配置文件中定义的默认监听的root，而app目录是我们宿主机中的一个目录，通过这样挂载我们可以直接将我们的项目文件放到app中，docker会帮你传输到容器内的`/data/www`目录下。\r\n\r\n其它的参数：\r\n- build 定义了你的 dockerfile 在哪里，如果没有写 dockerfile 可以不用 build，可以用 images参数定义官方镜像，比如`image:mysql:5.7`；\r\n- depends_on表示将依赖其它镜像，比如nginx依赖php-fpm，没有它我nginx没法玩；\r\n- links定义连接，比如要连接到php-fpm容器，就是`php-fpm:php-fpm`，后面是别名；\r\n- ports表示端口映射，`80:80`表示将80端口映射到宿主机的80端口\r\n- restart重启，`restart: always`表示将自动重启\r\n- command是自动执行的命令\r\n- ......\r\n\r\n参数很多，更多的可以参考官方文档。\r\n\r\n下面是一个完整的 docker-compose.yml 文件：\r\n```\r\nversion: \'3.2\'\r\nservices:\r\n  php-fpm:\r\n    build: ./php/\r\n    ports:\r\n      - \"9000:9000\"\r\n    links:\r\n      - mysql-db:mysql-db\r\n      - redis-db:redis-db\r\n    volumes:\r\n      - ../app:/data/www:rw\r\n      - ./php/php-dev.ini:/usr/local/etc/php/php.ini:ro\r\n      - ./php/php-fpm.conf:/usr/local/etc/php-fpm.conf:ro\r\n      - ../logs/php-fpm:/var/log/php-fpm:rw\r\n    restart: always\r\n    command: php-fpm\r\n\r\n  nginx:\r\n    build: ./nginx\r\n    depends_on:\r\n      - php-fpm\r\n    links:\r\n      - php-fpm:php-fpm\r\n    volumes:\r\n      - ../app:/data/www:rw\r\n      - ./nginx/conf.d:/etc/nginx/conf.d:ro\r\n      - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro\r\n      - ../logs/nginx:/var/log/nginx\r\n    ports:\r\n      - \"80:80\"\r\n      - \"8080:8080\"\r\n      - \"443:443\"\r\n    restart: always\r\n    command: nginx -g \'daemon off;\'\r\n\r\n  mysql-db:\r\n      build: ./mysql\r\n      ports:\r\n        - \"3306:3306\"\r\n      volumes:\r\n        - ../data/mysql:/var/lib/mysql:rw\r\n        - ../logs/mysql:/var/lib/mysql-logs:rw\r\n        - ./mysql/conf.d:/etc/mysql/conf.d:ro\r\n      environment:\r\n        MYSQL_ROOT_PASSWORD: 123456\r\n        MYSQL_DATABASE: zphaldb\r\n        MYSQL_USER: zphal\r\n        MYSQL_PASSWORD: zphal123\r\n      restart: always\r\n      command: \"--character-set-server=utf8\"\r\n\r\n  redis-db:\r\n      build: ./redis\r\n      ports:\r\n        - \"6379:6379\"\r\n      volumes:\r\n        - ../data/redis:/data\r\n      restart: always\r\n```\r\n\r\n# 3. 使用\r\n这一套编写下来，我们怎么用呢？\r\n\r\n## 3.1 使用搭建好的环境\r\n1. 首先，进入项目dockerfiles的目录下，这里是files目录：\r\n	```\r\n	cd zPhal-dockerfiles/files\r\n\r\n	wget https://pecl.php.net/get/redis-3.1.6.tgz -O php/pkg/redis.tgz\r\n	wget https://codeload.github.com/phalcon/cphalcon/tar.gz/v3.3.1 -O php/pkg/cphalcon.tar.gz\r\n	```\r\n	然后下载我们会用到的PHP拓展包。\r\n\r\n2. 执行命令：\r\n	```\r\n	docker-compose up\r\n	```\r\n	docker会自动通过编写好的docker-compose.yml内容构建镜像，并且启动容器。\r\n	如果没问题，下次启动时可以以守护模式启用，所有容器将后台运行：\r\n	```\r\n	docker-compose up -d\r\n	```\r\n\r\n3. 关闭容器\r\n	可以这样关闭容器并删除服务：\r\n	```\r\n	docker-compose down\r\n	```\r\n\r\n使用 docker-compose 基本上就这么简单，用 stop，start 等这些命令来操纵容器服务。而更多的工作是在于编写 dockerfile 和 docker-compose.yml 文件。\r\n\r\n## 3.2 使用 Composer\r\n当我们要使用composer时怎么做呢？ 我们已经在php-fpm里安装了composer。\r\n\r\n用 docker-compose 进行操作：\r\n```\r\ndocker-compose run --rm -w /data/www/zPhal php-fpm composer update\r\n```\r\n`-w /data/www/zPhal`为在php-fpm的工作区域，zPhal项目也是挂载在里面，所有我们可以直接在容器里运行composer。\r\n\r\n或者进入宿主机app目录下用docker命令：\r\n```\r\ncd zPhal-dockerfiles/app\r\n\r\ndocker run -it --rm -v `pwd`:/data/www/ -w /data/www/zPhal files_php-fpm composer update\r\n```\r\n\r\n# 4. 注意事项\r\n- 注意挂载路径\r\n- 构建失败时，注意容器内是否报错\r\n- 加速镜像。如果过程下载镜像很慢，可以使用国内的加速镜像服务，比如阿里云，Daocloud。', '<h1 id=\"h1-1-\"><a name=\"1. 前言\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1. 前言</h1><h2 id=\"h2-1-1-docker-\"><a name=\"1.1 为什么要用 Docker ？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.1 为什么要用 Docker ？</h2><p>是否有这样的场景，你搞了一个项目，在本地开发时需要搭建环境，放到线上时也需要搭建环境，到公司想暗戳戳玩一下要搭建环境，不搭还不行，因为你的环境依赖还挺多。这个时候如果有了Docker，只需要在机器上装个Docker，放上写好的Dickerfile，一行命令就自动完成这个事，方便又高效，岂不是很爽？</p>\r\n<h2 id=\"h2-1-2-\"><a name=\"1.2 准备\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.2 准备</h2><p>接下来，本文介绍如何搭建一个PHP的开发环境，将用 <a href=\"https://github.com/ZpGuo/zPhal-dockerfiles\" title=\"zPhal-dockerfiles\">zPhal-dockerfiles</a> 做为例子，这是我为我的博客系统准备的一套Dockerfile。</p>\r\n<p>现在不管是windows，mac还是linux，docker都可以很好支持，包括Windows系统，在win10系统下Docker for Windows 其实还是挺不错的，就是比较吃内存。</p>\r\n<p>通过Docker命令行，我们可以做很多事情，拉取镜像，运行容器，容器内执行命令等，但是现在，我们要用更加简单粗暴的方式，编写好dockerfiles文件，然后通过docker-compose管理好这些文件，简化操作流程。</p>\r\n<blockquote>\r\n<p>什么是Dockerfile？<br>Dockerfile是由一系列命令和参数构成的脚本，这些命令应用于拉取的基础镜像并最终创建一个新的镜像，通过Dockerfile我们可以创建一个你需要的镜像，里面是包含了你要安装的软件，相当于是提前定制好要安装的拓展，执行的命令等，然后一键执行，极大地简化操作流程。</p>\r\n</blockquote>\r\n<p>按照本文来搭建环境，你需要：</p>\r\n<ul>\r\n<li>首先了解一下Docker以及Docker的一些基本操作，还有docker-compose是什么。</li><li>然后需要安装 Docker 和 docker-compose，我将使用 docker-compose 来管理我的 dockerfiles。</li></ul>\r\n<p>注意，编写 dockerfile 是活的，不是死的，每个人写出来的 dockerfile 都会不一样，取决于你的需求。</p>\r\n<p>Docker的官方文档非常清楚，虽然是英文，但是基本上什么都有，有问题上文档翻是非常明智的：<a href=\"https://docs.docker.com/\" title=\"Docker Documentation\">Docker Documentation</a></p>\r\n<h1 id=\"h1-2-\"><a name=\"2. 开始编写\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2. 开始编写</h1><p>接下来都是以 <a href=\"https://github.com/ZpGuo/zPhal-dockerfiles\" title=\"zPhal-dockerfiles\">zPhal-dockerfiles</a> 为例子，完整的可以点链接进去看，下面的只是片段。</p>\r\n<h2 id=\"h2-2-1-\"><a name=\"2.1 预览\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.1 预览</h2><p>首先，我们来看一下，我创建的这个dockerfile项目，我大概分成了下面的目录（当然这个是自己定的，并不是要求这么去排版你的文件）：</p>\r\n<pre><code>zPhal-dockerfiles\r\n    app/\r\n        index.php\r\n        phpinfo.php\r\n    data/\r\n        .gitignore\r\n    files/\r\n        mysql/\r\n            conf.d/\r\n                mysql-file.cnf\r\n            Dockerfile\r\n        nginx/\r\n            conf.d/\r\n                default.conf\r\n                zphal.conf\r\n            Dockerfile\r\n            nginx.conf\r\n        php/\r\n            pkg/\r\n                .gitignore\r\n            Dockerfile\r\n            php.ini\r\n            php-dev.ini\r\n            php-fpm.conf\r\n        redis/\r\n            Dockerfile\r\n        docker-compose.yml\r\n    logs/\r\n    .gitgnore\r\n    README.md\r\n</code></pre><p>在这个项目里，我用到PHP，MySQL，Nginx，Redis；以及Composer，Phalcon拓展等。</p>\r\n<p>总的来说，我们做这件事有三个流程：编写好各个软件的dockerfile；编写好配置文件；通过docker-compose处理所有的dockerfile，包括将配置配置文件扔进去 dockerfile 文件将构建的镜像中。</p>\r\n<h2 id=\"h2-2-2-dockerfile-\"><a name=\"2.2 编写 Dockerfile 文件\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.2 编写 Dockerfile 文件</h2><h3 id=\"h3-2-2-1-php\"><a name=\"2.2.1 PHP\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.2.1 PHP</h3><p>下面是PHP的Dockerfile：</p>\r\n<pre><code>FROM php:7.2-fpm\r\nMAINTAINER goozp &quot;gzp@goozp.com&quot;\r\n\r\n# 设置时区\r\nENV TZ=Asia/Shanghai\r\nRUN ln -snf /usr/share/zoneinfo/$TZ /etc/localtime &amp;&amp; echo $TZ &gt; /etc/timezone\r\n\r\n# 更新安装依赖包和PHP核心拓展\r\nRUN apt-get update &amp;&amp; apt-get install -y \\\r\n        git \\\r\n        libfreetype6-dev \\\r\n        libjpeg62-turbo-dev \\\r\n        libpng-dev \\\r\n    &amp;&amp; docker-php-ext-configure gd --with-freetype-dir=/usr/include/ --with-jpeg-dir=/usr/include/ \\\r\n    &amp;&amp; docker-php-ext-install -j$(nproc) gd \\\r\n        &amp;&amp; docker-php-ext-install zip \\\r\n        &amp;&amp; docker-php-ext-install pdo_mysql \\\r\n        &amp;&amp; docker-php-ext-install opcache \\\r\n        &amp;&amp; docker-php-ext-install mysqli \\\r\n        &amp;&amp; rm -r /var/lib/apt/lists/*\r\n\r\n# 将预先下载好的拓展包从宿主机拷贝进去\r\nCOPY ./pkg/redis.tgz /home/redis.tgz\r\nCOPY ./pkg/cphalcon.tar.gz /home/cphalcon.tar.gz\r\n\r\n# 安装 PECL 拓展，这里我们安装的是Redis\r\nRUN pecl install /home/redis.tgz &amp;&amp; echo &quot;extension=redis.so&quot; &gt; /usr/local/etc/php/conf.d/redis.ini\r\n\r\n# 安装第三方拓展，这里是 Phalcon 拓展\r\nRUN cd /home \\\r\n    &amp;&amp; tar -zxvf cphalcon.tar.gz \\\r\n    &amp;&amp; mv cphalcon-* phalcon \\\r\n    &amp;&amp; cd phalcon/build \\\r\n    &amp;&amp; ./install \\\r\n    &amp;&amp; echo &quot;extension=phalcon.so&quot; &gt; /usr/local/etc/php/conf.d/phalcon.ini\r\n\r\n# 安装 Composer\r\nENV COMPOSER_HOME /root/composer\r\nRUN curl -sS https://getcomposer.org/installer | php -- --install-dir=/usr/local/bin --filename=composer\r\nENV PATH $COMPOSER_HOME/vendor/bin:$PATH\r\n\r\nRUN rm -f /home/redis.tgz \\\r\n        rm -f /home/cphalcon.tar.gz \r\n\r\nWORKDIR /data\r\n\r\n# Write Permission\r\nRUN usermod -u 1000 www-data\r\n</code></pre><p>第一行定义了基础镜像，这里我们用了PHP7.2的fpm版本，这里第二行定义了一个维护者。</p>\r\n<p>接下来定义了时区，在每一个dockerfile都定义了这一句，主要是为了使所有的容器的时间都与宿主机同步，其实我们可以在docker-composer.yml文件中这么定义：</p>\r\n<pre><code>services:\r\n  php-fpm:\r\n    volumes:\r\n      - /etc/localtime:/etc/localtime:ro\r\n</code></pre><p>但是在非linux系统，比如Windows中运行时，我们不能取到/etc/localtime，为了更大兼容所有平台，我把时间同步写到dockerfile中。</p>\r\n<p>接下来安装一些拓展，其实安装拓展的过程类似于我们徒手在linux中安装PHP拓展，值得一提的是composer。我将Composer直接安装在了php-fpm的镜像中，其实官方也提供了Composer的镜像，拉取composer镜像执行也可以达到目的，因为我们使用composer只是为了执行composer命令来管理我们的包，如果composer单独是一个容器的话，我们在不用时，还可以将容器关掉；但是在这里，我直接将composer装进php-fpm镜像中，主要是我的项目安装了一些PHP拓展，在编写composer.json文件时，我定义了extension的依赖，这样composer执行时会检查环境是否安装了这些依赖，所有如果我直接用composer镜像的话，还需要把我用的拓展安装到镜像里，就麻烦多了，所以我直接在php镜像中就把这个事做了，其实没什么区别，取决于你怎么用。</p>\r\n<h3 id=\"h3-2-2-2-nginx\"><a name=\"2.2.2 Nginx\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.2.2 Nginx</h3><p>下面是 Nginx 的 dockerfile：</p>\r\n<pre><code>FROM nginx:1.12\r\n\r\n# set timezome\r\nENV TZ=Asia/Shanghai\r\nRUN ln -snf /usr/share/zoneinfo/$TZ /etc/localtime &amp;&amp; echo $TZ &gt; /etc/timezone\r\n</code></pre><p>这个就简单多了，我只设置了一个时间。因为我不需要安装其它的东西，可以直接使用官方的镜像。</p>\r\n<p>当然，我们需要修改配置文件，只要事先写好配置文件就行，最后在 docker-compose.yml 文件中，将配置文件扔进去，这个下面会讲，包括PHP的配置文件，MySQL的配置文件，都是一样的。</p>\r\n<h3 id=\"h3-2-2-3-mysql\"><a name=\"2.2.3 MySQL\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.2.3 MySQL</h3><p>下面是 MySQL 的 dockerfile：</p>\r\n<pre><code>FROM mysql:5.7\r\n\r\n# set timezome\r\nENV TZ=Asia/Shanghai\r\nRUN ln -snf /usr/share/zoneinfo/$TZ /etc/localtime &amp;&amp; echo $TZ &gt; /etc/timezone\r\n</code></pre><p>MySQL也没有什么特别之处，直接使用官方的镜像。</p>\r\n<h3 id=\"h3-2-2-4-redis\"><a name=\"2.2.4 Redis\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.2.4 Redis</h3><p>下面是 Redis 的，也直接使用官方镜像：</p>\r\n<pre><code>FROM redis:3.2\r\n\r\n# set timezome\r\nENV TZ=Asia/Shanghai\r\nRUN ln -snf /usr/share/zoneinfo/$TZ /etc/localtime &amp;&amp; echo $TZ &gt; /etc/timezone\r\n</code></pre><h2 id=\"h2-2-3-\"><a name=\"2.3 编写配置文件\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.3 编写配置文件</h2><p>如何处理配置文件呢，我将配置文件进行归类，PHP的配置文件放在PHP目录下，Nginx的配置放在Nginx目录下，至于要不要再新建一个子文件夹就看情况了，比如conf.d文件夹。</p>\r\n<p>下面以Nginx配置文件为例，首先nginx目录是这样的：</p>\r\n<pre><code>nginx/\r\n    conf.d/\r\n        default.conf\r\n        zphal.conf\r\n    Dockerfile\r\n    nginx.conf\r\n</code></pre><p>除了nginx.conf外，还有一个子文件夹conf.d用来存放所有的域名配置文件，在linux下搭建过php环境的应该都比较熟悉。这些配置文件就是我们到时候要传进去容器中的文件，我们并不会在宿主机使用这些文件。</p>\r\n<p>所以需要注意的最重要一点就是，<strong>配置文件中出现的路径是容器内环境的路径，而不是宿主机的路径</strong>，每一个容器内都有一个运行环境，都是一台微型小系统，这些路径都是容器内的路径。我们可以通过<strong>挂载</strong>与容器内通讯来同步文件，在命令行启动容器也需要挂载文件路径，而现在挂载这一步我们也用docker-compose来解决。</p>\r\n<p>下面是一个配置文件示例：</p>\r\n<pre><code>server {\r\n    listen   80 default;\r\n    index index.html index.htm;\r\n    server_name localhost docker;\r\n\r\n    root /data/www;\r\n    index index.php index.html index.htm;\r\n    location / {\r\n        try_files $uri $uri/ /index.html;\r\n    }\r\n\r\n    location ~ \\.php {\r\n        include fastcgi_params;\r\n        fastcgi_pass   php-fpm:9000;\r\n        fastcgi_index  index.php;\r\n        fastcgi_param  SCRIPT_FILENAME  /data/www/$fastcgi_script_name;\r\n    }\r\n}\r\n</code></pre><p>而<code>root /data/www</code>中，<code>/data/www</code>路径，是到时候nginx容器的路径，而不是当前在操作的宿主机的路径，所以到时候我们要挂载web程序放的位置到这个路径。</p>\r\n<h2 id=\"h2-2-4-docker-compose-yml\"><a name=\"2.4 编写 docker-compose.yml\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.4 编写 docker-compose.yml</h2><p>在php，nginx等目录的同级，我们创建一个 docker-compose.yml，我们在执行 docker-compose 相关命令时，会自动找到这个文件，并根据里面的内容来执行。</p>\r\n<p>接上面 nginx 的例子，我们先谈挂载，因为这是最重要的一步。在 docker-compose.yml 中，nginx 的部分：</p>\r\n<pre><code>nginx:\r\n    build: ./nginx\r\n    depends_on:\r\n      - php-fpm\r\n    links:\r\n      - php-fpm:php-fpm\r\n    volumes:\r\n      - ../app:/data/www:rw\r\n      - ./nginx/conf.d:/etc/nginx/conf.d:ro\r\n      - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro\r\n      - ../logs/nginx:/var/log/nginx\r\n    ports:\r\n      - &quot;80:80&quot;\r\n      - &quot;8080:8080&quot;\r\n      - &quot;443:443&quot;\r\n    restart: always\r\n    command: nginx -g &#39;daemon off;&#39;\r\n</code></pre><p>有一个 volumes 参数，这里就是我们要挂载的目录的相关配置，第一条我们将<code>../app</code>挂载到<code>/data/www</code>之中，也是我们配置文件中定义的默认监听的root，而app目录是我们宿主机中的一个目录，通过这样挂载我们可以直接将我们的项目文件放到app中，docker会帮你传输到容器内的<code>/data/www</code>目录下。</p>\r\n<p>其它的参数：</p>\r\n<ul>\r\n<li>build 定义了你的 dockerfile 在哪里，如果没有写 dockerfile 可以不用 build，可以用 images参数定义官方镜像，比如<code>image:mysql:5.7</code>；</li><li>depends_on表示将依赖其它镜像，比如nginx依赖php-fpm，没有它我nginx没法玩；</li><li>links定义连接，比如要连接到php-fpm容器，就是<code>php-fpm:php-fpm</code>，后面是别名；</li><li>ports表示端口映射，<code>80:80</code>表示将80端口映射到宿主机的80端口</li><li>restart重启，<code>restart: always</code>表示将自动重启</li><li>command是自动执行的命令</li><li>……</li></ul>\r\n<p>参数很多，更多的可以参考官方文档。</p>\r\n<p>下面是一个完整的 docker-compose.yml 文件：</p>\r\n<pre><code>version: &#39;3.2&#39;\r\nservices:\r\n  php-fpm:\r\n    build: ./php/\r\n    ports:\r\n      - &quot;9000:9000&quot;\r\n    links:\r\n      - mysql-db:mysql-db\r\n      - redis-db:redis-db\r\n    volumes:\r\n      - ../app:/data/www:rw\r\n      - ./php/php-dev.ini:/usr/local/etc/php/php.ini:ro\r\n      - ./php/php-fpm.conf:/usr/local/etc/php-fpm.conf:ro\r\n      - ../logs/php-fpm:/var/log/php-fpm:rw\r\n    restart: always\r\n    command: php-fpm\r\n\r\n  nginx:\r\n    build: ./nginx\r\n    depends_on:\r\n      - php-fpm\r\n    links:\r\n      - php-fpm:php-fpm\r\n    volumes:\r\n      - ../app:/data/www:rw\r\n      - ./nginx/conf.d:/etc/nginx/conf.d:ro\r\n      - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro\r\n      - ../logs/nginx:/var/log/nginx\r\n    ports:\r\n      - &quot;80:80&quot;\r\n      - &quot;8080:8080&quot;\r\n      - &quot;443:443&quot;\r\n    restart: always\r\n    command: nginx -g &#39;daemon off;&#39;\r\n\r\n  mysql-db:\r\n      build: ./mysql\r\n      ports:\r\n        - &quot;3306:3306&quot;\r\n      volumes:\r\n        - ../data/mysql:/var/lib/mysql:rw\r\n        - ../logs/mysql:/var/lib/mysql-logs:rw\r\n        - ./mysql/conf.d:/etc/mysql/conf.d:ro\r\n      environment:\r\n        MYSQL_ROOT_PASSWORD: 123456\r\n        MYSQL_DATABASE: zphaldb\r\n        MYSQL_USER: zphal\r\n        MYSQL_PASSWORD: zphal123\r\n      restart: always\r\n      command: &quot;--character-set-server=utf8&quot;\r\n\r\n  redis-db:\r\n      build: ./redis\r\n      ports:\r\n        - &quot;6379:6379&quot;\r\n      volumes:\r\n        - ../data/redis:/data\r\n      restart: always\r\n</code></pre><h1 id=\"h1-3-\"><a name=\"3. 使用\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3. 使用</h1><p>这一套编写下来，我们怎么用呢？</p>\r\n<h2 id=\"h2-3-1-\"><a name=\"3.1 使用搭建好的环境\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.1 使用搭建好的环境</h2><ol>\r\n<li><p>首先，进入项目dockerfiles的目录下，这里是files目录：</p>\r\n<pre><code> cd zPhal-dockerfiles/files\r\n\r\n wget https://pecl.php.net/get/redis-3.1.6.tgz -O php/pkg/redis.tgz\r\n wget https://codeload.github.com/phalcon/cphalcon/tar.gz/v3.3.1 -O php/pkg/cphalcon.tar.gz\r\n</code></pre><p> 然后下载我们会用到的PHP拓展包。</p>\r\n</li><li><p>执行命令：</p>\r\n<pre><code> docker-compose up\r\n</code></pre><p> docker会自动通过编写好的docker-compose.yml内容构建镜像，并且启动容器。<br> 如果没问题，下次启动时可以以守护模式启用，所有容器将后台运行：</p>\r\n<pre><code> docker-compose up -d\r\n</code></pre></li><li><p>关闭容器<br> 可以这样关闭容器并删除服务：</p>\r\n<pre><code> docker-compose down\r\n</code></pre></li></ol>\r\n<p>使用 docker-compose 基本上就这么简单，用 stop，start 等这些命令来操纵容器服务。而更多的工作是在于编写 dockerfile 和 docker-compose.yml 文件。</p>\r\n<h2 id=\"h2-3-2-composer\"><a name=\"3.2 使用 Composer\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.2 使用 Composer</h2><p>当我们要使用composer时怎么做呢？ 我们已经在php-fpm里安装了composer。</p>\r\n<p>用 docker-compose 进行操作：</p>\r\n<pre><code>docker-compose run --rm -w /data/www/zPhal php-fpm composer update\r\n</code></pre><p><code>-w /data/www/zPhal</code>为在php-fpm的工作区域，zPhal项目也是挂载在里面，所有我们可以直接在容器里运行composer。</p>\r\n<p>或者进入宿主机app目录下用docker命令：</p>\r\n<pre><code>cd zPhal-dockerfiles/app\r\n\r\ndocker run -it --rm -v `pwd`:/data/www/ -w /data/www/zPhal files_php-fpm composer update\r\n</code></pre><h1 id=\"h1-4-\"><a name=\"4. 注意事项\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4. 注意事项</h1><ul>\r\n<li>注意挂载路径</li><li>构建失败时，注意容器内是否报错</li><li>加速镜像。如果过程下载镜像很慢，可以使用国内的加速镜像服务，比如阿里云，Daocloud。</li></ul>\r\n', '', 0, 'publish', 1, 0, '/article/77.html', 'https://www.goozp.com/uploads/2018/02/docker_dockerfile.jpg', 0, 993, '2018-02-10 19:14:21', '2018-02-10 19:14:21', '2018-02-10 19:27:13', NULL);
INSERT INTO `pt_post` VALUES (79, 10, 'article', '记录常用的 Docker 命令', '以下记录在使用 Docker 过程中遇到的常用命令，方便查询。\r\n\r\n# 镜像（Images）相关操作\r\n- **列出所有的镜像**\r\n`docker images`\r\n\r\n- **搜索镜像（从官方镜像和所有个人公共镜像）**\r\n`docker search <NAME>`\r\n\r\n- **拉取镜像**\r\n`docker pull [OPTIONS] <NAME[:TAG]>`\r\n\r\n- **将一个容器固化为一个新的镜像**\r\n`docker commit <container> [repo:tag]`\r\n\r\n- **删除镜像，通过镜像的id来指定删除谁**\r\n`docker rmi <image_id>`\r\n\r\n- **删除untagged images没有标签的镜像，也就是那些id为<None>的镜像**\r\n`docker rmi $(docker images | grep \"^<none>\" | awk \"{print $3}\")`\r\n\r\n- **删除全部镜像**\r\n`docker rmi $(docker images -q)`\r\n\r\n# 容器（container）相关操作\r\n- **查看容器**\r\n当前正在运行中容器： `docker ps`\r\n已经停止的所有容器： `docker ps -a`\r\n显示最新的一个容器（包括已停止的）：`docker ps -l`\r\n\r\n- **从镜像启动容器**\r\n`docker run [OPTIONS] <image> [COMMAND] [ARG...]`\r\n\r\n **OPTIONS说明**：\r\n - -d: 后台运行容器，并返回容器ID；\r\n - -i: 以交互模式运行容器，通常与 -t 同时使用；\r\n - -t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用；\r\n\r\n **例子**：\r\n 操作运行的redis容器：`docker run -it redis:3.2 redis-cli -h 172.17.0.1`\r\n\r\n- **开启/停止/重启 容器**\r\n`docker start <container_id>`\r\n`docker stop <container_id>`\r\n`docker restart <container_id>`\r\n\r\n- **连接到正在运行中的容器**\r\n`docker attach [OPTIONS] <container_id>`\r\n\r\n- **在运行的容器中执行命令**\r\n`docker exec [OPTIONS] <container> <command> [ARG...]`\r\n\r\n- **停止所有的容器，这样才能够删除相关的镜像**\r\n`docker stop $(docker ps -a -q)`\r\n\r\n- **删除指定容器**\r\n`docker rm <container_id>`\r\n\r\n- **删除所有退出的容器**\r\n`docker rm -f $(docker ps -a | grep Exit | awk \'{ print $1 }\')`\r\n\r\n- **删除所有容器**\r\n`docker rm $(docker ps -aq)`\r\n\r\n- **查看容器的相关信息**\r\n`docker inspect <container_id>`\r\n\r\n- **显示指定容器的IP**\r\n`docker inspect --format \'{{ .NetworkSettings.IPAddress }}\' <container_id>`\r\n\r\n- **查看容器中正在运行的进程**\r\n`docker top <container_id/container_name>`\r\n', '<p>以下记录在使用 Docker 过程中遇到的常用命令，方便查询。</p>\r\n<h1 id=\"h1--images-\"><a name=\"镜像（Images）相关操作\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>镜像（Images）相关操作</h1><ul>\r\n<li><p><strong>列出所有的镜像</strong><br><code>docker images</code></p>\r\n</li><li><p><strong>搜索镜像（从官方镜像和所有个人公共镜像）</strong><br><code>docker search &lt;NAME&gt;</code></p>\r\n</li><li><p><strong>拉取镜像</strong><br><code>docker pull [OPTIONS] &lt;NAME[:TAG]&gt;</code></p>\r\n</li><li><p><strong>将一个容器固化为一个新的镜像</strong><br><code>docker commit &lt;container&gt; [repo:tag]</code></p>\r\n</li><li><p><strong>删除镜像，通过镜像的id来指定删除谁</strong><br><code>docker rmi &lt;image_id&gt;</code></p>\r\n</li><li><p><strong>删除untagged images没有标签的镜像，也就是那些id为&lt;None&gt;的镜像</strong><br><code>docker rmi $(docker images | grep &quot;^&lt;none&gt;&quot; | awk &quot;{print $3}&quot;)</code></p>\r\n</li><li><p><strong>删除全部镜像</strong><br><code>docker rmi $(docker images -q)</code></p>\r\n</li></ul>\r\n<h1 id=\"h1--container-\"><a name=\"容器（container）相关操作\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>容器（container）相关操作</h1><ul>\r\n<li><p><strong>查看容器</strong><br>当前正在运行中容器： <code>docker ps</code><br>已经停止的所有容器： <code>docker ps -a</code><br>显示最新的一个容器（包括已停止的）：<code>docker ps -l</code></p>\r\n</li><li><p><strong>从镜像启动容器</strong><br><code>docker run [OPTIONS] &lt;image&gt; [COMMAND] [ARG...]</code></p>\r\n<p><strong>OPTIONS说明</strong>：</p>\r\n<ul>\r\n<li>-d: 后台运行容器，并返回容器ID；</li><li>-i: 以交互模式运行容器，通常与 -t 同时使用；</li><li>-t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用；</li></ul>\r\n<p><strong>例子</strong>：<br>操作运行的redis容器：<code>docker run -it redis:3.2 redis-cli -h 172.17.0.1</code></p>\r\n</li><li><p><strong>开启/停止/重启 容器</strong><br><code>docker start &lt;container_id&gt;</code><br><code>docker stop &lt;container_id&gt;</code><br><code>docker restart &lt;container_id&gt;</code></p>\r\n</li><li><p><strong>连接到正在运行中的容器</strong><br><code>docker attach [OPTIONS] &lt;container_id&gt;</code></p>\r\n</li><li><p><strong>在运行的容器中执行命令</strong><br><code>docker exec [OPTIONS] &lt;container&gt; &lt;command&gt; [ARG...]</code></p>\r\n</li><li><p><strong>停止所有的容器，这样才能够删除相关的镜像</strong><br><code>docker stop $(docker ps -a -q)</code></p>\r\n</li><li><p><strong>删除指定容器</strong><br><code>docker rm &lt;container_id&gt;</code></p>\r\n</li><li><p><strong>删除所有退出的容器</strong><br><code>docker rm -f $(docker ps -a | grep Exit | awk &#39;{ print $1 }&#39;)</code></p>\r\n</li><li><p><strong>删除所有容器</strong><br><code>docker rm $(docker ps -aq)</code></p>\r\n</li><li><p><strong>查看容器的相关信息</strong><br><code>docker inspect &lt;container_id&gt;</code></p>\r\n</li><li><p><strong>显示指定容器的IP</strong><br><code>docker inspect --format &#39;{{ .NetworkSettings.IPAddress }}&#39; &lt;container_id&gt;</code></p>\r\n</li><li><p><strong>查看容器中正在运行的进程</strong><br><code>docker top &lt;container_id/container_name&gt;</code></p>\r\n</li></ul>\r\n', '', 0, 'publish', 1, 0, '/article/79.html', 'https://www.goozp.com/uploads/2018/01/docker_logo_square.png', 0, 273, '2018-02-11 03:30:46', '2018-02-11 03:30:46', '2018-02-11 03:50:41', NULL);
INSERT INTO `pt_post` VALUES (80, 10, 'article', 'Swiper：移动端网站的内容触摸滑动 JavaScript 插件', '之前过节，想自己做点H5页面的时候，了解到了 Swiper 这款插件，发现非常好用，简单粗暴！通过Swiper这个插件，我们可以自己徒手快速撸出好看的H5页面。\r\n\r\n# 1. 什么是 Swiper\r\nSwiper 是纯 javascript 打造的滑动特效插件，常用于移动端网站的内容触摸滑动。Swiper 能实现触屏焦点图、触屏Tab切换、触屏多图切换等常用效果。\r\n\r\nGitHub：[nolimits4web/swiper](https://github.com/nolimits4web/swiper/ \"nolimits4web/swiper\")\r\n官网：[Swiper](http://idangero.us/swiper/ \"Swiper\")\r\nSwiper中文网：[Swiper中文网](http://www.swiper.com.cn/ \"Swiper中文网\")\r\n\r\n# 2. 效果演示\r\n具体的是个什么效果，来看一下。\r\n\r\n比如下面新闻页的一个滑动效果，Tab切换和触屏切换：\r\n![](https://www.goozp.com/uploads/2018/02/swiper3.gif)\r\n\r\n很多时候我们可以拿 Swiper 来做 H5 页面的滑动效果，比如（**这些示例都来自Swiper中文网！**）：\r\n![](https://www.goozp.com/uploads/2018/02/swiper1.gif)\r\n\r\n可以加上一些动画效果：\r\n![](https://www.goozp.com/uploads/2018/02/swiper2.gif)\r\n这种页面我们平时见得挺多的，效果还是很不错的。\r\n\r\n# 3. 使用\r\n## 3.1 下载\r\n下载就不说了\r\n\r\n## 3.2 使用\r\n引入swiper.min.css，和swiper.min.js文件。\r\n```html\r\n<!DOCTYPE html>\r\n<html>\r\n<head>\r\n    <!-- 引入swiper.min.css -->\r\n    <link rel=\"stylesheet\" href=\"path/to/swiper.min.css\">\r\n	<style>\r\n	.swiper-container {\r\n		width: 600px;\r\n		height: 300px;\r\n	}\r\n	</style>\r\n</head>\r\n<body>\r\n	<div class=\"swiper-container\">\r\n		<div class=\"swiper-wrapper\">\r\n			<div class=\"swiper-slide\">Slide 1</div>\r\n			<div class=\"swiper-slide\">Slide 2</div>\r\n			<div class=\"swiper-slide\">Slide 3</div>\r\n		</div>\r\n		<!-- 如果需要分页器 -->\r\n		<div class=\"swiper-pagination\"></div>\r\n\r\n		<!-- 如果需要导航按钮 -->\r\n		<div class=\"swiper-button-prev\"></div>\r\n		<div class=\"swiper-button-next\"></div>\r\n\r\n		<!-- 如果需要滚动条 -->\r\n		<div class=\"swiper-scrollbar\"></div>\r\n	</div>\r\n\r\n	<!-- 引入swiper.min.js -->\r\n    <script src=\"path/to/swiper.min.js\"></script>\r\n	<script>\r\n	var mySwiper = new Swiper (\'.swiper-container\', {\r\n		direction: \'vertical\',\r\n		loop: true,\r\n\r\n		// 如果需要分页器\r\n		pagination: {\r\n		  el: \'.swiper-pagination\',\r\n		},\r\n\r\n		// 如果需要前进后退按钮\r\n		navigation: {\r\n		  nextEl: \'.swiper-button-next\',\r\n		  prevEl: \'.swiper-button-prev\',\r\n		},\r\n\r\n		// 如果需要滚动条\r\n		scrollbar: {\r\n		  el: \'.swiper-scrollbar\',\r\n		},\r\n	})\r\n	</script>\r\n</body>\r\n</html>\r\n```\r\n先引入 swiper.min.js 和 swiper.min.css；创建一个`<div class=\"swiper-container\"></div>`，div内为内容和滚动条，分页器等内容；然后实例化 Swiper：`new Swiper(swiperContainer, parameters)`，wiperContainer 为 Swiper 容器的 css 选择器，“.swiper-container”，parameters为可选配置。\r\n\r\n这里为完整的Api文档：[http://www.swiper.com.cn/api/index.html](http://www.swiper.com.cn/api/index.html)\r\n', '<p>之前过节，想自己做点H5页面的时候，了解到了 Swiper 这款插件，发现非常好用，简单粗暴！通过Swiper这个插件，我们可以自己徒手快速撸出好看的H5页面。</p>\r\n<h1 id=\"h1-1-swiper\"><a name=\"1. 什么是 Swiper\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1. 什么是 Swiper</h1><p>Swiper 是纯 javascript 打造的滑动特效插件，常用于移动端网站的内容触摸滑动。Swiper 能实现触屏焦点图、触屏Tab切换、触屏多图切换等常用效果。</p>\r\n<p>GitHub：<a href=\"https://github.com/nolimits4web/swiper/\" title=\"nolimits4web/swiper\">nolimits4web/swiper</a><br>官网：<a href=\"http://idangero.us/swiper/\" title=\"Swiper\">Swiper</a><br>Swiper中文网：<a href=\"http://www.swiper.com.cn/\" title=\"Swiper中文网\">Swiper中文网</a></p>\r\n<h1 id=\"h1-2-\"><a name=\"2. 效果演示\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2. 效果演示</h1><p>具体的是个什么效果，来看一下。</p>\r\n<p>比如下面新闻页的一个滑动效果，Tab切换和触屏切换：<br><img src=\"https://www.goozp.com/uploads/2018/02/swiper3.gif\" alt=\"\"></p>\r\n<p>很多时候我们可以拿 Swiper 来做 H5 页面的滑动效果，比如（<strong>这些示例都来自Swiper中文网！</strong>）：<br><img src=\"https://www.goozp.com/uploads/2018/02/swiper1.gif\" alt=\"\"></p>\r\n<p>可以加上一些动画效果：<br><img src=\"https://www.goozp.com/uploads/2018/02/swiper2.gif\" alt=\"\"><br>这种页面我们平时见得挺多的，效果还是很不错的。</p>\r\n<h1 id=\"h1-3-\"><a name=\"3. 使用\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3. 使用</h1><h2 id=\"h2-3-1-\"><a name=\"3.1 下载\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.1 下载</h2><p>下载就不说了</p>\r\n<h2 id=\"h2-3-2-\"><a name=\"3.2 使用\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.2 使用</h2><p>引入swiper.min.css，和swiper.min.js文件。</p>\r\n<pre><code class=\"lang-html\">&lt;!DOCTYPE html&gt;\r\n&lt;html&gt;\r\n&lt;head&gt;\r\n    &lt;!-- 引入swiper.min.css --&gt;\r\n    &lt;link rel=&quot;stylesheet&quot; href=&quot;path/to/swiper.min.css&quot;&gt;\r\n    &lt;style&gt;\r\n    .swiper-container {\r\n        width: 600px;\r\n        height: 300px;\r\n    }\r\n    &lt;/style&gt;\r\n&lt;/head&gt;\r\n&lt;body&gt;\r\n    &lt;div class=&quot;swiper-container&quot;&gt;\r\n        &lt;div class=&quot;swiper-wrapper&quot;&gt;\r\n            &lt;div class=&quot;swiper-slide&quot;&gt;Slide 1&lt;/div&gt;\r\n            &lt;div class=&quot;swiper-slide&quot;&gt;Slide 2&lt;/div&gt;\r\n            &lt;div class=&quot;swiper-slide&quot;&gt;Slide 3&lt;/div&gt;\r\n        &lt;/div&gt;\r\n        &lt;!-- 如果需要分页器 --&gt;\r\n        &lt;div class=&quot;swiper-pagination&quot;&gt;&lt;/div&gt;\r\n\r\n        &lt;!-- 如果需要导航按钮 --&gt;\r\n        &lt;div class=&quot;swiper-button-prev&quot;&gt;&lt;/div&gt;\r\n        &lt;div class=&quot;swiper-button-next&quot;&gt;&lt;/div&gt;\r\n\r\n        &lt;!-- 如果需要滚动条 --&gt;\r\n        &lt;div class=&quot;swiper-scrollbar&quot;&gt;&lt;/div&gt;\r\n    &lt;/div&gt;\r\n\r\n    &lt;!-- 引入swiper.min.js --&gt;\r\n    &lt;script src=&quot;path/to/swiper.min.js&quot;&gt;&lt;/script&gt;\r\n    &lt;script&gt;\r\n    var mySwiper = new Swiper (&#39;.swiper-container&#39;, {\r\n        direction: &#39;vertical&#39;,\r\n        loop: true,\r\n\r\n        // 如果需要分页器\r\n        pagination: {\r\n          el: &#39;.swiper-pagination&#39;,\r\n        },\r\n\r\n        // 如果需要前进后退按钮\r\n        navigation: {\r\n          nextEl: &#39;.swiper-button-next&#39;,\r\n          prevEl: &#39;.swiper-button-prev&#39;,\r\n        },\r\n\r\n        // 如果需要滚动条\r\n        scrollbar: {\r\n          el: &#39;.swiper-scrollbar&#39;,\r\n        },\r\n    })\r\n    &lt;/script&gt;\r\n&lt;/body&gt;\r\n&lt;/html&gt;\r\n</code></pre>\r\n<p>先引入 swiper.min.js 和 swiper.min.css；创建一个<code>&lt;div class=&quot;swiper-container&quot;&gt;&lt;/div&gt;</code>，div内为内容和滚动条，分页器等内容；然后实例化 Swiper：<code>new Swiper(swiperContainer, parameters)</code>，wiperContainer 为 Swiper 容器的 css 选择器，“.swiper-container”，parameters为可选配置。</p>\r\n<p>这里为完整的Api文档：<a href=\"http://www.swiper.com.cn/api/index.html\">http://www.swiper.com.cn/api/index.html</a></p>\r\n', '', 0, 'publish', 1, 0, '/article/80.html', '', 0, 246, '2018-02-17 12:55:22', '2018-02-17 12:55:22', '2018-02-17 12:57:07', NULL);
INSERT INTO `pt_post` VALUES (81, 10, 'article', 'Phalcon 入门学习指南', '# 1. 什么是 Phalcon\r\n相比 Laravel，Yii，ThinkPHP，在国内 Phalcon 似乎并没有什么人用，甚至有很多人不知道这么一个PHP框架。Phalcon 是一个C拓展编写的全功能栈框架，支持MVC模式。性能是 Phalcon 的一个显著的特点。\r\n\r\n还有一个C拓展框架，是鸟哥的Yaf，Yaf和Phalcon的区别在于，Yaf是一个架子而且只有一个架子，而Phalcon是全功能的，要什么有什么。\r\n\r\n# 2. 为什么要学习 Phalcon\r\n那么一个高性能的C拓展框架为什么用的人这么少呢。我揣摩了一下，主要有以下一些因素：\r\n1. 很多时候，PHP的性能瓶颈并不在PHP本身，而在于数据库，在IO，在并发等；再加上PHP7性能的提升，以及未来JIT出来后的进一步跃进，都使 Phalcon 的高性能的特点被掩埋，所以一般的中小项目，Phalcon的优势并不明显，但是学习成本却高得多，不划算。\r\n2. Phalcon的生态圈不够丰富。玩Phalcon的都会知道，Phalcon国内基本没什么社区，资料少得可怜，只有google英文资料才能解决问题，神奇的是，遇到问题里基本上google一下，通过phalcon官方论坛，Stack Overflow等，基本上都能解决你的疑惑。\r\n3. 学习成本高。很多人都说学习成本高，其实我在开发过程中发现，虽然遇到的坑是有，但是并不是说不能解决，说到底还是学习环境不行，生态不行。Laravel的学习成本其实也不低（相对于TP之类的），但是现在也是风生水起，国内的几个社区确实做得非常不错，特别是Laravel China的维护者，不仅是促进Laravel的发展，也在普及一些新的PHP知识。与其说学习成本高，倒不如说是没有前人填坑，只要坑填好了，后面的人就好走了。\r\n4. 不是项目的优先选择。其实我觉得这个是最主要的原因，一个团队在选择开发框架的时候，会考虑很多，性能并不一定是优先选择，往往效率是很多人会优先考虑的。那么在这面前，选择Laravel这种框架，熟悉Laravel的开发者，可以利用Laravel生态，优雅而又高效地去完成任务，何必去装一个拓展然后慢慢踩坑呢（因为C拓展的框架看不到PHP源码不利于调试），再者，很多人会选择国内生态极好的TP框架速撸（真的很速，要多速有多速，目的是实现功能的话）。这样一来，用的人就少了，用的人少，流传不开，生态也自然就差了。\r\n\r\n在我用一波下来，我觉得 Phalcon 确实是比较优秀的一款框架。未来PHP的发展方向，在我看来铁定是要求高并发高可用，所以Swoole成为了一个大杀器，Phalcon+Swoole是我比较青睐的一个搭配，再加上现在Docker已经逐渐成熟，搭建环境不再是问题了。\r\n\r\n最后，学习多一门框架，并不是说为了用而学，多学一门框架我们就可以从这门框架中提炼出他的精髓，在选择时也多了一个选择。\r\n\r\n# 3. 学习 Phalcon 能给你带来什么\r\n其实我非常建议PHPer初期在用完ThinkPHP或者Yii之类的时候，来学一下Laravel或者Phalcon，当然我就是处于这个学习阶段，受益很大。\r\n\r\n自己动手从头做一个项目来学习 Phalcon，会有很大收获，有这些好处：\r\n- 真正理解MVC架构\r\n你会开始思考很多，model 究竟是什么（新手或者被荼毒的PHPer）；model层的应用与拆分；业务逻辑的拆分；前后台复用拆分；REST风格与传统控制器方法风格；大中小型不同项目的区别。因为这些东西都要你自己去设计，构造，即使你用Phalcon-devtools来生成项目。\r\n- 找到自己的方向\r\n从头开始做一个项目，如果你只有一个人，或者只是一个练手小项目；也许一开始想得很多，后端用什么技术啦，前端用什么先进的技术啦，什么vue啦react啦，前后端分离啦。当你开始时才发现，这样做一套下来，要学很多，而且前端更新太快了，顾不来。有时候精力有限，还有工作，并不能顾及这些骚操作，除非你真的想往全栈发展并投入大量精力。这个时候，你会发现，专注一个方向才是最主要的，比如专精后端（如果你选择了Phalcon，很大程度上你已经偏向后端了），学习算法，如何高并发，数据库瓶颈等等这些够你学的了；很多大公司面试，并不会考你前端如何，毕竟岗位是后端工程师，大公司里职责很分明，不会让你一条线通吃的。\r\n- 往底层发展\r\nPhalcon是C拓展的框架。学习到一定深度，就可以开始看看C，看看PHP拓展的开发了。\r\n\r\n# 4. 学习的好去处\r\n首先遇到问题，用google，而不是百度，百度一般找不到答案，而google一般可以，不然就用必应，但是最好google。\r\n1. 官方文档：[https://docs.phalconphp.com](https://docs.phalconphp.com \"https://docs.phalconphp.com\")\r\nPhalcon的官方文档是非常详细的，而且教学也很简单粗暴，入门就靠它。最近文档做了改版，体验很不错。\r\n2. 官方论坛：[https://forum.phalconphp.com/](https://forum.phalconphp.com/ \"https://forum.phalconphp.com/\")\r\nPhalcon的官方论坛能解决大部分问题，你碰到的问题，别人也碰到过。\r\n3. Stack Overflow：[https://stackoverflow.com/questions/tagged/phalcon](https://stackoverflow.com/questions/tagged/phalcon \"https://stackoverflow.com/questions/tagged/phalcon\")\r\n在Stack Overflow上查找问题，一般碰到的问题，官方论坛上没有Stack Overflow上会有，基本上这两个论坛就可以解决大部分问题，如果还不行，就自己提问试试吧。\r\n4. Phalcontip：[https://phalcontip.com/](https://phalcontip.com/ \"https://phalcontip.com/\")\r\n这个站点上面有很多很好的实践，也可以解决很多问题。\r\n\r\n\r\n# 5. 系列文章\r\n因为我自己用 Phalcon 用起来是非常爽的，我觉得把这些整理下来，一来填坑，二来自己以后也受用。\r\n\r\n我准备整理出以下的文章，以后有时间抽空写写：\r\n\r\n **初学系列**\r\n- [Phalcon框架架构初识](https://www.goozp.com/article/72.html \"Phalcon框架架构初识\")\r\n- ......\r\n\r\n**踩坑系列**\r\n- [Phalcon填坑手册：开发中会遇到的问题和解决方案（不断更新）](https://www.goozp.com/article/62.html \"Phalcon填坑手册：开发中会遇到的问题和解决方案（不断更新）\")\r\n- ......\r\n\r\n**最佳实践系列**\r\n- Phalcon最佳实践1：健壮的项目结构和代码\r\n- Phalcon最佳实践2：核心之model层的使用\r\n- Phalcon最佳实践3：model的批量操作\r\n- Phalcon最佳实践4：正确使用模型关联\r\n- Phalcon最佳实践5：数据库操作的几种方式和坑\r\n- Phalcon最佳实践6：ACL实现权限功能\r\n- Phalcon最佳实践7：分页及其拓展\r\n- Phalcon最佳实践8：过滤器的使用\r\n- Phalcon最佳实践9：使用缓存系统(前后端适配器)\r\n- Phalcon最佳实践10：数据库迁移\r\n- Phalcon最佳实践11：合理使用Notfound\r\n- Phalcon最佳实践12：构建composer支持的Phalcon项目\r\n- ......\r\n\r\n**拓展系列**\r\n- 权限相关：ACL与RBAC\r\n- 如何设计博客系统文章的草稿，保存，发布，自动草稿等功能\r\n- 什么是元数据，如何应用\r\n- 结合PHPunit做测试\r\n- 开发时预留插件功能\r\n- ......\r\n\r\n', '<h1 id=\"h1-1-phalcon\"><a name=\"1. 什么是 Phalcon\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1. 什么是 Phalcon</h1><p>相比 Laravel，Yii，ThinkPHP，在国内 Phalcon 似乎并没有什么人用，甚至有很多人不知道这么一个PHP框架。Phalcon 是一个C拓展编写的全功能栈框架，支持MVC模式。性能是 Phalcon 的一个显著的特点。</p>\r\n<p>还有一个C拓展框架，是鸟哥的Yaf，Yaf和Phalcon的区别在于，Yaf是一个架子而且只有一个架子，而Phalcon是全功能的，要什么有什么。</p>\r\n<h1 id=\"h1-2-phalcon\"><a name=\"2. 为什么要学习 Phalcon\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2. 为什么要学习 Phalcon</h1><p>那么一个高性能的C拓展框架为什么用的人这么少呢。我揣摩了一下，主要有以下一些因素：</p>\r\n<ol>\r\n<li>很多时候，PHP的性能瓶颈并不在PHP本身，而在于数据库，在IO，在并发等；再加上PHP7性能的提升，以及未来JIT出来后的进一步跃进，都使 Phalcon 的高性能的特点被掩埋，所以一般的中小项目，Phalcon的优势并不明显，但是学习成本却高得多，不划算。</li><li>Phalcon的生态圈不够丰富。玩Phalcon的都会知道，Phalcon国内基本没什么社区，资料少得可怜，只有google英文资料才能解决问题，神奇的是，遇到问题里基本上google一下，通过phalcon官方论坛，Stack Overflow等，基本上都能解决你的疑惑。</li><li>学习成本高。很多人都说学习成本高，其实我在开发过程中发现，虽然遇到的坑是有，但是并不是说不能解决，说到底还是学习环境不行，生态不行。Laravel的学习成本其实也不低（相对于TP之类的），但是现在也是风生水起，国内的几个社区确实做得非常不错，特别是Laravel China的维护者，不仅是促进Laravel的发展，也在普及一些新的PHP知识。与其说学习成本高，倒不如说是没有前人填坑，只要坑填好了，后面的人就好走了。</li><li>不是项目的优先选择。其实我觉得这个是最主要的原因，一个团队在选择开发框架的时候，会考虑很多，性能并不一定是优先选择，往往效率是很多人会优先考虑的。那么在这面前，选择Laravel这种框架，熟悉Laravel的开发者，可以利用Laravel生态，优雅而又高效地去完成任务，何必去装一个拓展然后慢慢踩坑呢（因为C拓展的框架看不到PHP源码不利于调试），再者，很多人会选择国内生态极好的TP框架速撸（真的很速，要多速有多速，目的是实现功能的话）。这样一来，用的人就少了，用的人少，流传不开，生态也自然就差了。</li></ol>\r\n<p>在我用一波下来，我觉得 Phalcon 确实是比较优秀的一款框架。未来PHP的发展方向，在我看来铁定是要求高并发高可用，所以Swoole成为了一个大杀器，Phalcon+Swoole是我比较青睐的一个搭配，再加上现在Docker已经逐渐成熟，搭建环境不再是问题了。</p>\r\n<p>最后，学习多一门框架，并不是说为了用而学，多学一门框架我们就可以从这门框架中提炼出他的精髓，在选择时也多了一个选择。</p>\r\n<h1 id=\"h1-3-phalcon-\"><a name=\"3. 学习 Phalcon 能给你带来什么\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3. 学习 Phalcon 能给你带来什么</h1><p>其实我非常建议PHPer初期在用完ThinkPHP或者Yii之类的时候，来学一下Laravel或者Phalcon，当然我就是处于这个学习阶段，受益很大。</p>\r\n<p>自己动手从头做一个项目来学习 Phalcon，会有很大收获，有这些好处：</p>\r\n<ul>\r\n<li>真正理解MVC架构<br>你会开始思考很多，model 究竟是什么（新手或者被荼毒的PHPer）；model层的应用与拆分；业务逻辑的拆分；前后台复用拆分；REST风格与传统控制器方法风格；大中小型不同项目的区别。因为这些东西都要你自己去设计，构造，即使你用Phalcon-devtools来生成项目。</li><li>找到自己的方向<br>从头开始做一个项目，如果你只有一个人，或者只是一个练手小项目；也许一开始想得很多，后端用什么技术啦，前端用什么先进的技术啦，什么vue啦react啦，前后端分离啦。当你开始时才发现，这样做一套下来，要学很多，而且前端更新太快了，顾不来。有时候精力有限，还有工作，并不能顾及这些骚操作，除非你真的想往全栈发展并投入大量精力。这个时候，你会发现，专注一个方向才是最主要的，比如专精后端（如果你选择了Phalcon，很大程度上你已经偏向后端了），学习算法，如何高并发，数据库瓶颈等等这些够你学的了；很多大公司面试，并不会考你前端如何，毕竟岗位是后端工程师，大公司里职责很分明，不会让你一条线通吃的。</li><li>往底层发展<br>Phalcon是C拓展的框架。学习到一定深度，就可以开始看看C，看看PHP拓展的开发了。</li></ul>\r\n<h1 id=\"h1-4-\"><a name=\"4. 学习的好去处\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4. 学习的好去处</h1><p>首先遇到问题，用google，而不是百度，百度一般找不到答案，而google一般可以，不然就用必应，但是最好google。</p>\r\n<ol>\r\n<li>官方文档：<a href=\"https://docs.phalconphp.com\" title=\"https://docs.phalconphp.com\">https://docs.phalconphp.com</a><br>Phalcon的官方文档是非常详细的，而且教学也很简单粗暴，入门就靠它。最近文档做了改版，体验很不错。</li><li>官方论坛：<a href=\"https://forum.phalconphp.com/\" title=\"https://forum.phalconphp.com/\">https://forum.phalconphp.com/</a><br>Phalcon的官方论坛能解决大部分问题，你碰到的问题，别人也碰到过。</li><li>Stack Overflow：<a href=\"https://stackoverflow.com/questions/tagged/phalcon\" title=\"https://stackoverflow.com/questions/tagged/phalcon\">https://stackoverflow.com/questions/tagged/phalcon</a><br>在Stack Overflow上查找问题，一般碰到的问题，官方论坛上没有Stack Overflow上会有，基本上这两个论坛就可以解决大部分问题，如果还不行，就自己提问试试吧。</li><li>Phalcontip：<a href=\"https://phalcontip.com/\" title=\"https://phalcontip.com/\">https://phalcontip.com/</a><br>这个站点上面有很多很好的实践，也可以解决很多问题。</li></ol>\r\n<h1 id=\"h1-5-\"><a name=\"5. 系列文章\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5. 系列文章</h1><p>因为我自己用 Phalcon 用起来是非常爽的，我觉得把这些整理下来，一来填坑，二来自己以后也受用。</p>\r\n<p>我准备整理出以下的文章，以后有时间抽空写写：</p>\r\n<p> <strong>初学系列</strong></p>\r\n<ul>\r\n<li><a href=\"https://www.goozp.com/article/72.html\" title=\"Phalcon框架架构初识\">Phalcon框架架构初识</a></li><li>……</li></ul>\r\n<p><strong>踩坑系列</strong></p>\r\n<ul>\r\n<li><a href=\"https://www.goozp.com/article/62.html\" title=\"Phalcon填坑手册：开发中会遇到的问题和解决方案（不断更新）\">Phalcon填坑手册：开发中会遇到的问题和解决方案（不断更新）</a></li><li>……</li></ul>\r\n<p><strong>最佳实践系列</strong></p>\r\n<ul>\r\n<li>Phalcon最佳实践1：健壮的项目结构和代码</li><li>Phalcon最佳实践2：核心之model层的使用</li><li>Phalcon最佳实践3：model的批量操作</li><li>Phalcon最佳实践4：正确使用模型关联</li><li>Phalcon最佳实践5：数据库操作的几种方式和坑</li><li>Phalcon最佳实践6：ACL实现权限功能</li><li>Phalcon最佳实践7：分页及其拓展</li><li>Phalcon最佳实践8：过滤器的使用</li><li>Phalcon最佳实践9：使用缓存系统(前后端适配器)</li><li>Phalcon最佳实践10：数据库迁移</li><li>Phalcon最佳实践11：合理使用Notfound</li><li>Phalcon最佳实践12：构建composer支持的Phalcon项目</li><li>……</li></ul>\r\n<p><strong>拓展系列</strong></p>\r\n<ul>\r\n<li>权限相关：ACL与RBAC</li><li>如何设计博客系统文章的草稿，保存，发布，自动草稿等功能</li><li>什么是元数据，如何应用</li><li>结合PHPunit做测试</li><li>开发时预留插件功能</li><li>……</li></ul>\r\n', '', 0, 'publish', 1, 0, '/article/81.html', 'https://www.goozp.com/uploads/2018/01/php_phalcon_logo_1.jpg', 0, 309, '2018-02-19 17:12:51', '2018-02-19 17:12:51', '2018-02-20 05:36:04', NULL);
INSERT INTO `pt_post` VALUES (82, 10, 'article', '更快更安全，HTTPS 优化总结', '在网站升级到 HTTPS 之后，我们还可以有很多玩意可以折腾，优化 HTTPS，让它更快更安全。这里是一篇 HTTPS 优化的总结，也包含问题的解决方法，不过不仅仅包括 HTTPS 的优化，也包含 HTTP 一些安全相关的配置。\r\n\r\n因为平时用 Nginx 比较多，本文涉及到 Web Server 的大多数例子都会以 Nginx 为例。如果有错误欢迎指出。HTTPS 发展很快，尤其是在谷歌的推动之下，如果有过时的地方，也请指出。\r\n\r\n# HSTS\r\n## HSTS（HTTP Strict Transport Security）介绍\r\n浏览器在访问站点的时候，如果没有指定 HTTPS 访问，会默认使用 HTTP，所以我们会将 HTTP 重定向（301或302）到 HTTPS。这样看起来没有问题，但是当使用重定向进行跳转时，网站就存在被劫持的可能。\r\n\r\n因此有了 HSTS， 采用 HSTS 协议的网站将保证浏览器始终连接到网站的HTTPS版本，而不需要用户手动在URL地址栏中输入包含`https://`的加密地址，实现了一种新的跳转方式（浏览器识别后直接跳转），用户访问到的直接就是 HTTPS 的版本。HSTS 还可以用来防止基于 SSL Strip 的中间人攻击。\r\n\r\nHSTS 的 HTTP 头部格式如下：\r\n```\r\nStrict-Transport-Security: max-age=<expire-time>[; includeSubDomains][; preload]\r\n```\r\n\r\n- max-age：有效时间；浏览器记住的有效时间\r\n- includeSubDomains：是否包含子域名；可选参数\r\n- preload：是否预加载；可选参数\r\n\r\n## 使用 HSTS\r\n只需要加入相应的 HTTP 头部信息就可以。比如我们配置以头部信息：\r\n```\r\nStrict-Transport-Security: max-age=31536000; includeSubDomains\r\n```\r\n\r\n以 Nginx 为例可以这样配置：\r\n```\r\nadd_header Strict-Transport-Security \"max-age=31536000; includeSubDomains\" always;\r\n```\r\n\r\n\r\n# HSTS Preloading\r\n## 介绍\r\n在上一条 HSTS 中，我们实现了浏览器维持 HTTPS 连接，但是仍然存在一个问题，如果我们是第一次访问该站点呢？那浏览器并不知道该站点的配置，所以也就不知道应该用 HTTPS 去连接，这个问题怎么解决？\r\n\r\n[HSTS Preload List](https://hstspreload.org/)，是一个谷歌维护的列表，现在大部分主流浏览器都支持这个列表，这个列表直接告诉浏览器要用 HTTPS 访问的站点有哪些，所以在访问站点之前，浏览器先捞一遍这个列表，如果要访问的站点在这里面，就直接用 HTTPS 进行访问，所以即使是第一次访问，也会走 HTTPS 了。\r\n\r\n## 加入Preload List\r\n只需要前往这个站点 [HSTS Preload List](https://hstspreload.org/) （可能需要科学上网访问）提交你的站点就可以，通过之后就加入 HSTS 预加载列表了。\r\n\r\n在提交之前，你需要注意以下几点：\r\n1. 提供有效的站点证书\r\n2. 将 HTTP 重定向到 HTTPS\r\n3. 所有的子域名也都要支持 HTTPS\r\n4. HSTS 头部配置需要：\r\n    1. max-age 需要至少 31536000 秒 (1年)\r\n    2. 必须包含includeSubDomains参数\r\n    3. 必须包含preload参数\r\n\r\n    比如 Nginx 为例修改配置为：\r\n    ```\r\n    add_header Strict-Transport-Security \"max-age=31536000; includeSubDomains; preload\" always;\r\n    ```\r\n\r\n## 注意事项\r\n加入预加载列表时候要想从列表中删除，需要很长的时间，如果你只是暂时玩玩 HTTPS，之后还会切换回 HTTP，需要谨慎考虑。\r\n\r\n\r\n# HTTP/2\r\n## HTTP/2 介绍\r\n即 HTTP 2.0，是下一代的 HTTP 协议，目前大量采用的是 HTTP 1.1，HTTP/2 现在只支持 HTTPS 开启。\r\n\r\nHTTP/2 有这些特点：\r\n- 彻底的二进制协议，头信息和数据体都是二进制\r\n- 多路复用请求\r\n- 对请求划分优先级\r\n- 压缩HTTP头\r\n- 服务器推送流（即Server Push技术）\r\n- 保持与HTTP 1.1语义的向后兼容性\r\n\r\n其中有些新东西都处于摸索阶段，比如Server Push技术。目前 Nginx 1.13.9版本中已经包含了 Server Push，参考 [Introducing HTTP/2 Server Push with NGINX 1.13.9](https://www.nginx.com/blog/nginx-1-13-9-http2-server-push/?_ga=2.42373861.1534169682.1519491280-170960590.1518497135)；但是 Nginx 当前的 stable 版本是 1.12，我准备在未来 1.13 的 stable 版本中再开启，相信性能又会有一定的提升。\r\n\r\n上 HTTP/2 给我们带来的最直观的体验就是，极大地加快了站点页面的加载速度。\r\n\r\n## 使用 HTTP/2\r\n如果是使用 Nginx，我们可以非常方便地就直接升级到 HTTP/2，只需要注意以下几点：\r\n- HTTP2 现在需要 HTTPS\r\n- HTTP2 要求 Nginx 版本是1.9.5以上\r\n- openssl 版本要求1.0.2\r\n\r\n然后，修改Nginx的配置：在监听端口的配置 `listen 443 ssl` 后面加上`http2 default_server`就行了。\r\n\r\n## 注意事项\r\n如果在 Chrome51 版本的 Chrome 浏览器中，HTTP/2不生效，检查一下是否支持 ALPN，支持 ALPN 需要开启 OCSP Stapling。\r\n\r\n\r\n# OCSP Stapling\r\n##  OCSP Stapling 是什么\r\nOCSP (Online Certificate Status Protocol) 通常是 CA 提供来实时验证证书是否合法有效的。客户端就可以根据证书中的 OCSP 信息，发送查询请求到 CA 的在线验证地址来查询证书是否有效。OCSP 的问题在于，对 CA 机构的验证接口高可用性有要求，增加了浏览器握手的延时。\r\n\r\nOCSP Stapling 技术是对 OCSP协议 的进一步升级。服务器事先模拟浏览器对证书链进行验证，然后将 OCSP 验证结果缓存到本地。这样，当浏览器访问站点时，在握手阶段，可以直接拿到 OCSP 响应结果和证书链，就不需要再向 CA 请求接口，对访问速度有明显提升。\r\n\r\n## 开启 OCSP Stapling\r\n检测 OCSP Stapling 的状态：\r\n```\r\nopenssl s_client -connect [yoursite.com]:443 -status\r\n```\r\n如果支持 OCSP Stapling 会看到`OCSP Response Data`内有以下内容：\r\n```\r\nOCSP Response Status: successful (0x0)\r\n```\r\n而如果不支持，不会有`OCSP Response Data`的内容。\r\n\r\n### Nginx 中开启 OCSP Stapling\r\n```\r\nssl_stapling on;\r\nssl_stapling_verify on;\r\nssl_trusted_certificate /path/to/certs/chained.pem;\r\n```\r\n如果 ssl_certificate 指令指定了完整的证书链，则 ssl_trusted_certificate 可省略。例如：\r\n```\r\nserver\r\n{\r\n    listen 443 ssl;\r\n    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;\r\n\r\n    ssl_certificate /etc/ssl/bundle.crt;\r\n    ssl_certificate_key /etc/ssl/your_domain_name.key;\r\n\r\n    ssl_stapling on;\r\n    ssl_stapling_verify on;\r\n}\r\n```\r\n重启 Nginx 即可生效。\r\n\r\n### Apache 中开启 OCSP Stapling\r\n在 `<VirtualHost></VirtualHost>` 中添加:\r\n```\r\nSSLUseStapling on\r\n```\r\n在 `<VirtualHost></VirtualHost>` 外添加:\r\n```\r\nSSLStaplingCache shmcb:/tmp/stapling_cache(128000)\r\n```\r\n例如：\r\n```\r\nSSLStaplingCache shmcb:/tmp/stapling_cache(128000)\r\n<VirtualHost *:443>\r\nSSLEngine on\r\nSSLProtocol all -SSLv3 -SSLv2\r\n\r\nSSLCertificateFile /path/to/your_domain_name.crt\r\nSSLCertificateKeyFile /path/to/your_private.key\r\nSSLCertificateChainFile /path/to/root.crt\r\n\r\nSSLUseStapling on\r\n</VirtualHost>\r\n```\r\n然后重启 Apache。\r\n\r\n\r\n# TLS False Start\r\nTLS False Start 意味着抢先开始。在 TLS 握手的过程中，客户端在发送 Change Cipher Spec 和 Finished，即握手完成前，就开始发送应用层的请求数据，服务端在 TLS 握手完成时直接返回响应数据。\r\n\r\n开启 TLS False Start 非常简单，以 Nginx 为例，在配置中加上：\r\n```\r\nssl_prefer_server_ciphers on;\r\nssl_ciphers EECDH+ECDSA+AESGCM:EECDH+aRSA+AESGCM:EECDH+ECDSA+SHA256:EECDH+aRSA+SHA256:EECDH+ECDSA+SHA384:EECDH+ECDSA+SHA256:EECDH+aRSA+SHA384:EDH+aRSA+AESGCM:EDH+aRSA+SHA256:EDH+aRSA:EECDH:!aNULL:!eNULL:!MEDIUM:!LOW:!3DES:!MD5:!EXP:!PSK:!SRP:!DSS:!RC4:!SEED;\r\n```\r\nssl_ciphers 加密方式的配置因人而异，可以参考一些资料琢磨一下。\r\n\r\n\r\n# Session resumption\r\n## Session ID resumption\r\n如果客户端和服务器端都保存了 session keys，我们就可以重用加密的 session。通过给每个连接一个唯一标识，服务端可以知道一个进来的连接是否在之前已经建立过连接，如果在服务器中也存在这个 session 的 key，那么它就能重用。\r\n\r\n重用 Session ID 需要服务器保存 Session 状态等，这样下次连接才能复用，这就需要服务器保存很多状态信息，所以耗费内存。\r\n\r\n重用 Session ID 在 Apache 中可以通过 `SSLSessionCache` 配置，在 Nginx 中可以通过 `ssl_session_cache` 设置。\r\n\r\n以 Nginx 为例，我们配置以下内容：\r\n- ssl_session_cache 设置储存SSL会话的缓存类型和大小。默认值为 `ssl_session_cache off`，off为关闭，还有一些其它的缓存类型，不过这里建议使用shared共享缓存类型，这种方法更为有效。\r\n- ssl_session_timeout 客户端能够反复使用储存在缓存中的会话参数时间\r\n\r\n例如：\r\n```\r\nssl_session_cache shared:SSL:50m;\r\nssl_session_timeout 1d;\r\n```\r\n共享缓存，缓存大小为50m，缓存时间1天。\r\n\r\n## Session ticket resumption\r\n在 Session ticket 重用中，服务器不需要保存所有的创建的 session 的状态信息，反而将状态保存成块状数据交给客户端来维护。Session tickets 允许服务器将某些信息存储到客户端，类似于HTTP cookies 在信息验证的应用。\r\n\r\nSession ticket 就是加密的存储了重用 TLS 连接所需要的信息的块数据（比如 session keys）。通常使用只有服务器才知道的 ticket key 来加密。\r\n\r\n服务器在初始握手期间向客户端发送 Session ticket 以便本地存储。当重用 session 时，客户端会将 Session ticket 发送回服务器交给服务器进行解密，然后恢复会话。\r\n\r\n复用 session ticket 在 Apache 中可以通过 `SSLTicketKeyDefault` 配置，在 Nginx 中可以通过 `ssl_session_tickets` 设置。\r\n在 Nginx 中，例：\r\n```\r\nssl_session_tickets on;\r\nssl_session_ticket_key current.key;\r\nssl_session_ticket_key previous.key;\r\n```\r\nNginx 中使用 `ssl_session_ticket_key file;` 来配置用于加密和解密 SSL session_ticket的密钥，如果用了多个指令文件，则仅第一个指令文件中的密钥用来加密和解密；其它的密钥文件（下面的）用来解密，这样的原因是，我们最好定期轮换加解密的 key，轮换的时候把旧的放在下面用来解密旧的 ticket，第一个放新的，用来加解密新的请求。 \r\n如果没有配置 key 文件，则 openssl 默认会在 ssl 初始化的时候生成随机数的 key；这种时候只有在重启 web server 的时候才会重新生成随机 key。\r\n\r\n## Session ID resumption 与 Session ticket resumption\r\n复用 session ticket 和 复用 session ID 的区别在于，复用 session ID 时在服务器和客户端存储了 key，连接时比对两边的数据是否一致；而 session ticket 将数据加密后存储在客户端，客户端请求时带回数据让服务器解密，正常则复用，只有发布的服务端能够解密该数据。\r\n\r\n如果在握手阶段 session ID 和 session ticket 都提供了，将以 session ticket 为准，如果在 session ticket 阶段被 pass 掉了才通过 session id 取 cache 中的信息来复用。\r\n\r\n\r\n# Public-Key-Pins\r\n## Public-Key-Pins 用来做什么呢\r\n任何一家受信任的 CA 都可以签发任意网站的站点证书，浏览器识别起来都是合法的，这些受信任的 CA 可以签发任意网站的站点证书（包括你的站点），而这些受信任的 CA 有很多，如果某 CA 中的某链被攻破，就可以造成由伪造或不正当手段获得网站证书的中间人攻击。\r\n\r\n所以 Public-Key-Pins 就是用来告诉浏览器当前网站的证书指纹，包括配置过期时间，在过期时间内，浏览器再次访问这个网站的话就必须验证证书链中的证书指纹，如果跟之前指定的证书指纹不匹配，就无法访问。\r\n\r\n如果我们自己更换了证书呢？为了避免这个情况导致的问题，所以我们在配置指纹的时候，至少配置两个，其中包含一个备用指纹。\r\n\r\n关于 HTTP Public Key Pinning (HPKP)的介绍，这里非常详细：[Public_Key_Pinning](https://developer.mozilla.org/en-US/docs/Web/HTTP/Public_Key_Pinning)\r\n\r\nPublic-Key-Pins 的 HTTP 头的格式如下：   \r\n```\r\nPublic-Key-Pins: pin-sha256=\"base64==\"; max-age=expireTime [; includeSubDomains][; report-uri=\"reportURI\"]\r\n```\r\n- pin-sha256：Base64加密的证书指纹；一般情况至少指定两个，其中包含一个备用指纹。\r\n- max-age：过期时间，秒\r\n- includeSubDomains：是否包含子域\r\n- report-uri：可选参数；验证失败时的上报地址\r\n\r\n`pin-sha256`证书指纹这个配置很容器搞错，我们需要指定一个备用指纹，而这个指纹并不是当前域名证书链中的指纹，应该是一个不在当前链中，未来有可能更换到该链的备用指纹。比如我的证书链，根证书是 DigiCert Global Root CA，中间证书是 Encryption Everywhere DV TLS CA - G1，再加上域名证书，我就可以配置中间证书为第一个pin-sha256，而第二个证书配置  Let\'s Encrypt 的证书指纹，这样以后如果用  Let\'s Encrypt Authority 签发证书，老用户不会受到影响。\r\n\r\n这里 [HTTP Public Key Pinning: You’re doing it wrong!](https://news.netcraft.com/archives/2016/03/30/http-public-key-pinning-youre-doing-it-wrong.html) 非常详细地介绍了在配置这个配置时会出现的问题。\r\n\r\n## 使用\r\n生成`pin-sha256`指纹，可以通过以下的方式来生成：\r\n通过 RSA key 文件生成：\r\n```\r\nopenssl rsa -in my-rsa-key-file.key -outform der -pubout | openssl dgst -sha256 -binary | openssl enc -base64\r\n```\r\n\r\n通过 ECC key 文件生成：\r\n```\r\nopenssl ec -in my-ecc-key-file.key -outform der -pubout | openssl dgst -sha256 -binary | openssl enc -base64\r\n```\r\n\r\n通过 CSR 文件生成：\r\n```\r\nopenssl req -in my-signing-request.csr -pubkey -noout | openssl pkey -pubin -outform der | openssl dgst -sha256 -binary | openssl enc -base64\r\n```\r\n\r\n通过域名之间生成：\r\n```\r\nopenssl s_client -servername www.example.com -connect www.example.com:443 | openssl x509 -pubkey -noout | openssl pkey -pubin -outform der | openssl dgst -sha256 -binary | openssl enc -base64\r\n```\r\n\r\n生成证书指纹之后就可以将指纹加入到配置中。\r\n\r\nApache配置：\r\n```\r\nHeader always set Public-Key-Pins \"pin-sha256=\\\"base64+primary==\\\"; pin-sha256=\\\"base64+backup==\\\"; max-age=5184000; includeSubDomains\"\r\n```\r\n\r\nNginx配置：\r\n```\r\nadd_header Public-Key-Pins \'pin-sha256=\"base64+primary==\"; pin-sha256=\"base64+backup==\"; max-age=5184000; includeSubDomains\' always;\r\n```\r\n\r\n# DNS CAA\r\n## DNS CAA 是什么\r\nCAA（Certificate Authority Authorization），即证书颁发机构授权。简单地说，就是当域名的 DNS 解析存在 CAA 记录时，则只允许在记录中列出的 CA 机构颁发针对该域名(或子域名)的证书。CAA 记录可以控制单域名 SS L证书的发行，也可以控制通配符证书。\r\n\r\n所以设置了 CAA，如果有一天想更换非 CAA 记录中的 CA，要记得把 DNS CAA 的解析记录消掉。否则颁发会失败。\r\n\r\n## 设置 CAA\r\n目前国内的云服务中，阿里云支持 CAA 的 DNS 解析，因为我本人用的阿里云，所以其它云服务产商不太了解，在 DNS 解析处看看就知道支持不支持了，如果不支持想添加的话也可以换用支持的 DNS 服务商来解决。\r\n\r\n添加 DNS 解析，选择 CAA 类型，填写通配符还是非通配符的，然后就是记录值了。如下图：\r\n![](https://www.goozp.com/uploads/2018/02/aliyun_CAA.png)\r\n\r\n关于记录值，我们可以简单地使用 [CAA Record Helper](https://sslmate.com/caa/) 来自动生成，非常方便。将生成的记录值（比如 `0 issue \"digicert.com\"` 这样的）填入到 DNS 解析中既可。\r\n\r\n# X-Frame-Options 响应头\r\nX-Frame-Options HTTP 响应头是用来给浏览器指示是否允许一个页面在 `<frame>`，`<iframe>` 或者 `<object>` 中展现的标记。通过设置 X-Frame-Options HTTP 响应头，我们可以确保自己的网站内容没有被嵌到别人的网站中去，也从而避免了点击劫持 (clickjacking) 的攻击。\r\n\r\nX-Frame-Options 有三个值:\r\n- DENY\r\n    表示该页面不允许在 frame 中展示，即便是在相同域名的页面中嵌套也不允许。\r\n- SAMEORIGIN\r\n    表示该页面可以在相同域名页面的 frame 中展示。\r\n- ALLOW-FROM uri\r\n    表示该页面可以在指定来源的 frame 中展示。\r\n\r\n就是说，如果设置为 DENY，不光在别人的网站 frame 嵌入时会无法加载，在同域名页面中同样会无法加载；如果设置为 SAMEORIGIN，那么页面就可以在同域名页面的 frame 中嵌套。\r\n\r\nCSP Level 2 规范中的 frame-ancestors 指令会替代这个非标准的 header。CSP 的 frame-ancestors 会在 Gecko 4.0 中支持，但是并不会被所有浏览器支持。然而 X-Frame-Options 是个已广泛支持的非官方标准，可以和 CSP 结合使用。\r\n\r\n## Apache 配置\r\n要把下面这行添加到“site”的配置中：\r\n```\r\nHeader always append X-Frame-Options SAMEORIGIN\r\n```\r\n\r\n## Nginx 配置\r\n在“http”，“server”或者“location”的配置中：\r\n```\r\nadd_header X-Frame-Options SAMEORIGIN;\r\n```\r\n\r\n# X-Content-Type-Options 响应头\r\n我们都知道 Content-Type 是用来标识资源类型的。浏览器有个特性，就是当有些资源的 Content-Type 没定义或者定义错了，浏览器会启用 MIME sniffing 来检测该资源的类型然后解析内容并执行。所以攻击者可以利用浏览器这个特性让原本的请求中的资源类型解析为其它类型，所以一般情况下我们都禁止浏览器去检测类型：\r\n```\r\nX-Content-Type-Options: nosniff\r\n```\r\n\r\n在 Nginx 中我们可以加上配置：\r\n```\r\nadd_header X-Content-Type-Options nosniff;\r\n```\r\n\r\n# Server Banner\r\n服务器版本号不应该存在在响应头中，这样容易让攻击者找到弱点。\r\n\r\nNginx 中可以增加以下配置：\r\n```\r\nserver_tokens off;\r\n```\r\n就会去除版本号，比如 nginx/1.10.3 就变成了 ningx.\r\n\r\n# Web framework Information\r\n和服务器版本号一样，我们应该移除一些头部框架信息，比如 X-Powered-By，X-Runtime，X-Version，X-AspNet-Version等。\r\n\r\n在 Nginx 中加配置：\r\n```\r\nproxy_hide_header X-Powered-By;\r\n```\r\n如果是 fastcgi 模式的 PHP 应用则用：\r\n```\r\nfastcgi_hide_header X-Powered-By;\r\n```\r\n\r\n在 PHP 配置 php.ini 中移除版本号，可以设置 expose_php：\r\n```\r\nexpose_php = off\r\n```\r\n\r\n# X-XSS-Protection 响应头\r\nXSS Protection 显然是用来防止 XSS 攻击的，这个不需要多解释了。\r\n\r\n我们只需要知道，现在主流浏览器都支持，并且默认都开启了 XSS 保护。配置这个响应头可以将它关闭，但是如果你没有更加好的防范 XSS 的解决方案，就留着吧。\r\n\r\n在 Nginx 中配置启用XSS保护，并在检查到XSS攻击时，停止渲染页面：\r\n```\r\nadd_header X-Xss-Protection \"1; mode=block\";\r\n```\r\n\r\n# Content Security Policy\r\nContent Security Policy（CSP），是用来有效防止 XSS 攻击的，实际上就是提供了一个白名单告诉客户端，哪些外部资源可以加载和执行。通过页面的`<meta>`标签和 HTTP 的 `Content-Security-Policy` 头信息的都可以控制 CSP。\r\n\r\n关于 CSP，我觉得阮一峰老师的这篇文章挺不错的：[Content Security Policy 入门教程](http://www.ruanyifeng.com/blog/2016/09/csp.html)，以及 google developer 的：[内容安全政策 ](https://developers.google.com/web/fundamentals/security/csp/?hl=zh-cn)。\r\n\r\nCSP 的配置需要根据自己的实际情况来配置。这里我就举个例子：\r\n```\r\nContent-Security-Policy: default-src \'self\' blob: data:; script-src \'self\' \'unsafe-inline\' *.baidu.com; img-src *\r\n```\r\n这里定义所有的资源类型都默认只能从当前域名加载（`\'self\'`），然后定义了 `blob:` 和 `data:`（实际上如果不是非要加载字体 font 等，使用要谨慎，攻击者很容器利用`data: URIs`注入攻击） 数据类型也允许加载；`script-src` 定义了只能从当前域名加载，`\'unsafe-inline\'` 是为了使用监听事件，允许加载百度的域名 `*.baidu.com`（使用百度统计的话）；`img-src *` 而图片文件可以从任何域名加载。\r\n\r\n以上只是随便举一个例子，这一套配置需要自己来定制。而且这个配置挺麻烦的，需要自己慢慢调试，特别是如果引用了很多外部资源，不过在安全上起到很好的效果。\r\n\r\n\r\n# Cache Control\r\nCache Control 表示输出页面的缓存首选项。强烈推荐自定义缓存的偏好，如果不定义 Cache Control，将由浏览器或者代理来选择是否缓存内存，而这种不受控制的选择有可能会导致性能问题或安全问题。\r\n\r\n每个资源都可通过 Cache-Control HTTP 标头定义其缓存策略，Cache-Control 指令控制谁在什么条件下可以缓存响应以及可以缓存多久。\r\n\r\nCache-Control 是一个灵活的配置，我们应该根据自己的需求定义最佳 Cache-Control 策略，参考 [HTTP 缓存](https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching)。\r\n\r\n\r\n# Secure Cookies\r\n如果站定已经是基于 HTTPS 的，包含敏感信息的 cookie，特别是 session id（在使用 session时，会在客户端存储一个cookie，记录 session id），需要被标记为安全的。\r\n例如以下这个设置 cookie 的头：\r\n```\r\nset-cookie: PHPSESSID=03196cccbf3a8cd7d4fb22214fc5111e; path=/\r\n```\r\nHTTPS 站点加上 secure 标志：\r\n```\r\nset-cookie: PHPSESSID=03196cccbf3a8cd7d4fb22214fc5111e; path=/; secure; \r\n```\r\n这样只有在 HTTPS 下 cookie 才能生效。另一种防范不安全的 cookie 通过 HTTP 传送的方式是 HSTS，上面已经提到过了，建议同时开启 HSTS 和 secure cookie。\r\n\r\nSession cookies 应该标记上 HttpOnly，防止通过 JavaScript 访问，攻击者可以利用这点进行 XSS 攻击窃取 Session cookies。其它的 cookie 可以不这么严格地标记，但是除非有从 JavaScript 去访问的需求，都建议标记上 HttpOnly。\r\n例如上面的 set-cookie，我们需要修改成以下的头信息：\r\n```\r\nset-cookie: PHPSESSID=03196cccbf3a8cd7d4fb22214fc5111e; path=/; secure; HttpOnly\r\n```\r\n\r\n\r\n# 不要混用 HTTPS 和 HTTP\r\n最后一点，不要 HTTPS 和 HTTP 混用，既然上了 HTTPS，还留 HTTP 做什么呢？为了 SEO 么？\r\n\r\n随着时间推移，越早全站 HTTPS 优势只会越明显。\r\n\r\n\r\n# 其它优化操作\r\n## SRI（Subresource Integrity）\r\n子资源完整性（SRI）是允许浏览器检查其获得的资源（例如从 CDN 获得的）是否被篡改的一项安全特性。它通过验证获取文件的哈希值是否和你提供的哈希值一样来判断资源是否被篡改。\r\n\r\nSRI 目前的浏览器兼容性不好，而且会增加代码和配置的复杂度。可以参考：[Subresource Integrity](https://developer.mozilla.org/zh-CN/docs/Web/Security/%E5%AD%90%E8%B5%84%E6%BA%90%E5%AE%8C%E6%95%B4%E6%80%A7)\r\n\r\n## Iframe Sandbox\r\nIframe Sandbox是html5的新属性，是专门为 iframe 定制的，如果你用了 iframe，才建议加上这个属性。可以参考：[<iframe>](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/iframe)。\r\n\r\n# 总结\r\n基本上以上内容做完就差不多了，SSLLabs 上测试肯定是 A+ 的。先到这里，以后再看看有没有什么要修改或者补充的。\r\n\r\n**测试站点**\r\n- Qualys SSL Labs：[https://www.ssllabs.com/ssltest/](https://www.ssllabs.com/ssltest/)\r\n- HTTP Security Report：[https://httpsecurityreport.com/](https://httpsecurityreport.com/)\r\n\r\n**本文参考资料**\r\n- MDN web docs HTTP：[https://developer.mozilla.org/en-US/docs/Web/HTTP](https://developer.mozilla.org/en-US/docs/Web/HTTP)\r\n- Speeding up HTTPS with session resumption：[https://calendar.perfplanet.com/2014/speeding-up-https-with-session-resumption/](https://calendar.perfplanet.com/2014/speeding-up-https-with-session-resumption/)\r\n- HTTP Security Best Practice：[https://httpsecurityreport.com/best_practice.html](https://httpsecurityreport.com/best_practice.html)\r\n- Guidelines for Setting Security Headers：[https://www.veracode.com/blog/2014/03/guidelines-for-setting-security-headers](https://www.veracode.com/blog/2014/03/guidelines-for-setting-security-headers)\r\n- HTTP 缓存：[https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching](https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching)', '<p>在网站升级到 HTTPS 之后，我们还可以有很多玩意可以折腾，优化 HTTPS，让它更快更安全。这里是一篇 HTTPS 优化的总结，也包含问题的解决方法，不过不仅仅包括 HTTPS 的优化，也包含 HTTP 一些安全相关的配置。</p>\r\n<p>因为平时用 Nginx 比较多，本文涉及到 Web Server 的大多数例子都会以 Nginx 为例。如果有错误欢迎指出。HTTPS 发展很快，尤其是在谷歌的推动之下，如果有过时的地方，也请指出。</p>\r\n<h1 id=\"h1-hsts\"><a name=\"HSTS\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>HSTS</h1><h2 id=\"h2-hsts-http-strict-transport-security-\"><a name=\"HSTS（HTTP Strict Transport Security）介绍\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>HSTS（HTTP Strict Transport Security）介绍</h2><p>浏览器在访问站点的时候，如果没有指定 HTTPS 访问，会默认使用 HTTP，所以我们会将 HTTP 重定向（301或302）到 HTTPS。这样看起来没有问题，但是当使用重定向进行跳转时，网站就存在被劫持的可能。</p>\r\n<p>因此有了 HSTS， 采用 HSTS 协议的网站将保证浏览器始终连接到网站的HTTPS版本，而不需要用户手动在URL地址栏中输入包含<code>https://</code>的加密地址，实现了一种新的跳转方式（浏览器识别后直接跳转），用户访问到的直接就是 HTTPS 的版本。HSTS 还可以用来防止基于 SSL Strip 的中间人攻击。</p>\r\n<p>HSTS 的 HTTP 头部格式如下：</p>\r\n<pre><code>Strict-Transport-Security: max-age=&lt;expire-time&gt;[; includeSubDomains][; preload]\r\n</code></pre><ul>\r\n<li>max-age：有效时间；浏览器记住的有效时间</li><li>includeSubDomains：是否包含子域名；可选参数</li><li>preload：是否预加载；可选参数</li></ul>\r\n<h2 id=\"h2--hsts\"><a name=\"使用 HSTS\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>使用 HSTS</h2><p>只需要加入相应的 HTTP 头部信息就可以。比如我们配置以头部信息：</p>\r\n<pre><code>Strict-Transport-Security: max-age=31536000; includeSubDomains\r\n</code></pre><p>以 Nginx 为例可以这样配置：</p>\r\n<pre><code>add_header Strict-Transport-Security &quot;max-age=31536000; includeSubDomains&quot; always;\r\n</code></pre><h1 id=\"h1-hsts-preloading\"><a name=\"HSTS Preloading\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>HSTS Preloading</h1><h2 id=\"h2-u4ECBu7ECD\"><a name=\"介绍\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>介绍</h2><p>在上一条 HSTS 中，我们实现了浏览器维持 HTTPS 连接，但是仍然存在一个问题，如果我们是第一次访问该站点呢？那浏览器并不知道该站点的配置，所以也就不知道应该用 HTTPS 去连接，这个问题怎么解决？</p>\r\n<p><a href=\"https://hstspreload.org/\">HSTS Preload List</a>，是一个谷歌维护的列表，现在大部分主流浏览器都支持这个列表，这个列表直接告诉浏览器要用 HTTPS 访问的站点有哪些，所以在访问站点之前，浏览器先捞一遍这个列表，如果要访问的站点在这里面，就直接用 HTTPS 进行访问，所以即使是第一次访问，也会走 HTTPS 了。</p>\r\n<h2 id=\"h2--preload-list\"><a name=\"加入Preload List\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>加入Preload List</h2><p>只需要前往这个站点 <a href=\"https://hstspreload.org/\">HSTS Preload List</a> （可能需要科学上网访问）提交你的站点就可以，通过之后就加入 HSTS 预加载列表了。</p>\r\n<p>在提交之前，你需要注意以下几点：</p>\r\n<ol>\r\n<li>提供有效的站点证书</li><li>将 HTTP 重定向到 HTTPS</li><li>所有的子域名也都要支持 HTTPS</li><li><p>HSTS 头部配置需要：</p>\r\n<ol>\r\n<li>max-age 需要至少 31536000 秒 (1年)</li><li>必须包含includeSubDomains参数</li><li><p>必须包含preload参数</p>\r\n<p>比如 Nginx 为例修改配置为：</p>\r\n<pre><code>add_header Strict-Transport-Security &quot;max-age=31536000; includeSubDomains; preload&quot; always;\r\n</code></pre></li></ol>\r\n</li></ol>\r\n<h2 id=\"h2-u6CE8u610Fu4E8Bu9879\"><a name=\"注意事项\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>注意事项</h2><p>加入预加载列表时候要想从列表中删除，需要很长的时间，如果你只是暂时玩玩 HTTPS，之后还会切换回 HTTP，需要谨慎考虑。</p>\r\n<h1 id=\"h1-http-2\"><a name=\"HTTP/2\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>HTTP/2</h1><h2 id=\"h2-http-2-\"><a name=\"HTTP/2 介绍\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>HTTP/2 介绍</h2><p>即 HTTP 2.0，是下一代的 HTTP 协议，目前大量采用的是 HTTP 1.1，HTTP/2 现在只支持 HTTPS 开启。</p>\r\n<p>HTTP/2 有这些特点：</p>\r\n<ul>\r\n<li>彻底的二进制协议，头信息和数据体都是二进制</li><li>多路复用请求</li><li>对请求划分优先级</li><li>压缩HTTP头</li><li>服务器推送流（即Server Push技术）</li><li>保持与HTTP 1.1语义的向后兼容性</li></ul>\r\n<p>其中有些新东西都处于摸索阶段，比如Server Push技术。目前 Nginx 1.13.9版本中已经包含了 Server Push，参考 <a href=\"https://www.nginx.com/blog/nginx-1-13-9-http2-server-push/?_ga=2.42373861.1534169682.1519491280-170960590.1518497135\">Introducing HTTP/2 Server Push with NGINX 1.13.9</a>；但是 Nginx 当前的 stable 版本是 1.12，我准备在未来 1.13 的 stable 版本中再开启，相信性能又会有一定的提升。</p>\r\n<p>上 HTTP/2 给我们带来的最直观的体验就是，极大地加快了站点页面的加载速度。</p>\r\n<h2 id=\"h2--http-2\"><a name=\"使用 HTTP/2\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>使用 HTTP/2</h2><p>如果是使用 Nginx，我们可以非常方便地就直接升级到 HTTP/2，只需要注意以下几点：</p>\r\n<ul>\r\n<li>HTTP2 现在需要 HTTPS</li><li>HTTP2 要求 Nginx 版本是1.9.5以上</li><li>openssl 版本要求1.0.2</li></ul>\r\n<p>然后，修改Nginx的配置：在监听端口的配置 <code>listen 443 ssl</code> 后面加上<code>http2 default_server</code>就行了。</p>\r\n<h2 id=\"h2-u6CE8u610Fu4E8Bu9879\"><a name=\"注意事项\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>注意事项</h2><p>如果在 Chrome51 版本的 Chrome 浏览器中，HTTP/2不生效，检查一下是否支持 ALPN，支持 ALPN 需要开启 OCSP Stapling。</p>\r\n<h1 id=\"h1-ocsp-stapling\"><a name=\"OCSP Stapling\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>OCSP Stapling</h1><h2 id=\"h2-ocsp-stapling-\"><a name=\"OCSP Stapling 是什么\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>OCSP Stapling 是什么</h2><p>OCSP (Online Certificate Status Protocol) 通常是 CA 提供来实时验证证书是否合法有效的。客户端就可以根据证书中的 OCSP 信息，发送查询请求到 CA 的在线验证地址来查询证书是否有效。OCSP 的问题在于，对 CA 机构的验证接口高可用性有要求，增加了浏览器握手的延时。</p>\r\n<p>OCSP Stapling 技术是对 OCSP协议 的进一步升级。服务器事先模拟浏览器对证书链进行验证，然后将 OCSP 验证结果缓存到本地。这样，当浏览器访问站点时，在握手阶段，可以直接拿到 OCSP 响应结果和证书链，就不需要再向 CA 请求接口，对访问速度有明显提升。</p>\r\n<h2 id=\"h2--ocsp-stapling\"><a name=\"开启 OCSP Stapling\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>开启 OCSP Stapling</h2><p>检测 OCSP Stapling 的状态：</p>\r\n<pre><code>openssl s_client -connect [yoursite.com]:443 -status\r\n</code></pre><p>如果支持 OCSP Stapling 会看到<code>OCSP Response Data</code>内有以下内容：</p>\r\n<pre><code>OCSP Response Status: successful (0x0)\r\n</code></pre><p>而如果不支持，不会有<code>OCSP Response Data</code>的内容。</p>\r\n<h3 id=\"h3-nginx-ocsp-stapling\"><a name=\"Nginx 中开启 OCSP Stapling\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Nginx 中开启 OCSP Stapling</h3><pre><code>ssl_stapling on;\r\nssl_stapling_verify on;\r\nssl_trusted_certificate /path/to/certs/chained.pem;\r\n</code></pre><p>如果 ssl_certificate 指令指定了完整的证书链，则 ssl_trusted_certificate 可省略。例如：</p>\r\n<pre><code>server\r\n{\r\n    listen 443 ssl;\r\n    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;\r\n\r\n    ssl_certificate /etc/ssl/bundle.crt;\r\n    ssl_certificate_key /etc/ssl/your_domain_name.key;\r\n\r\n    ssl_stapling on;\r\n    ssl_stapling_verify on;\r\n}\r\n</code></pre><p>重启 Nginx 即可生效。</p>\r\n<h3 id=\"h3-apache-ocsp-stapling\"><a name=\"Apache 中开启 OCSP Stapling\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Apache 中开启 OCSP Stapling</h3><p>在 <code>&lt;VirtualHost&gt;&lt;/VirtualHost&gt;</code> 中添加:</p>\r\n<pre><code>SSLUseStapling on\r\n</code></pre><p>在 <code>&lt;VirtualHost&gt;&lt;/VirtualHost&gt;</code> 外添加:</p>\r\n<pre><code>SSLStaplingCache shmcb:/tmp/stapling_cache(128000)\r\n</code></pre><p>例如：</p>\r\n<pre><code>SSLStaplingCache shmcb:/tmp/stapling_cache(128000)\r\n&lt;VirtualHost *:443&gt;\r\nSSLEngine on\r\nSSLProtocol all -SSLv3 -SSLv2\r\n\r\nSSLCertificateFile /path/to/your_domain_name.crt\r\nSSLCertificateKeyFile /path/to/your_private.key\r\nSSLCertificateChainFile /path/to/root.crt\r\n\r\nSSLUseStapling on\r\n&lt;/VirtualHost&gt;\r\n</code></pre><p>然后重启 Apache。</p>\r\n<h1 id=\"h1-tls-false-start\"><a name=\"TLS False Start\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>TLS False Start</h1><p>TLS False Start 意味着抢先开始。在 TLS 握手的过程中，客户端在发送 Change Cipher Spec 和 Finished，即握手完成前，就开始发送应用层的请求数据，服务端在 TLS 握手完成时直接返回响应数据。</p>\r\n<p>开启 TLS False Start 非常简单，以 Nginx 为例，在配置中加上：</p>\r\n<pre><code>ssl_prefer_server_ciphers on;\r\nssl_ciphers EECDH+ECDSA+AESGCM:EECDH+aRSA+AESGCM:EECDH+ECDSA+SHA256:EECDH+aRSA+SHA256:EECDH+ECDSA+SHA384:EECDH+ECDSA+SHA256:EECDH+aRSA+SHA384:EDH+aRSA+AESGCM:EDH+aRSA+SHA256:EDH+aRSA:EECDH:!aNULL:!eNULL:!MEDIUM:!LOW:!3DES:!MD5:!EXP:!PSK:!SRP:!DSS:!RC4:!SEED;\r\n</code></pre><p>ssl_ciphers 加密方式的配置因人而异，可以参考一些资料琢磨一下。</p>\r\n<h1 id=\"h1-session-resumption\"><a name=\"Session resumption\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Session resumption</h1><h2 id=\"h2-session-id-resumption\"><a name=\"Session ID resumption\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Session ID resumption</h2><p>如果客户端和服务器端都保存了 session keys，我们就可以重用加密的 session。通过给每个连接一个唯一标识，服务端可以知道一个进来的连接是否在之前已经建立过连接，如果在服务器中也存在这个 session 的 key，那么它就能重用。</p>\r\n<p>重用 Session ID 需要服务器保存 Session 状态等，这样下次连接才能复用，这就需要服务器保存很多状态信息，所以耗费内存。</p>\r\n<p>重用 Session ID 在 Apache 中可以通过 <code>SSLSessionCache</code> 配置，在 Nginx 中可以通过 <code>ssl_session_cache</code> 设置。</p>\r\n<p>以 Nginx 为例，我们配置以下内容：</p>\r\n<ul>\r\n<li>ssl_session_cache 设置储存SSL会话的缓存类型和大小。默认值为 <code>ssl_session_cache off</code>，off为关闭，还有一些其它的缓存类型，不过这里建议使用shared共享缓存类型，这种方法更为有效。</li><li>ssl_session_timeout 客户端能够反复使用储存在缓存中的会话参数时间</li></ul>\r\n<p>例如：</p>\r\n<pre><code>ssl_session_cache shared:SSL:50m;\r\nssl_session_timeout 1d;\r\n</code></pre><p>共享缓存，缓存大小为50m，缓存时间1天。</p>\r\n<h2 id=\"h2-session-ticket-resumption\"><a name=\"Session ticket resumption\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Session ticket resumption</h2><p>在 Session ticket 重用中，服务器不需要保存所有的创建的 session 的状态信息，反而将状态保存成块状数据交给客户端来维护。Session tickets 允许服务器将某些信息存储到客户端，类似于HTTP cookies 在信息验证的应用。</p>\r\n<p>Session ticket 就是加密的存储了重用 TLS 连接所需要的信息的块数据（比如 session keys）。通常使用只有服务器才知道的 ticket key 来加密。</p>\r\n<p>服务器在初始握手期间向客户端发送 Session ticket 以便本地存储。当重用 session 时，客户端会将 Session ticket 发送回服务器交给服务器进行解密，然后恢复会话。</p>\r\n<p>复用 session ticket 在 Apache 中可以通过 <code>SSLTicketKeyDefault</code> 配置，在 Nginx 中可以通过 <code>ssl_session_tickets</code> 设置。<br>在 Nginx 中，例：</p>\r\n<pre><code>ssl_session_tickets on;\r\nssl_session_ticket_key current.key;\r\nssl_session_ticket_key previous.key;\r\n</code></pre><p>Nginx 中使用 <code>ssl_session_ticket_key file;</code> 来配置用于加密和解密 SSL session_ticket的密钥，如果用了多个指令文件，则仅第一个指令文件中的密钥用来加密和解密；其它的密钥文件（下面的）用来解密，这样的原因是，我们最好定期轮换加解密的 key，轮换的时候把旧的放在下面用来解密旧的 ticket，第一个放新的，用来加解密新的请求。<br>如果没有配置 key 文件，则 openssl 默认会在 ssl 初始化的时候生成随机数的 key；这种时候只有在重启 web server 的时候才会重新生成随机 key。</p>\r\n<h2 id=\"h2-session-id-resumption-session-ticket-resumption\"><a name=\"Session ID resumption 与 Session ticket resumption\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Session ID resumption 与 Session ticket resumption</h2><p>复用 session ticket 和 复用 session ID 的区别在于，复用 session ID 时在服务器和客户端存储了 key，连接时比对两边的数据是否一致；而 session ticket 将数据加密后存储在客户端，客户端请求时带回数据让服务器解密，正常则复用，只有发布的服务端能够解密该数据。</p>\r\n<p>如果在握手阶段 session ID 和 session ticket 都提供了，将以 session ticket 为准，如果在 session ticket 阶段被 pass 掉了才通过 session id 取 cache 中的信息来复用。</p>\r\n<h1 id=\"h1-public-key-pins\"><a name=\"Public-Key-Pins\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Public-Key-Pins</h1><h2 id=\"h2-public-key-pins-\"><a name=\"Public-Key-Pins 用来做什么呢\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Public-Key-Pins 用来做什么呢</h2><p>任何一家受信任的 CA 都可以签发任意网站的站点证书，浏览器识别起来都是合法的，这些受信任的 CA 可以签发任意网站的站点证书（包括你的站点），而这些受信任的 CA 有很多，如果某 CA 中的某链被攻破，就可以造成由伪造或不正当手段获得网站证书的中间人攻击。</p>\r\n<p>所以 Public-Key-Pins 就是用来告诉浏览器当前网站的证书指纹，包括配置过期时间，在过期时间内，浏览器再次访问这个网站的话就必须验证证书链中的证书指纹，如果跟之前指定的证书指纹不匹配，就无法访问。</p>\r\n<p>如果我们自己更换了证书呢？为了避免这个情况导致的问题，所以我们在配置指纹的时候，至少配置两个，其中包含一个备用指纹。</p>\r\n<p>关于 HTTP Public Key Pinning (HPKP)的介绍，这里非常详细：<a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Public_Key_Pinning\">Public_Key_Pinning</a></p>\r\n<p>Public-Key-Pins 的 HTTP 头的格式如下：   </p>\r\n<pre><code>Public-Key-Pins: pin-sha256=&quot;base64==&quot;; max-age=expireTime [; includeSubDomains][; report-uri=&quot;reportURI&quot;]\r\n</code></pre><ul>\r\n<li>pin-sha256：Base64加密的证书指纹；一般情况至少指定两个，其中包含一个备用指纹。</li><li>max-age：过期时间，秒</li><li>includeSubDomains：是否包含子域</li><li>report-uri：可选参数；验证失败时的上报地址</li></ul>\r\n<p><code>pin-sha256</code>证书指纹这个配置很容器搞错，我们需要指定一个备用指纹，而这个指纹并不是当前域名证书链中的指纹，应该是一个不在当前链中，未来有可能更换到该链的备用指纹。比如我的证书链，根证书是 DigiCert Global Root CA，中间证书是 Encryption Everywhere DV TLS CA - G1，再加上域名证书，我就可以配置中间证书为第一个pin-sha256，而第二个证书配置  Let’s Encrypt 的证书指纹，这样以后如果用  Let’s Encrypt Authority 签发证书，老用户不会受到影响。</p>\r\n<p>这里 <a href=\"https://news.netcraft.com/archives/2016/03/30/http-public-key-pinning-youre-doing-it-wrong.html\">HTTP Public Key Pinning: You’re doing it wrong!</a> 非常详细地介绍了在配置这个配置时会出现的问题。</p>\r\n<h2 id=\"h2-u4F7Fu7528\"><a name=\"使用\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>使用</h2><p>生成<code>pin-sha256</code>指纹，可以通过以下的方式来生成：<br>通过 RSA key 文件生成：</p>\r\n<pre><code>openssl rsa -in my-rsa-key-file.key -outform der -pubout | openssl dgst -sha256 -binary | openssl enc -base64\r\n</code></pre><p>通过 ECC key 文件生成：</p>\r\n<pre><code>openssl ec -in my-ecc-key-file.key -outform der -pubout | openssl dgst -sha256 -binary | openssl enc -base64\r\n</code></pre><p>通过 CSR 文件生成：</p>\r\n<pre><code>openssl req -in my-signing-request.csr -pubkey -noout | openssl pkey -pubin -outform der | openssl dgst -sha256 -binary | openssl enc -base64\r\n</code></pre><p>通过域名之间生成：</p>\r\n<pre><code>openssl s_client -servername www.example.com -connect www.example.com:443 | openssl x509 -pubkey -noout | openssl pkey -pubin -outform der | openssl dgst -sha256 -binary | openssl enc -base64\r\n</code></pre><p>生成证书指纹之后就可以将指纹加入到配置中。</p>\r\n<p>Apache配置：</p>\r\n<pre><code>Header always set Public-Key-Pins &quot;pin-sha256=\\&quot;base64+primary==\\&quot;; pin-sha256=\\&quot;base64+backup==\\&quot;; max-age=5184000; includeSubDomains&quot;\r\n</code></pre><p>Nginx配置：</p>\r\n<pre><code>add_header Public-Key-Pins &#39;pin-sha256=&quot;base64+primary==&quot;; pin-sha256=&quot;base64+backup==&quot;; max-age=5184000; includeSubDomains&#39; always;\r\n</code></pre><h1 id=\"h1-dns-caa\"><a name=\"DNS CAA\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>DNS CAA</h1><h2 id=\"h2-dns-caa-\"><a name=\"DNS CAA 是什么\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>DNS CAA 是什么</h2><p>CAA（Certificate Authority Authorization），即证书颁发机构授权。简单地说，就是当域名的 DNS 解析存在 CAA 记录时，则只允许在记录中列出的 CA 机构颁发针对该域名(或子域名)的证书。CAA 记录可以控制单域名 SS L证书的发行，也可以控制通配符证书。</p>\r\n<p>所以设置了 CAA，如果有一天想更换非 CAA 记录中的 CA，要记得把 DNS CAA 的解析记录消掉。否则颁发会失败。</p>\r\n<h2 id=\"h2--caa\"><a name=\"设置 CAA\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>设置 CAA</h2><p>目前国内的云服务中，阿里云支持 CAA 的 DNS 解析，因为我本人用的阿里云，所以其它云服务产商不太了解，在 DNS 解析处看看就知道支持不支持了，如果不支持想添加的话也可以换用支持的 DNS 服务商来解决。</p>\r\n<p>添加 DNS 解析，选择 CAA 类型，填写通配符还是非通配符的，然后就是记录值了。如下图：<br><img src=\"https://www.goozp.com/uploads/2018/02/aliyun_CAA.png\" alt=\"\"></p>\r\n<p>关于记录值，我们可以简单地使用 <a href=\"https://sslmate.com/caa/\">CAA Record Helper</a> 来自动生成，非常方便。将生成的记录值（比如 <code>0 issue &quot;digicert.com&quot;</code> 这样的）填入到 DNS 解析中既可。</p>\r\n<h1 id=\"h1-x-frame-options-\"><a name=\"X-Frame-Options 响应头\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>X-Frame-Options 响应头</h1><p>X-Frame-Options HTTP 响应头是用来给浏览器指示是否允许一个页面在 <code>&lt;frame&gt;</code>，<code>&lt;iframe&gt;</code> 或者 <code>&lt;object&gt;</code> 中展现的标记。通过设置 X-Frame-Options HTTP 响应头，我们可以确保自己的网站内容没有被嵌到别人的网站中去，也从而避免了点击劫持 (clickjacking) 的攻击。</p>\r\n<p>X-Frame-Options 有三个值:</p>\r\n<ul>\r\n<li>DENY<br>  表示该页面不允许在 frame 中展示，即便是在相同域名的页面中嵌套也不允许。</li><li>SAMEORIGIN<br>  表示该页面可以在相同域名页面的 frame 中展示。</li><li>ALLOW-FROM uri<br>  表示该页面可以在指定来源的 frame 中展示。</li></ul>\r\n<p>就是说，如果设置为 DENY，不光在别人的网站 frame 嵌入时会无法加载，在同域名页面中同样会无法加载；如果设置为 SAMEORIGIN，那么页面就可以在同域名页面的 frame 中嵌套。</p>\r\n<p>CSP Level 2 规范中的 frame-ancestors 指令会替代这个非标准的 header。CSP 的 frame-ancestors 会在 Gecko 4.0 中支持，但是并不会被所有浏览器支持。然而 X-Frame-Options 是个已广泛支持的非官方标准，可以和 CSP 结合使用。</p>\r\n<h2 id=\"h2-apache-\"><a name=\"Apache 配置\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Apache 配置</h2><p>要把下面这行添加到“site”的配置中：</p>\r\n<pre><code>Header always append X-Frame-Options SAMEORIGIN\r\n</code></pre><h2 id=\"h2-nginx-\"><a name=\"Nginx 配置\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Nginx 配置</h2><p>在“http”，“server”或者“location”的配置中：</p>\r\n<pre><code>add_header X-Frame-Options SAMEORIGIN;\r\n</code></pre><h1 id=\"h1-x-content-type-options-\"><a name=\"X-Content-Type-Options 响应头\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>X-Content-Type-Options 响应头</h1><p>我们都知道 Content-Type 是用来标识资源类型的。浏览器有个特性，就是当有些资源的 Content-Type 没定义或者定义错了，浏览器会启用 MIME sniffing 来检测该资源的类型然后解析内容并执行。所以攻击者可以利用浏览器这个特性让原本的请求中的资源类型解析为其它类型，所以一般情况下我们都禁止浏览器去检测类型：</p>\r\n<pre><code>X-Content-Type-Options: nosniff\r\n</code></pre><p>在 Nginx 中我们可以加上配置：</p>\r\n<pre><code>add_header X-Content-Type-Options nosniff;\r\n</code></pre><h1 id=\"h1-server-banner\"><a name=\"Server Banner\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Server Banner</h1><p>服务器版本号不应该存在在响应头中，这样容易让攻击者找到弱点。</p>\r\n<p>Nginx 中可以增加以下配置：</p>\r\n<pre><code>server_tokens off;\r\n</code></pre><p>就会去除版本号，比如 nginx/1.10.3 就变成了 ningx.</p>\r\n<h1 id=\"h1-web-framework-information\"><a name=\"Web framework Information\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Web framework Information</h1><p>和服务器版本号一样，我们应该移除一些头部框架信息，比如 X-Powered-By，X-Runtime，X-Version，X-AspNet-Version等。</p>\r\n<p>在 Nginx 中加配置：</p>\r\n<pre><code>proxy_hide_header X-Powered-By;\r\n</code></pre><p>如果是 fastcgi 模式的 PHP 应用则用：</p>\r\n<pre><code>fastcgi_hide_header X-Powered-By;\r\n</code></pre><p>在 PHP 配置 php.ini 中移除版本号，可以设置 expose_php：</p>\r\n<pre><code>expose_php = off\r\n</code></pre><h1 id=\"h1-x-xss-protection-\"><a name=\"X-XSS-Protection 响应头\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>X-XSS-Protection 响应头</h1><p>XSS Protection 显然是用来防止 XSS 攻击的，这个不需要多解释了。</p>\r\n<p>我们只需要知道，现在主流浏览器都支持，并且默认都开启了 XSS 保护。配置这个响应头可以将它关闭，但是如果你没有更加好的防范 XSS 的解决方案，就留着吧。</p>\r\n<p>在 Nginx 中配置启用XSS保护，并在检查到XSS攻击时，停止渲染页面：</p>\r\n<pre><code>add_header X-Xss-Protection &quot;1; mode=block&quot;;\r\n</code></pre><h1 id=\"h1-content-security-policy\"><a name=\"Content Security Policy\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Content Security Policy</h1><p>Content Security Policy（CSP），是用来有效防止 XSS 攻击的，实际上就是提供了一个白名单告诉客户端，哪些外部资源可以加载和执行。通过页面的<code>&lt;meta&gt;</code>标签和 HTTP 的 <code>Content-Security-Policy</code> 头信息的都可以控制 CSP。</p>\r\n<p>关于 CSP，我觉得阮一峰老师的这篇文章挺不错的：<a href=\"http://www.ruanyifeng.com/blog/2016/09/csp.html\">Content Security Policy 入门教程</a>，以及 google developer 的：<a href=\"https://developers.google.com/web/fundamentals/security/csp/?hl=zh-cn\">内容安全政策 </a>。</p>\r\n<p>CSP 的配置需要根据自己的实际情况来配置。这里我就举个例子：</p>\r\n<pre><code>Content-Security-Policy: default-src &#39;self&#39; blob: data:; script-src &#39;self&#39; &#39;unsafe-inline&#39; *.baidu.com; img-src *\r\n</code></pre><p>这里定义所有的资源类型都默认只能从当前域名加载（<code>&#39;self&#39;</code>），然后定义了 <code>blob:</code> 和 <code>data:</code>（实际上如果不是非要加载字体 font 等，使用要谨慎，攻击者很容器利用<code>data: URIs</code>注入攻击） 数据类型也允许加载；<code>script-src</code> 定义了只能从当前域名加载，<code>&#39;unsafe-inline&#39;</code> 是为了使用监听事件，允许加载百度的域名 <code>*.baidu.com</code>（使用百度统计的话）；<code>img-src *</code> 而图片文件可以从任何域名加载。</p>\r\n<p>以上只是随便举一个例子，这一套配置需要自己来定制。而且这个配置挺麻烦的，需要自己慢慢调试，特别是如果引用了很多外部资源，不过在安全上起到很好的效果。</p>\r\n<h1 id=\"h1-cache-control\"><a name=\"Cache Control\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Cache Control</h1><p>Cache Control 表示输出页面的缓存首选项。强烈推荐自定义缓存的偏好，如果不定义 Cache Control，将由浏览器或者代理来选择是否缓存内存，而这种不受控制的选择有可能会导致性能问题或安全问题。</p>\r\n<p>每个资源都可通过 Cache-Control HTTP 标头定义其缓存策略，Cache-Control 指令控制谁在什么条件下可以缓存响应以及可以缓存多久。</p>\r\n<p>Cache-Control 是一个灵活的配置，我们应该根据自己的需求定义最佳 Cache-Control 策略，参考 <a href=\"https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching\">HTTP 缓存</a>。</p>\r\n<h1 id=\"h1-secure-cookies\"><a name=\"Secure Cookies\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Secure Cookies</h1><p>如果站定已经是基于 HTTPS 的，包含敏感信息的 cookie，特别是 session id（在使用 session时，会在客户端存储一个cookie，记录 session id），需要被标记为安全的。<br>例如以下这个设置 cookie 的头：</p>\r\n<pre><code>set-cookie: PHPSESSID=03196cccbf3a8cd7d4fb22214fc5111e; path=/\r\n</code></pre><p>HTTPS 站点加上 secure 标志：</p>\r\n<pre><code>set-cookie: PHPSESSID=03196cccbf3a8cd7d4fb22214fc5111e; path=/; secure;\r\n</code></pre><p>这样只有在 HTTPS 下 cookie 才能生效。另一种防范不安全的 cookie 通过 HTTP 传送的方式是 HSTS，上面已经提到过了，建议同时开启 HSTS 和 secure cookie。</p>\r\n<p>Session cookies 应该标记上 HttpOnly，防止通过 JavaScript 访问，攻击者可以利用这点进行 XSS 攻击窃取 Session cookies。其它的 cookie 可以不这么严格地标记，但是除非有从 JavaScript 去访问的需求，都建议标记上 HttpOnly。<br>例如上面的 set-cookie，我们需要修改成以下的头信息：</p>\r\n<pre><code>set-cookie: PHPSESSID=03196cccbf3a8cd7d4fb22214fc5111e; path=/; secure; HttpOnly\r\n</code></pre><h1 id=\"h1--https-http\"><a name=\"不要混用 HTTPS 和 HTTP\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>不要混用 HTTPS 和 HTTP</h1><p>最后一点，不要 HTTPS 和 HTTP 混用，既然上了 HTTPS，还留 HTTP 做什么呢？为了 SEO 么？</p>\r\n<p>随着时间推移，越早全站 HTTPS 优势只会越明显。</p>\r\n<h1 id=\"h1-u5176u5B83u4F18u5316u64CDu4F5C\"><a name=\"其它优化操作\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>其它优化操作</h1><h2 id=\"h2-sri-subresource-integrity-\"><a name=\"SRI（Subresource Integrity）\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>SRI（Subresource Integrity）</h2><p>子资源完整性（SRI）是允许浏览器检查其获得的资源（例如从 CDN 获得的）是否被篡改的一项安全特性。它通过验证获取文件的哈希值是否和你提供的哈希值一样来判断资源是否被篡改。</p>\r\n<p>SRI 目前的浏览器兼容性不好，而且会增加代码和配置的复杂度。可以参考：<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/Security/%E5%AD%90%E8%B5%84%E6%BA%90%E5%AE%8C%E6%95%B4%E6%80%A7\">Subresource Integrity</a></p>\r\n<h2 id=\"h2-iframe-sandbox\"><a name=\"Iframe Sandbox\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Iframe Sandbox</h2><p>Iframe Sandbox是html5的新属性，是专门为 iframe 定制的，如果你用了 iframe，才建议加上这个属性。可以参考：<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/iframe\">&lt;iframe&gt;</a>。</p>\r\n<h1 id=\"h1-u603Bu7ED3\"><a name=\"总结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>总结</h1><p>基本上以上内容做完就差不多了，SSLLabs 上测试肯定是 A+ 的。先到这里，以后再看看有没有什么要修改或者补充的。</p>\r\n<p><strong>测试站点</strong></p>\r\n<ul>\r\n<li>Qualys SSL Labs：<a href=\"https://www.ssllabs.com/ssltest/\">https://www.ssllabs.com/ssltest/</a></li><li>HTTP Security Report：<a href=\"https://httpsecurityreport.com/\">https://httpsecurityreport.com/</a></li></ul>\r\n<p><strong>本文参考资料</strong></p>\r\n<ul>\r\n<li>MDN web docs HTTP：<a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP\">https://developer.mozilla.org/en-US/docs/Web/HTTP</a></li><li>Speeding up HTTPS with session resumption：<a href=\"https://calendar.perfplanet.com/2014/speeding-up-https-with-session-resumption/\">https://calendar.perfplanet.com/2014/speeding-up-https-with-session-resumption/</a></li><li>HTTP Security Best Practice：<a href=\"https://httpsecurityreport.com/best_practice.html\">https://httpsecurityreport.com/best_practice.html</a></li><li>Guidelines for Setting Security Headers：<a href=\"https://www.veracode.com/blog/2014/03/guidelines-for-setting-security-headers\">https://www.veracode.com/blog/2014/03/guidelines-for-setting-security-headers</a></li><li>HTTP 缓存：<a href=\"https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching\">https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching</a></li></ul>\r\n', '', 0, 'publish', 1, 0, '/article/82.html', 'https://www.goozp.com/uploads/2018/02/HTTPS_Security2.png', 0, 530, '2018-02-25 19:07:54', '2018-02-25 19:07:54', '2018-02-26 10:17:40', NULL);
INSERT INTO `pt_post` VALUES (83, 10, 'article', '入门 Linux 之 从命令行开始', '# 目录操作\r\n## Linux 默认目录结构\r\n以下为 Linux 系统默认的目录结构，加粗部分为比较重要的目录，平时应注意不要误删。\r\n- **/bin**：bin 是 Binary 的缩写，这个目录存放着最经常使用的命令。\r\n- /boot：这里存放的是启动 Linux 时使用的一些核心文件，包括一些连接文件以及镜像文件。\r\n- /dev：dev 是 Device(设备) 的缩写,该目录下存放的是Linux的外部设备，在Linux中访问设备的方式和访问文件的方式是相同的。\r\n- **/etc**：这个目录用来存放所有的系统管理所需要的配置文件和子目录。\r\n- /home：用户的主目录，在Linux中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。\r\n- /lib：这个目录里存放着系统最基本的动态连接共享库，其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库。\r\n- /lost+found：这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。\r\n- /media：linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下。\r\n- /mnt：系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在/mnt/上，然后进入该目录就可以查看光驱里的内容了。\r\n- /opt：这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。\r\n- /proc：这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件，比如可以通过下面的命令来屏蔽主机的ping命令，使别人无法ping你的机器：`echo 1 > /proc/sys/net/ipv4/icmp_echo_ignore_all`\r\n- /root：该目录为系统管理员，也称作超级权限者的用户主目录。\r\n- **/sbin**：s 就是 Super User 的意思，这里存放的是系统管理员使用的系统管理程序。\r\n- /selinux：这个目录是 Redhat/CentOS 所特有的目录，Selinux 是一个安全机制，类似于 windows 的防火墙，但是这套机制比较复杂，这个目录就是存放selinux相关的文件的。\r\n- /srv：该目录存放一些服务启动之后需要提取的数据。\r\n- /sys：这是 linux2.6 内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs。sysfs 文件系统集成了下面 3 种文件系统的信息：针对进程信息的 proc 文件系统、针对设备的 devfs 文件系统以及针对伪终端的 devpts 文件系统。该文件系统是内核设备树的一个直观反映。当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建。\r\n- /tmp：这个目录是用来存放一些临时文件的。\r\n- /usr：这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录。\r\n    - **/usr/bin**：系统用户使用的应用程序。\r\n    - **/usr/sbin**：超级用户使用的比较高级的管理程序和系统守护程序。\r\n    - /usr/src：内核源代码默认的放置目录。\r\n- **/var**：这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。\r\n\r\n## Linux 特殊目录表示\r\n在 Linux 或 Unix 操作系统中，所有的文件和目录都被组织成以一个根节点开始的倒置的树状结构。\r\n- `/`：代表根目录\r\n- `.`：代表当前的目录，也可以使用 `./` 来表示\r\n- `..`：代表上一层目录，也可以 `../` 来代表\r\n- `~`：用户默认登录后进入的就是 `~`，为用户主目录，一般用来存放用户的文件\r\n- `.目录或文件名`：表示这个目录或文件是一个隐藏目录或文件\r\n\r\n## 创建目录\r\n使用 `mkdir` 命令创建目录，如：\r\n```\r\nmkdir $HOME/test\r\n```\r\n`$HOME` 即 `~` 用户主目录，一般用户的主目录在 `/home` 下，比如用户 user 的主目录就是 `/home/user`，可以用 `~user` 表示；而系统管理员的主目录在 `/root`。   \r\n可以 echo `$HOME` 查看当前的 `$HOME` 目录是什么。\r\n\r\n## 切换目录\r\n使用 `cd` 命令切换目录\r\n- 切换到指定目录：`cd $HOME/test`\r\n- 切换到上一级目录：`cd ../` 或 `cd ..`\r\n- 进入根目录`/`：`cd /`\r\n- 进入用户主目录`~`:`cd ~`\r\n\r\n## 移动目录\r\n使用 `mv` 命令移动目录\r\n```\r\nmv $HOME/test /var/tmp\r\n```\r\n前面为要移动的目录位置，后面为要移动到哪个目录下。\r\n\r\n## 删除目录\r\n使用 `rm -rf` 命令删除目录，如：\r\n```\r\nrm -rf /var/tmp/testFolder\r\n```\r\n参数：\r\n- `-f` : 强制删除文件或目录，不进行提醒\r\n- `-r` 或 `-R` ：递归处理，将指定目录下的所有文件与子目录一并处理\r\n- `-i`：删除已有文件或目录之前先询问用户\r\n\r\n## 查看目录下的文件\r\n使用 `ls` 命令查看目录下所有文件和文件夹\r\n- 查看当前目录下的文件和文件夹：`ls`\r\n- 查看指定目录下的文件和文件夹：`ls $HOME/test`\r\n- 查看目录下的文件和文件夹和详情（包括权限，时间等）：`ll`；即 `ls -l` 命令的缩写\r\n\r\n\r\n# 文件操作\r\n## 创建文件\r\n使用 `touch` 命令创建文件\r\n```\r\ntouch $HOME/test/testFile\r\n```\r\n\r\n## 复制文件\r\n使用 `cp` 命令复制文件，如：\r\n```\r\ncp $HOME/test/testFile $HOME/test/testFile2\r\n```\r\n在 test 目录下复制了一份 `testFile`，命名为 `testFile2`。\r\n\r\n## 删除文件\r\n使用 `rm` 命令删除文件, 输入 `y` + 回车确认删除，如：\r\n```\r\nrm $HOME/test/testFile\r\n```\r\n\r\n## 查看文件内容\r\n使用 cat 命令查看文件内容，如：\r\n```\r\ncat ~/.bash_history\r\n```\r\n`.bash_history` 文件存储执行过的命令的历史记录。\r\n\r\n\r\n# 过滤，管道，重定向\r\n## 过滤\r\n过滤类似于搜索，使用过 `grep` 命令进行过滤。   \r\n例如，过滤出 `/etc/passwd` 文件中包含 `root` 的记录：\r\n```\r\ngrep \'root\' /etc/passwd\r\n```\r\n前面是要过滤出来的内容，后面是要过滤的文件。\r\n\r\n递归地过滤出 `/var/log/` 目录中包含 `linux` 的记录：\r\n```\r\ngrep -r \'linux\' /var/log/\r\n```\r\n即递归查找出 `/var/log/` 目录下所有文件中存在 `linux` 的记录，会列出所有符合的文件及匹配到的内容。\r\n\r\n## 管道\r\nLinux 中管道的作用是将上一个命令的输出作为下一个命令的输入，像 `pipe` 一样将各个命令串联起来执行，管道的操作符是 `|`。\r\n\r\n比如，我们可以将 `cat` 和 `grep` 两个命令用管道组合在一起，\r\n```\r\ncat /etc/passwd | grep \'root\'\r\n```\r\n该命令类似于 `grep \'root\' /etc/passwd`；这里拆成了组合命令，前面部分 `cat /etc/passwd` 查看了 passwd 文件内容，然后将文件内容作为下半部分的输入，在文件内容中过滤出存在“root”的地方。\r\n\r\n又比如，过滤出 `/etc` 目录中名字包含 ssh 的目录（不包括子目录）：\r\n```\r\nls /etc | grep \'ssh\'\r\n```\r\n前半部分列出了 `etc` 目录下的文件和文件夹，将这部分内容作为后半部分的过滤条件，过滤出包含 ssh 的（只是名字包含）。\r\n\r\n## 重定向\r\n可以使用 `>` 或 `<` 将命令的输出重定向到一个文件中，如：\r\n```\r\necho \'Hello World\' > ~/test.txt\r\n```\r\n以上命令，往 `~/test.txt` 文件中写入了“Hello World”。\r\n\r\n\r\n# 运维常用命令\r\n## ping 命令\r\n对 `www.example.com` 发送 4 个 ping 包，检查与其是否联通：\r\n```\r\nping -c 4 www.example.com\r\n```\r\n\r\n## netstat 命令\r\nnetstat 命令用于显示各种网络相关信息，如网络连接，路由表，接口状态等等。\r\n\r\n列出所有处于监听状态的 tcp 端口：\r\n```\r\nnetstat -lt\r\n```\r\n\r\n查看所有的端口信息，包括 PID 和进程名称\r\n```\r\nnetstat -tulpn\r\n```\r\n\r\n## ps 命令\r\nps命令用于报告当前系统的进程状态。\r\n例如，过滤得到当前系统中的 ssh 进程信息：\r\n```\r\nps -aux | grep \'ssh\'\r\n```\r\n\r\n# 总结\r\n## 参考资料\r\n- Linux 系统目录结构：[http://www.runoob.com/linux/linux-system-contents.html](http://www.runoob.com/linux/linux-system-contents.html)\r\n- Linux 基础入门：[https://cloud.tencent.com/developer/labs/lab/10000](https://cloud.tencent.com/developer/labs/lab/10000)', '<h1 id=\"h1-u76EEu5F55u64CDu4F5C\"><a name=\"目录操作\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>目录操作</h1><h2 id=\"h2-linux-\"><a name=\"Linux 默认目录结构\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Linux 默认目录结构</h2><p>以下为 Linux 系统默认的目录结构，加粗部分为比较重要的目录，平时应注意不要误删。</p>\r\n<ul>\r\n<li><strong>/bin</strong>：bin 是 Binary 的缩写，这个目录存放着最经常使用的命令。</li><li>/boot：这里存放的是启动 Linux 时使用的一些核心文件，包括一些连接文件以及镜像文件。</li><li>/dev：dev 是 Device(设备) 的缩写,该目录下存放的是Linux的外部设备，在Linux中访问设备的方式和访问文件的方式是相同的。</li><li><strong>/etc</strong>：这个目录用来存放所有的系统管理所需要的配置文件和子目录。</li><li>/home：用户的主目录，在Linux中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。</li><li>/lib：这个目录里存放着系统最基本的动态连接共享库，其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库。</li><li>/lost+found：这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。</li><li>/media：linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下。</li><li>/mnt：系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在/mnt/上，然后进入该目录就可以查看光驱里的内容了。</li><li>/opt：这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。</li><li>/proc：这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件，比如可以通过下面的命令来屏蔽主机的ping命令，使别人无法ping你的机器：<code>echo 1 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all</code></li><li>/root：该目录为系统管理员，也称作超级权限者的用户主目录。</li><li><strong>/sbin</strong>：s 就是 Super User 的意思，这里存放的是系统管理员使用的系统管理程序。</li><li>/selinux：这个目录是 Redhat/CentOS 所特有的目录，Selinux 是一个安全机制，类似于 windows 的防火墙，但是这套机制比较复杂，这个目录就是存放selinux相关的文件的。</li><li>/srv：该目录存放一些服务启动之后需要提取的数据。</li><li>/sys：这是 linux2.6 内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs。sysfs 文件系统集成了下面 3 种文件系统的信息：针对进程信息的 proc 文件系统、针对设备的 devfs 文件系统以及针对伪终端的 devpts 文件系统。该文件系统是内核设备树的一个直观反映。当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建。</li><li>/tmp：这个目录是用来存放一些临时文件的。</li><li>/usr：这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录。<ul>\r\n<li><strong>/usr/bin</strong>：系统用户使用的应用程序。</li><li><strong>/usr/sbin</strong>：超级用户使用的比较高级的管理程序和系统守护程序。</li><li>/usr/src：内核源代码默认的放置目录。</li></ul>\r\n</li><li><strong>/var</strong>：这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。</li></ul>\r\n<h2 id=\"h2-linux-\"><a name=\"Linux 特殊目录表示\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Linux 特殊目录表示</h2><p>在 Linux 或 Unix 操作系统中，所有的文件和目录都被组织成以一个根节点开始的倒置的树状结构。</p>\r\n<ul>\r\n<li><code>/</code>：代表根目录</li><li><code>.</code>：代表当前的目录，也可以使用 <code>./</code> 来表示</li><li><code>..</code>：代表上一层目录，也可以 <code>../</code> 来代表</li><li><code>~</code>：用户默认登录后进入的就是 <code>~</code>，为用户主目录，一般用来存放用户的文件</li><li><code>.目录或文件名</code>：表示这个目录或文件是一个隐藏目录或文件</li></ul>\r\n<h2 id=\"h2-u521Bu5EFAu76EEu5F55\"><a name=\"创建目录\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>创建目录</h2><p>使用 <code>mkdir</code> 命令创建目录，如：</p>\r\n<pre><code>mkdir $HOME/test\r\n</code></pre><p><code>$HOME</code> 即 <code>~</code> 用户主目录，一般用户的主目录在 <code>/home</code> 下，比如用户 user 的主目录就是 <code>/home/user</code>，可以用 <code>~user</code> 表示；而系统管理员的主目录在 <code>/root</code>。<br>可以 echo <code>$HOME</code> 查看当前的 <code>$HOME</code> 目录是什么。</p>\r\n<h2 id=\"h2-u5207u6362u76EEu5F55\"><a name=\"切换目录\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>切换目录</h2><p>使用 <code>cd</code> 命令切换目录</p>\r\n<ul>\r\n<li>切换到指定目录：<code>cd $HOME/test</code></li><li>切换到上一级目录：<code>cd ../</code> 或 <code>cd ..</code></li><li>进入根目录<code>/</code>：<code>cd /</code></li><li>进入用户主目录<code>~</code>:<code>cd ~</code></li></ul>\r\n<h2 id=\"h2-u79FBu52A8u76EEu5F55\"><a name=\"移动目录\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>移动目录</h2><p>使用 <code>mv</code> 命令移动目录</p>\r\n<pre><code>mv $HOME/test /var/tmp\r\n</code></pre><p>前面为要移动的目录位置，后面为要移动到哪个目录下。</p>\r\n<h2 id=\"h2-u5220u9664u76EEu5F55\"><a name=\"删除目录\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>删除目录</h2><p>使用 <code>rm -rf</code> 命令删除目录，如：</p>\r\n<pre><code>rm -rf /var/tmp/testFolder\r\n</code></pre><p>参数：</p>\r\n<ul>\r\n<li><code>-f</code> : 强制删除文件或目录，不进行提醒</li><li><code>-r</code> 或 <code>-R</code> ：递归处理，将指定目录下的所有文件与子目录一并处理</li><li><code>-i</code>：删除已有文件或目录之前先询问用户</li></ul>\r\n<h2 id=\"h2-u67E5u770Bu76EEu5F55u4E0Bu7684u6587u4EF6\"><a name=\"查看目录下的文件\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>查看目录下的文件</h2><p>使用 <code>ls</code> 命令查看目录下所有文件和文件夹</p>\r\n<ul>\r\n<li>查看当前目录下的文件和文件夹：<code>ls</code></li><li>查看指定目录下的文件和文件夹：<code>ls $HOME/test</code></li><li>查看目录下的文件和文件夹和详情（包括权限，时间等）：<code>ll</code>；即 <code>ls -l</code> 命令的缩写</li></ul>\r\n<h1 id=\"h1-u6587u4EF6u64CDu4F5C\"><a name=\"文件操作\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>文件操作</h1><h2 id=\"h2-u521Bu5EFAu6587u4EF6\"><a name=\"创建文件\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>创建文件</h2><p>使用 <code>touch</code> 命令创建文件</p>\r\n<pre><code>touch $HOME/test/testFile\r\n</code></pre><h2 id=\"h2-u590Du5236u6587u4EF6\"><a name=\"复制文件\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>复制文件</h2><p>使用 <code>cp</code> 命令复制文件，如：</p>\r\n<pre><code>cp $HOME/test/testFile $HOME/test/testFile2\r\n</code></pre><p>在 test 目录下复制了一份 <code>testFile</code>，命名为 <code>testFile2</code>。</p>\r\n<h2 id=\"h2-u5220u9664u6587u4EF6\"><a name=\"删除文件\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>删除文件</h2><p>使用 <code>rm</code> 命令删除文件, 输入 <code>y</code> + 回车确认删除，如：</p>\r\n<pre><code>rm $HOME/test/testFile\r\n</code></pre><h2 id=\"h2-u67E5u770Bu6587u4EF6u5185u5BB9\"><a name=\"查看文件内容\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>查看文件内容</h2><p>使用 cat 命令查看文件内容，如：</p>\r\n<pre><code>cat ~/.bash_history\r\n</code></pre><p><code>.bash_history</code> 文件存储执行过的命令的历史记录。</p>\r\n<h1 id=\"h1--\"><a name=\"过滤，管道，重定向\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>过滤，管道，重定向</h1><h2 id=\"h2-u8FC7u6EE4\"><a name=\"过滤\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>过滤</h2><p>过滤类似于搜索，使用过 <code>grep</code> 命令进行过滤。<br>例如，过滤出 <code>/etc/passwd</code> 文件中包含 <code>root</code> 的记录：</p>\r\n<pre><code>grep &#39;root&#39; /etc/passwd\r\n</code></pre><p>前面是要过滤出来的内容，后面是要过滤的文件。</p>\r\n<p>递归地过滤出 <code>/var/log/</code> 目录中包含 <code>linux</code> 的记录：</p>\r\n<pre><code>grep -r &#39;linux&#39; /var/log/\r\n</code></pre><p>即递归查找出 <code>/var/log/</code> 目录下所有文件中存在 <code>linux</code> 的记录，会列出所有符合的文件及匹配到的内容。</p>\r\n<h2 id=\"h2-u7BA1u9053\"><a name=\"管道\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>管道</h2><p>Linux 中管道的作用是将上一个命令的输出作为下一个命令的输入，像 <code>pipe</code> 一样将各个命令串联起来执行，管道的操作符是 <code>|</code>。</p>\r\n<p>比如，我们可以将 <code>cat</code> 和 <code>grep</code> 两个命令用管道组合在一起，</p>\r\n<pre><code>cat /etc/passwd | grep &#39;root&#39;\r\n</code></pre><p>该命令类似于 <code>grep &#39;root&#39; /etc/passwd</code>；这里拆成了组合命令，前面部分 <code>cat /etc/passwd</code> 查看了 passwd 文件内容，然后将文件内容作为下半部分的输入，在文件内容中过滤出存在“root”的地方。</p>\r\n<p>又比如，过滤出 <code>/etc</code> 目录中名字包含 ssh 的目录（不包括子目录）：</p>\r\n<pre><code>ls /etc | grep &#39;ssh&#39;\r\n</code></pre><p>前半部分列出了 <code>etc</code> 目录下的文件和文件夹，将这部分内容作为后半部分的过滤条件，过滤出包含 ssh 的（只是名字包含）。</p>\r\n<h2 id=\"h2-u91CDu5B9Au5411\"><a name=\"重定向\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>重定向</h2><p>可以使用 <code>&gt;</code> 或 <code>&lt;</code> 将命令的输出重定向到一个文件中，如：</p>\r\n<pre><code>echo &#39;Hello World&#39; &gt; ~/test.txt\r\n</code></pre><p>以上命令，往 <code>~/test.txt</code> 文件中写入了“Hello World”。</p>\r\n<h1 id=\"h1-u8FD0u7EF4u5E38u7528u547Du4EE4\"><a name=\"运维常用命令\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>运维常用命令</h1><h2 id=\"h2-ping-\"><a name=\"ping 命令\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>ping 命令</h2><p>对 <code>www.example.com</code> 发送 4 个 ping 包，检查与其是否联通：</p>\r\n<pre><code>ping -c 4 www.example.com\r\n</code></pre><h2 id=\"h2-netstat-\"><a name=\"netstat 命令\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>netstat 命令</h2><p>netstat 命令用于显示各种网络相关信息，如网络连接，路由表，接口状态等等。</p>\r\n<p>列出所有处于监听状态的 tcp 端口：</p>\r\n<pre><code>netstat -lt\r\n</code></pre><p>查看所有的端口信息，包括 PID 和进程名称</p>\r\n<pre><code>netstat -tulpn\r\n</code></pre><h2 id=\"h2-ps-\"><a name=\"ps 命令\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>ps 命令</h2><p>ps命令用于报告当前系统的进程状态。<br>例如，过滤得到当前系统中的 ssh 进程信息：</p>\r\n<pre><code>ps -aux | grep &#39;ssh&#39;\r\n</code></pre><h1 id=\"h1-u603Bu7ED3\"><a name=\"总结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>总结</h1><h2 id=\"h2-u53C2u8003u8D44u6599\"><a name=\"参考资料\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>参考资料</h2><ul>\r\n<li>Linux 系统目录结构：<a href=\"http://www.runoob.com/linux/linux-system-contents.html\">http://www.runoob.com/linux/linux-system-contents.html</a></li><li>Linux 基础入门：<a href=\"https://cloud.tencent.com/developer/labs/lab/10000\">https://cloud.tencent.com/developer/labs/lab/10000</a></li></ul>\r\n', '', 0, 'publish', 1, 0, '/article/83.html', '', 0, 200, '2018-03-08 15:13:18', '2018-03-08 15:13:18', '2018-03-08 15:21:24', NULL);
INSERT INTO `pt_post` VALUES (84, 10, 'article', '阶段性总结——回顾两年匆匆技术路', '本文是对过去两年转行进入 IT 行业的回顾总结。\r\n# 本猿的前世今生\r\n## 入行\r\n从事 IT 行业两年多，现在让我想一下大学四年在环境科学都学了什么，我已经不记得都学了什么了。反而让我想一下，我这两年多都干了什么，却是历历在目，感觉比大学四年学得都多。步入程序猿的行列似乎并没有什么不适，相反我还挺适应的，可能毕竟兴趣点在这里。当然，我不是一个甘于搬砖的码农。\r\n\r\n两年多，我要追回别人六年多的知识积累，有时候觉得还是蛮累的，你在进步的时候别人也在进步。\r\n\r\n## 我聪明吗？\r\n我肯定不是天才，我也不处于食物链的顶级，但是我感觉我以前还挺聪明的，现在越来越笨了。主要是感觉记忆力越来越差了，从高中后半截开始，记忆力就开始下降，也许是因为那段时间疯狂扁桃体发炎+发烧吧，状态日益下滑，比如英语单词记不住了。其实记忆力是聪明的资本，好的记忆力可以提升各种效率，事半功倍。过段时间调整一下状态，多锻炼一下身体，说不定能回春？\r\n\r\n虽说如此，但是我发现我仍然可以发挥我的作用，我的脑袋有时还是很清醒的，我会思考，我可以思考到别人思考不到的范围。也许是因为平时话少的原因，旁观者清，别人义愤填膺的时候我往往在思考下一步了；所以有的时候当我也深陷争吵之中时，我也无法保持合理的理性思考；环境对人的影响也是很大的。当然我觉得我的逻辑，我的“世界观”还是在线的，不然思考再多也没用。因此在人群中，有时候我发现我有很大的优势，而我的劣势，是缺乏侃大山的能力，去让别人知道我的想法，有时候我真的可以点醒梦中人。\r\n\r\n记不住就多写写，不是天才就多动手。于是我开始记录，任何对我有用，以后有可能对我有用，我很有可能会返回来查阅的知识点，我都记录下来；以及梳理新学习到的技术，各个知识点，各个条条框框；我也开始分享给他人我的学习笔记，希望对别人也有所帮助。一路下来，非常有用，为此我还为我的博客开设专题这个功能，我可以快速定位到我要查阅的笔记。久而久之，你会发现，翻笔记翻久了，也就不用翻了，自然就记住了。有时候，接触的知识点多了，感觉越来越不够时间来总结笔记，写文章了。\r\n\r\n## 目前的我\r\n虽然一直提醒自己不要浮躁，但是还是有点浮躁。对新技术非常感兴趣，就想玩新技术，但是老的技术或者知识，还没打牢。基础不牢，地动山摇。还是要沉下心来，基础牢固，做什么都简单。\r\n\r\n# 这两年都学了什么\r\n接下来回顾一下两年来都学了什么吧。\r\n## 关于 PHP\r\n其实一开始学习 PHP，从 PHP 切入编程，有点误打误撞。一开始学的时候，我还是很懵的，因为我对编程没有任何概念，大学的时候也没学 C 语言，因为大学时的电脑课也不学这些。\r\n\r\n梳理一下我目前为止做下来的三份工作：\r\n1. 其实第一份工作，算是对之前学习的一个总结，从此知道了我们究竟拿 PHP 来做什么。显然 ECShop 的二次开发过于简单，对我来说，提高不大，待久了浪费时间了，所以第一份工作待的时间不长。这份工作，我学到的是，PHP 基础的巩固，和形成基础的编程思想，而且也不会后悔走得早，因为我现在可以非常自信的说我比当时那些计算机专业还工作了四年的同事强（当然只是那边的同事）。\r\n2. 第二份工作，主要是独立开发 APP 后台，一开始是新鲜的，开发 APP 后台，一个人！还要设计数据库。原来 PHP 还能做这些事情！又开了眼界，第二份工作，让我了解了 APP 的 “世界观”。当然，现在回想起来，当时的工作是有很大的不足的。\r\n3. 第三份工作，其实回想起来，公司上的项目，对我来说没什么提高。但是这段时间我的提高是巨大的，主要在于我会不断地抽时间出来，学习学习再学习。真正让我对编程开始有了初步的世界观，还是在这最近一年多，接触了很多很多，涵盖范围也很广。\r\n\r\n经验可以推翻以前的知识认知。举个例子，比如一年前我去查“负载均衡”是什么，喔百度说是这样的这样的，确实说的没错是这样的。但是负载均衡就这样而已了吗，一年之后再去回顾，经验告诉你，其实是那样的，之前的理念被自己推翻，但是之前查到的概念确实是没错的，确实是那样的，但是你有了新的认识，更准确，更富有经验的认识。当然，也可能在将来再被自己推翻。这就是一个成长的过程，所以说老程序员是存在经验上的优势的，或者说架构师是如何成长起来的，就是这么成长起来的。\r\n\r\n## 由 PHP 延伸开来\r\nPHP 只是一门语言。很开心，由 PHP 延伸开来的生态，我都不断在接触和学习。\r\n\r\n这些 PHP 框架：\r\n- ThinkPHP：TP是简单粗暴的，也是入门首选。但是入门之后，还是希望能够摆脱 TP 的束缚， 不然会深受其害。当然，当我们要快速实现需求的时候，TP 还是很好的选择。\r\n- Phalcon：虽然公司没怎么用，国内用得很少，但是我还是自己学习了这个框架。包括博客系统，我也用 Phalcon 写了一个开源博客系统。我觉得 Phalcon 是十分优秀的。\r\n- Workerman：其实一开始是没有打算用 Workerman的，而是想学习 Swoole，阴差阳错地，用上了 Workerman，觉得还挺好用的，确实挺不错也很稳定。\r\n\r\n数据库相关：\r\n- MySQL：MySQL 不用说了，非常流行。其实在我一开始学习的时候，还有很多 NoSQL 的声音，包括很多 MongoDB 的支持者有很多。但是发现后来这个热潮已经逐渐消退了，现在见得比较多的就是 Node.js+MongoDB 这个组合。关系型数据库在未来一段时间还会是主导，不过现在已经开始讨论 NewSQL 了。\r\n- Redis：Redis 估计是必学必会的了，Redis 的应用现在很多，现在我对 Redis 还不熟，以后要加强。\r\n- Memcache：Memcache 用得很少，很多时候会被 Redis 取代。\r\n\r\nWeb Server：\r\n- Apache：Apache 是我一开始搭建 PHP 环境的时候最先了解的，但是后面就逐渐倾向于 Nginx 了。\r\n- Nginx：对 Nginx 有好感还是之前有一次跟 Apache 比较了一下内存的占用。后来就主要在玩 Nginx 了，配置什么的也自己研究了一些。\r\n\r\n## 其它方面\r\n- Git：不会 Git 都不好意思说自己是一个程序猿了。\r\n- Go 语言：这段时间抽空学习了一下 Go 语言，可以说非常感兴趣，现在就学了个皮毛，之后会继续学习。\r\n- Docker：可以说，17年下半年学的最有意思的一个就是 Docker 了，抱着要与时俱进的态度，而且确实需要用到这么一项非常方便的工具来帮助我的开发，就把 Docker 给学习了。现在有了这项技能，开发效率也有所提高。\r\n- 通讯：因为之前公司涉及到通讯这一块，关于数据传输，现在也有了一些 PHP 去对接 TCP 连接的经验，以及一些抓包分析的技巧。\r\n\r\n# 未来的我\r\n## 目标是什么\r\n这段时间找工作，可以明显地感觉到，PHP 的岗位越来越少了，特别是大公司，只放出来一些比较高级的职位，而低中级职位很少了，很多公司的 PHP，特别是中大型的公司的 PHP，感觉都在转型，Go 是一个明显的方向，再一个就是 Java。虽说如此，PHP 还是不能放弃，在许多场景 PHP 还是有用武之地，而且在创业公司 PHP 还是优势很明显的。所以我会继续深入 PHP 的研究，一门语言要研究到位，基础就要打牢，基础打牢了，切换语言也是很快的了，而且在学习 PHP 的同时，接触到的数据库，服务器等等相关的内容，都是有用的；除此之外的一个目标，就是数据结构和算法，这个是不能再拖了，要慢慢地补起来，现在只能说是懂了一点点皮毛；再一个，就是学习 Go 语言，并且做些项目，现在初步的想法是准备用 Go 来搭建微信公众号，小程序的后台做个小项目。\r\n\r\n## 重点学习什么\r\n列一下未来一两年会着重学习的任务：\r\n- 数据结构和算法：这个就不再说了。\r\n- HTTP，TCP， UDP 等通讯：把网络通讯这一块啃一下。\r\n- Linux：要熟练 Linux，现在只能说是熟悉 Linux 的一些命令，这是不够的，有条件还要考虑能够在 Linux 环境下做开发。\r\n- Yii框架：经过这几次面试，我觉得我需要重新审视一下 Yii 这款框架，其实一开始学 Yii 学得很早，所以总会把它放在和 TP 一个阵营，其实 Yii 还是非常不错的，生态很好，虽然没有 laravel 那么热门，但是相对来说 Yii 上手可能会更流畅，性能也还可以，是一个折中的很好的选择，可能很多公司选择这个框架就是因为这些原因。学起来。\r\n- PHPUnit：要开始接触单元测试相关的内容了，不过这部分应该不难。\r\n- Swoole：Swoole 是早就想学的了，早机会快点学起来，因为一开始可能学得不会那么深入，目前经验也不够，但是越早学能够更有利于沉淀。\r\n- Golang：都说学了 Go 还学什么 Swoole，但是这是两种解决方案，懂得越多越好，技多不压身。\r\n- 设计模式：这一块主要了解各设计模式的原理，以及 PHP 中的实现；Go 还是比较特别的，所以 Go 的实现，我先放一放，了解了再思考一下。\r\n- 并发：并发这一块已经成为一道坎，因为没有并发方面的经验，错过了一家比较不错的公司，挺可惜。', '<p>本文是对过去两年转行进入 IT 行业的回顾总结。</p>\r\n<h1 id=\"h1-u672Cu733Fu7684u524Du4E16u4ECAu751F\"><a name=\"本猿的前世今生\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>本猿的前世今生</h1><h2 id=\"h2-u5165u884C\"><a name=\"入行\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>入行</h2><p>从事 IT 行业两年多，现在让我想一下大学四年在环境科学都学了什么，我已经不记得都学了什么了。反而让我想一下，我这两年多都干了什么，却是历历在目，感觉比大学四年学得都多。步入程序猿的行列似乎并没有什么不适，相反我还挺适应的，可能毕竟兴趣点在这里。当然，我不是一个甘于搬砖的码农。</p>\r\n<p>两年多，我要追回别人六年多的知识积累，有时候觉得还是蛮累的，你在进步的时候别人也在进步。</p>\r\n<h2 id=\"h2--\"><a name=\"我聪明吗？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>我聪明吗？</h2><p>我肯定不是天才，我也不处于食物链的顶级，但是我感觉我以前还挺聪明的，现在越来越笨了。主要是感觉记忆力越来越差了，从高中后半截开始，记忆力就开始下降，也许是因为那段时间疯狂扁桃体发炎+发烧吧，状态日益下滑，比如英语单词记不住了。其实记忆力是聪明的资本，好的记忆力可以提升各种效率，事半功倍。过段时间调整一下状态，多锻炼一下身体，说不定能回春？</p>\r\n<p>虽说如此，但是我发现我仍然可以发挥我的作用，我的脑袋有时还是很清醒的，我会思考，我可以思考到别人思考不到的范围。也许是因为平时话少的原因，旁观者清，别人义愤填膺的时候我往往在思考下一步了；所以有的时候当我也深陷争吵之中时，我也无法保持合理的理性思考；环境对人的影响也是很大的。当然我觉得我的逻辑，我的“世界观”还是在线的，不然思考再多也没用。因此在人群中，有时候我发现我有很大的优势，而我的劣势，是缺乏侃大山的能力，去让别人知道我的想法，有时候我真的可以点醒梦中人。</p>\r\n<p>记不住就多写写，不是天才就多动手。于是我开始记录，任何对我有用，以后有可能对我有用，我很有可能会返回来查阅的知识点，我都记录下来；以及梳理新学习到的技术，各个知识点，各个条条框框；我也开始分享给他人我的学习笔记，希望对别人也有所帮助。一路下来，非常有用，为此我还为我的博客开设专题这个功能，我可以快速定位到我要查阅的笔记。久而久之，你会发现，翻笔记翻久了，也就不用翻了，自然就记住了。有时候，接触的知识点多了，感觉越来越不够时间来总结笔记，写文章了。</p>\r\n<h2 id=\"h2-u76EEu524Du7684u6211\"><a name=\"目前的我\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>目前的我</h2><p>虽然一直提醒自己不要浮躁，但是还是有点浮躁。对新技术非常感兴趣，就想玩新技术，但是老的技术或者知识，还没打牢。基础不牢，地动山摇。还是要沉下心来，基础牢固，做什么都简单。</p>\r\n<h1 id=\"h1-u8FD9u4E24u5E74u90FDu5B66u4E86u4EC0u4E48\"><a name=\"这两年都学了什么\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>这两年都学了什么</h1><p>接下来回顾一下两年来都学了什么吧。</p>\r\n<h2 id=\"h2--php\"><a name=\"关于 PHP\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>关于 PHP</h2><p>其实一开始学习 PHP，从 PHP 切入编程，有点误打误撞。一开始学的时候，我还是很懵的，因为我对编程没有任何概念，大学的时候也没学 C 语言，因为大学时的电脑课也不学这些。</p>\r\n<p>梳理一下我目前为止做下来的三份工作：</p>\r\n<ol>\r\n<li>其实第一份工作，算是对之前学习的一个总结，从此知道了我们究竟拿 PHP 来做什么。显然 ECShop 的二次开发过于简单，对我来说，提高不大，待久了浪费时间了，所以第一份工作待的时间不长。这份工作，我学到的是，PHP 基础的巩固，和形成基础的编程思想，而且也不会后悔走得早，因为我现在可以非常自信的说我比当时那些计算机专业还工作了四年的同事强（当然只是那边的同事）。</li><li>第二份工作，主要是独立开发 APP 后台，一开始是新鲜的，开发 APP 后台，一个人！还要设计数据库。原来 PHP 还能做这些事情！又开了眼界，第二份工作，让我了解了 APP 的 “世界观”。当然，现在回想起来，当时的工作是有很大的不足的。</li><li>第三份工作，其实回想起来，公司上的项目，对我来说没什么提高。但是这段时间我的提高是巨大的，主要在于我会不断地抽时间出来，学习学习再学习。真正让我对编程开始有了初步的世界观，还是在这最近一年多，接触了很多很多，涵盖范围也很广。</li></ol>\r\n<p>经验可以推翻以前的知识认知。举个例子，比如一年前我去查“负载均衡”是什么，喔百度说是这样的这样的，确实说的没错是这样的。但是负载均衡就这样而已了吗，一年之后再去回顾，经验告诉你，其实是那样的，之前的理念被自己推翻，但是之前查到的概念确实是没错的，确实是那样的，但是你有了新的认识，更准确，更富有经验的认识。当然，也可能在将来再被自己推翻。这就是一个成长的过程，所以说老程序员是存在经验上的优势的，或者说架构师是如何成长起来的，就是这么成长起来的。</p>\r\n<h2 id=\"h2--php-\"><a name=\"由 PHP 延伸开来\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>由 PHP 延伸开来</h2><p>PHP 只是一门语言。很开心，由 PHP 延伸开来的生态，我都不断在接触和学习。</p>\r\n<p>这些 PHP 框架：</p>\r\n<ul>\r\n<li>ThinkPHP：TP是简单粗暴的，也是入门首选。但是入门之后，还是希望能够摆脱 TP 的束缚， 不然会深受其害。当然，当我们要快速实现需求的时候，TP 还是很好的选择。</li><li>Phalcon：虽然公司没怎么用，国内用得很少，但是我还是自己学习了这个框架。包括博客系统，我也用 Phalcon 写了一个开源博客系统。我觉得 Phalcon 是十分优秀的。</li><li>Workerman：其实一开始是没有打算用 Workerman的，而是想学习 Swoole，阴差阳错地，用上了 Workerman，觉得还挺好用的，确实挺不错也很稳定。</li></ul>\r\n<p>数据库相关：</p>\r\n<ul>\r\n<li>MySQL：MySQL 不用说了，非常流行。其实在我一开始学习的时候，还有很多 NoSQL 的声音，包括很多 MongoDB 的支持者有很多。但是发现后来这个热潮已经逐渐消退了，现在见得比较多的就是 Node.js+MongoDB 这个组合。关系型数据库在未来一段时间还会是主导，不过现在已经开始讨论 NewSQL 了。</li><li>Redis：Redis 估计是必学必会的了，Redis 的应用现在很多，现在我对 Redis 还不熟，以后要加强。</li><li>Memcache：Memcache 用得很少，很多时候会被 Redis 取代。</li></ul>\r\n<p>Web Server：</p>\r\n<ul>\r\n<li>Apache：Apache 是我一开始搭建 PHP 环境的时候最先了解的，但是后面就逐渐倾向于 Nginx 了。</li><li>Nginx：对 Nginx 有好感还是之前有一次跟 Apache 比较了一下内存的占用。后来就主要在玩 Nginx 了，配置什么的也自己研究了一些。</li></ul>\r\n<h2 id=\"h2-u5176u5B83u65B9u9762\"><a name=\"其它方面\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>其它方面</h2><ul>\r\n<li>Git：不会 Git 都不好意思说自己是一个程序猿了。</li><li>Go 语言：这段时间抽空学习了一下 Go 语言，可以说非常感兴趣，现在就学了个皮毛，之后会继续学习。</li><li>Docker：可以说，17年下半年学的最有意思的一个就是 Docker 了，抱着要与时俱进的态度，而且确实需要用到这么一项非常方便的工具来帮助我的开发，就把 Docker 给学习了。现在有了这项技能，开发效率也有所提高。</li><li>通讯：因为之前公司涉及到通讯这一块，关于数据传输，现在也有了一些 PHP 去对接 TCP 连接的经验，以及一些抓包分析的技巧。</li></ul>\r\n<h1 id=\"h1-u672Au6765u7684u6211\"><a name=\"未来的我\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>未来的我</h1><h2 id=\"h2-u76EEu6807u662Fu4EC0u4E48\"><a name=\"目标是什么\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>目标是什么</h2><p>这段时间找工作，可以明显地感觉到，PHP 的岗位越来越少了，特别是大公司，只放出来一些比较高级的职位，而低中级职位很少了，很多公司的 PHP，特别是中大型的公司的 PHP，感觉都在转型，Go 是一个明显的方向，再一个就是 Java。虽说如此，PHP 还是不能放弃，在许多场景 PHP 还是有用武之地，而且在创业公司 PHP 还是优势很明显的。所以我会继续深入 PHP 的研究，一门语言要研究到位，基础就要打牢，基础打牢了，切换语言也是很快的了，而且在学习 PHP 的同时，接触到的数据库，服务器等等相关的内容，都是有用的；除此之外的一个目标，就是数据结构和算法，这个是不能再拖了，要慢慢地补起来，现在只能说是懂了一点点皮毛；再一个，就是学习 Go 语言，并且做些项目，现在初步的想法是准备用 Go 来搭建微信公众号，小程序的后台做个小项目。</p>\r\n<h2 id=\"h2-u91CDu70B9u5B66u4E60u4EC0u4E48\"><a name=\"重点学习什么\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>重点学习什么</h2><p>列一下未来一两年会着重学习的任务：</p>\r\n<ul>\r\n<li>数据结构和算法：这个就不再说了。</li><li>HTTP，TCP， UDP 等通讯：把网络通讯这一块啃一下。</li><li>Linux：要熟练 Linux，现在只能说是熟悉 Linux 的一些命令，这是不够的，有条件还要考虑能够在 Linux 环境下做开发。</li><li>Yii框架：经过这几次面试，我觉得我需要重新审视一下 Yii 这款框架，其实一开始学 Yii 学得很早，所以总会把它放在和 TP 一个阵营，其实 Yii 还是非常不错的，生态很好，虽然没有 laravel 那么热门，但是相对来说 Yii 上手可能会更流畅，性能也还可以，是一个折中的很好的选择，可能很多公司选择这个框架就是因为这些原因。学起来。</li><li>PHPUnit：要开始接触单元测试相关的内容了，不过这部分应该不难。</li><li>Swoole：Swoole 是早就想学的了，早机会快点学起来，因为一开始可能学得不会那么深入，目前经验也不够，但是越早学能够更有利于沉淀。</li><li>Golang：都说学了 Go 还学什么 Swoole，但是这是两种解决方案，懂得越多越好，技多不压身。</li><li>设计模式：这一块主要了解各设计模式的原理，以及 PHP 中的实现；Go 还是比较特别的，所以 Go 的实现，我先放一放，了解了再思考一下。</li><li>并发：并发这一块已经成为一道坎，因为没有并发方面的经验，错过了一家比较不错的公司，挺可惜。</li></ul>\r\n', '', 0, 'publish', 1, 0, '/article/84.html', '', 0, 226, '2018-03-13 09:02:52', '2018-03-13 09:02:52', '2018-03-13 17:53:41', NULL);
INSERT INTO `pt_post` VALUES (85, 10, 'article', '【更新】PHP 常见面试题', '# 前言\r\n本篇总结我在 PHP 笔试、面试中碰到的比较经典的，常见的面试体，我大概分成了初级、中级、高级三个等级，标准比较主观，但时也差不多；目前水平也没达到高级工程师，所以也碰到比较难的题不多，高级题目会比较少。\r\n\r\n我会不断更新这篇面试总结，以后再次找工作了可以翻看，也可以来继续补充。\r\n\r\n关于必考题，面试下来感觉，MySQL优化是必考的。\r\n\r\n# 题目\r\n## 初级\r\n### PHP 里的超全局变量有哪些？\r\n- $GLOBALS\r\n- $_SERVER\r\n- $_GET\r\n- $_POST\r\n- $_FILES\r\n- $_COOKIE\r\n- $_SESSION\r\n- $_REQUEST\r\n- $_ENV\r\n\r\n### require 和 include 的区别\r\n- require 失败会产生 E_COMPILE_ERROR 致命错误，并停止运行下边的代码。\r\n- include 失败只产生 E_WARNING 警告，并继续运行下边的代码。\r\n- 涉及比较严谨的业务逻辑的代码（php脚本）建议用 require ，因为如果引用失败还继续执行的话，有可能对比较重要的数据造成破坏。\r\n- 只用于拼页面相关的代码（前端脚本）可以使用 include 。因为即使引用失败，后续操作也不会破坏数据，最多使页面缺个模块或出现 4xx 错误，也比 5xx 错误更容易让人接受。\r\n- require_once 和 include_once 用于避免重复引入。\r\n\r\n### MySQL 中 char 和 varchar 的区别\r\nchar 的长度是固定的，不管你存储的数据是多少他都是固定的长度；而 varchar 的长度是可变的，不过要在总长度上加1字符用来存储位置。\r\nchar 固定长度所以在处理速度上要比 varchar 快很多，但是对费存储空间；所以对存储不大，但在速度上有要求的可以使用char类型，反之可以用varchar类型。\r\n\r\n### Linux 中如何查看 PHP 进程的状态\r\n- `ps -aux | grep \'php\'` 过滤出包含“PHP”（比如PHP-fpm，视具体情况）的进程\r\n- `strace -p <进程编号>` 查看进程的具体工作内容\r\n\r\n### redis 的存储类型都有哪些\r\n- **string 字符串**\r\n二进制安全的，可以包涵任何数据，jpg图片或序列化对象。string 是 redis 最基本的类型，一个键最大存储 512M。\r\n- **set 集合**\r\nset 是 string 类型的一个无序集合，集合内数据不重复，set 元素最大可以包含(2的32次方-1)个元素；set 是通过 hash table 实现的，所以添加，删除，查找的复杂度都是O(1)\r\n- **hash 哈希表**\r\nhash 是 key-value 映射的结构，它的添加，删除操作平均复杂度是 O(1)\r\n- **list 列表**\r\nlist 就是一个存储 string 类型的双向链表；push 和 pop 的复杂度都是 O(1)，list 会记录链表长度，链表的最大长度是(2的32次方-1)；list 的特性导致它可以做栈，也可以做队列；list有阻塞版本，可以避免轮训查询list队列；\r\n- **sorted set 有序集合**\r\nsorted set 就是 set 的有序集合，添加，删除操作开销都是 O(log(N))；比 list 更消耗内存；\r\n\r\n### HTTP 中 GET 和 POST 的区别\r\n- GET 在浏览器回退时是无害的，而 POST 会再次提交请求。\r\n- GET 产生的 URL 地址可以被 Bookmark，而 POST 不可以。\r\n- GET 请求会被浏览器主动 cache，而 POST 不会，除非手动设置。\r\n- GET 请求只能进行 url 编码，而POST支持多种编码方式。\r\n- GET 请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。\r\n- GET 请求在URL中传送的参数是有长度限制的，而 POST 没有。\r\n- 对参数的数据类型，GET 只接受 ASCII 字符，而 POST 没有限制。\r\n- GET 比 POST 更不安全，因为参数直接暴露在 URL 上，所以不能用来传递敏感信息。\r\n- GET 参数通过URL传递，POST 放在 Request body 中。\r\n\r\n### Cookie 和 Session 的区别和关系\r\n- Cookie 保存在客户端，Session 保存在服务端\r\n- Session 的安全性更高，Cookie 容易被窃取\r\n- Cookie 保存内存的大小有限制，而 Session 没有，但是 Session 会对服务器造成压力\r\n- 默认 Session 存储方式为 file，也可以修改为存储在内存中，或者使用 memcache、redis 等；而 Cookie 设置了过期时间会存储在硬盘里面，如果没有设置过期时间会存储在内存里。\r\n\r\n### Memcache 与 Redis 的主要区别\r\n- Memcache 将数据存在内存中，如果服务器奔溃，数据会丢失；而 Redis 有数据持久化功能。\r\n- Memcache 只能存储 string 的键值对；而 Redis 可以存储 String、List、Set、Sorted set、Hash 类型并且有计算功能。\r\n- Mencache 是支持多线程的，而 Redis 是单线程的。\r\n\r\n### 并发和并行的区别\r\n**并发**：不同代码块交替执行的性能；并发的关键是你有处理多个任务的能力，不一定要同时。\r\n**并行**：不同代码块同时执行的性能；并行的关键是你有同时处理多个任务的能力。\r\n并发是指同时有很多事要做，你可以串行处理也可以并行处理，并发和并行是相关的。\r\n\r\n### 进程与线程的联系\r\n进程是资源（CPU时间、内存等）分配的最小单位；线程是程序执行的最小单位。\r\n\r\n\r\n### 同步与异步，阻塞与非阻塞。\r\n**同步**: 在发出一个功能调用时，在没有得到结果之前，该调用就不返回。所有的操作都做完，才返回给用户。\r\n**异步**: 当一个异步过程调用发出后，调用者不能立刻得到结果，不用等所有操作做完，就响应用户请求。实际处理这个调用的部件在完成后通过状态、通知和回调来通知调用者。\r\n**阻塞**: 阻塞调用是指调用结果返回之前，当前线程会被挂起（线程进入非可执行状态，在这个状态下，cpu不会给线程分配时间片，即线程暂停运行，把计算资源让给其他活动线程，当I/O操作结束，该线程阻塞状态解除，重新变成活动线程，继续争用CPU）。函数只有在得到结果之后才会返回。\r\n**非阻塞**: 非阻塞和阻塞的概念相对应,指在不能立刻得到结果之前,该函数不会阻塞当前线程,而会立刻返回。\r\n**同步与异步**是针对数据访问的方式，程序是主动去询问操作系统数据准备好了么，还是操作系统在数据准备好的时候通知程序。\r\n**阻塞与非阻塞**是针对函数（程序）运行的方式，在IO未就绪时，是等待就绪还是直接返回（执行别的操作）。\r\n\r\n组合 | 同步 | 异步\r\n--- | ---  | ---\r\n阻塞 | 调用者发出某调用之后，如果函数不能立即返回，则挂起所在线程，等待结果  | 调用者发出调用之后（如async_recv），线程挂起，被调用的读操作由系统（或者库）来进行，等待有结果之后，系统（或者库）通过某种机制来通知调用者（在调用者获得结果之前，调用者所在线程一直阻塞。这个看起来和同步阻塞很像，但可以这样理解，同步阻塞相当于调用者A调用了一个函数F，F是在调用者A所在的线程中完成的，而异步阻塞相当于调用者A发出对F的调用，然后A所在线程挂起，而实际F是在另一个线程中完成，然后另一个线程通知给A所在的线程，更准确的是将两个线程分别换成用户进程和内核）\r\n非阻塞 | 调用者发出调用之后，如果有数据可返回则返回，如果没有数据可读，则线程继续向下执行。程序循环执行，不断地发出调用请求获取数据直到获取到数据。  | 调用者发出调用之后（如async_recv），线程继续进行别的操作，被调用的读操作由系统（或者库）来进行，等待有结果之后，系统（或者库）通过某种机制（一般为调用调用者设置的回调函数）来通知调用者\r\n\r\n### 跨域解决方法\r\n\r\n## 中级\r\n### 秒杀功能，如何实现，会出现什么问题？\r\n\r\n### fastcgi 通过端口监听和通过文件监听的区别\r\n\r\n### Nginx + PHP-FPM 的工作原理\r\nCGI 是 Web Server 与后台语言交互的协议，有了这个协议，开发者可以使用任何语言处理 Web Server 发来的请求，动态的生成内容。但 CGI 每处理一个请求都需要 fork 一个全新的进程。\r\nFastCGI，顾名思义为更快的 CGI，它允许在一个进程内处理多个请求，而不是一个请求处理完毕就直接结束进程，性能上有了很大的提高。\r\n至于 FPM (FastCGI Process Manager)，它是 FastCGI 的实现，任何实现了 FastCGI 协议的 Web Server 都能够与之通信。FPM 之于标准的 FastCGI，也提供了一些增强功能。\r\nPHP-FPM 是一个 PHP 进程管理器，包含 master 进程和 worker 进程两种进程：master 进程只有一个，负责监听端口，接收来自 Web Server 的请求，而 worker 进程则一般有多个 (具体数量根据实际需要配置)，每个进程内部都嵌入了一个 PHP 解释器，是 PHP 代码真正执行的地方。\r\n502错误：master 进程根据配置指派特定的 worker 进程进行请求处理，如果没有可用进程，返回错误。 504错误：worker 进程处理请求，如果超时。\r\n参考：https://zhuanlan.zhihu.com/p/20694204\r\n\r\n### PHP 线程安全的原理\r\nWindows下的PHP版本分两种:线程安全版本与非线程安全版本。线程安全通过 PHP-TSRM 线程安全管理器实现。\r\n正常多线程环境下操作公共的资源都是加上互斥锁，而PHP没有选择加锁，因为加锁可能多少会有些性能损耗，PHP的解决方法是为每一个线程都copy一份当前PHP内核所有的公共资源过来，每个线程指向自己的公共资源区，互不影响，各操作各的公共资源。\r\n因为 TSRM 就是让每一个线程都指向自己的这一堆公共资源(数组)，而想在这这一堆公共资源找到你想要的资源就要通过对应的资源id才可以，如果不是这种线程安全版本的，那就不会把这些公共资源都聚合到一堆，直接通过对应的名字获取就好了。\r\n\r\n### PHP 垃圾回收的原理 \r\nhttps://secure.php.net/manual/zh/features.gc.php\r\n\r\n### PHP 各种数据类型实现原理\r\n\r\n### ajax 的实现原理\r\n\r\n### 描述 tcp 的3次握手4次挥手\r\n\r\n### 如何实现单点登录（如何管理session）\r\n\r\n### PHP 代码实现一个双向队列\r\n\r\n### JS 闭包\r\n\r\n## 高级\r\n\r\n# 总结\r\n## 参考资料\r\n', '<h1 id=\"h1-u524Du8A00\"><a name=\"前言\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>前言</h1><p>本篇总结我在 PHP 笔试、面试中碰到的比较经典的，常见的面试体，我大概分成了初级、中级、高级三个等级，标准比较主观，但时也差不多；目前水平也没达到高级工程师，所以也碰到比较难的题不多，高级题目会比较少。</p>\r\n<p>我会不断更新这篇面试总结，以后再次找工作了可以翻看，也可以来继续补充。</p>\r\n<p>关于必考题，面试下来感觉，MySQL优化是必考的。</p>\r\n<h1 id=\"h1-u9898u76EE\"><a name=\"题目\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>题目</h1><h2 id=\"h2-u521Du7EA7\"><a name=\"初级\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>初级</h2><h3 id=\"h3-php-\"><a name=\"PHP 里的超全局变量有哪些？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>PHP 里的超全局变量有哪些？</h3><ul>\r\n<li>$GLOBALS</li><li>$_SERVER</li><li>$_GET</li><li>$_POST</li><li>$_FILES</li><li>$_COOKIE</li><li>$_SESSION</li><li>$_REQUEST</li><li>$_ENV</li></ul>\r\n<h3 id=\"h3-require-include-\"><a name=\"require 和 include 的区别\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>require 和 include 的区别</h3><ul>\r\n<li>require 失败会产生 E_COMPILE_ERROR 致命错误，并停止运行下边的代码。</li><li>include 失败只产生 E_WARNING 警告，并继续运行下边的代码。</li><li>涉及比较严谨的业务逻辑的代码（php脚本）建议用 require ，因为如果引用失败还继续执行的话，有可能对比较重要的数据造成破坏。</li><li>只用于拼页面相关的代码（前端脚本）可以使用 include 。因为即使引用失败，后续操作也不会破坏数据，最多使页面缺个模块或出现 4xx 错误，也比 5xx 错误更容易让人接受。</li><li>require_once 和 include_once 用于避免重复引入。</li></ul>\r\n<h3 id=\"h3-mysql-char-varchar-\"><a name=\"MySQL 中 char 和 varchar 的区别\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>MySQL 中 char 和 varchar 的区别</h3><p>char 的长度是固定的，不管你存储的数据是多少他都是固定的长度；而 varchar 的长度是可变的，不过要在总长度上加1字符用来存储位置。<br>char 固定长度所以在处理速度上要比 varchar 快很多，但是对费存储空间；所以对存储不大，但在速度上有要求的可以使用char类型，反之可以用varchar类型。</p>\r\n<h3 id=\"h3-linux-php-\"><a name=\"Linux 中如何查看 PHP 进程的状态\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Linux 中如何查看 PHP 进程的状态</h3><ul>\r\n<li><code>ps -aux | grep &#39;php&#39;</code> 过滤出包含“PHP”（比如PHP-fpm，视具体情况）的进程</li><li><code>strace -p &lt;进程编号&gt;</code> 查看进程的具体工作内容</li></ul>\r\n<h3 id=\"h3-redis-\"><a name=\"redis 的存储类型都有哪些\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>redis 的存储类型都有哪些</h3><ul>\r\n<li><strong>string 字符串</strong><br>二进制安全的，可以包涵任何数据，jpg图片或序列化对象。string 是 redis 最基本的类型，一个键最大存储 512M。</li><li><strong>set 集合</strong><br>set 是 string 类型的一个无序集合，集合内数据不重复，set 元素最大可以包含(2的32次方-1)个元素；set 是通过 hash table 实现的，所以添加，删除，查找的复杂度都是O(1)</li><li><strong>hash 哈希表</strong><br>hash 是 key-value 映射的结构，它的添加，删除操作平均复杂度是 O(1)</li><li><strong>list 列表</strong><br>list 就是一个存储 string 类型的双向链表；push 和 pop 的复杂度都是 O(1)，list 会记录链表长度，链表的最大长度是(2的32次方-1)；list 的特性导致它可以做栈，也可以做队列；list有阻塞版本，可以避免轮训查询list队列；</li><li><strong>sorted set 有序集合</strong><br>sorted set 就是 set 的有序集合，添加，删除操作开销都是 O(log(N))；比 list 更消耗内存；</li></ul>\r\n<h3 id=\"h3-http-get-post-\"><a name=\"HTTP 中 GET 和 POST 的区别\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>HTTP 中 GET 和 POST 的区别</h3><ul>\r\n<li>GET 在浏览器回退时是无害的，而 POST 会再次提交请求。</li><li>GET 产生的 URL 地址可以被 Bookmark，而 POST 不可以。</li><li>GET 请求会被浏览器主动 cache，而 POST 不会，除非手动设置。</li><li>GET 请求只能进行 url 编码，而POST支持多种编码方式。</li><li>GET 请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。</li><li>GET 请求在URL中传送的参数是有长度限制的，而 POST 没有。</li><li>对参数的数据类型，GET 只接受 ASCII 字符，而 POST 没有限制。</li><li>GET 比 POST 更不安全，因为参数直接暴露在 URL 上，所以不能用来传递敏感信息。</li><li>GET 参数通过URL传递，POST 放在 Request body 中。</li></ul>\r\n<h3 id=\"h3-cookie-session-\"><a name=\"Cookie 和 Session 的区别和关系\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Cookie 和 Session 的区别和关系</h3><ul>\r\n<li>Cookie 保存在客户端，Session 保存在服务端</li><li>Session 的安全性更高，Cookie 容易被窃取</li><li>Cookie 保存内存的大小有限制，而 Session 没有，但是 Session 会对服务器造成压力</li><li>默认 Session 存储方式为 file，也可以修改为存储在内存中，或者使用 memcache、redis 等；而 Cookie 设置了过期时间会存储在硬盘里面，如果没有设置过期时间会存储在内存里。</li></ul>\r\n<h3 id=\"h3-memcache-redis-\"><a name=\"Memcache 与 Redis 的主要区别\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Memcache 与 Redis 的主要区别</h3><ul>\r\n<li>Memcache 将数据存在内存中，如果服务器奔溃，数据会丢失；而 Redis 有数据持久化功能。</li><li>Memcache 只能存储 string 的键值对；而 Redis 可以存储 String、List、Set、Sorted set、Hash 类型并且有计算功能。</li><li>Mencache 是支持多线程的，而 Redis 是单线程的。</li></ul>\r\n<h3 id=\"h3-u5E76u53D1u548Cu5E76u884Cu7684u533Au522B\"><a name=\"并发和并行的区别\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>并发和并行的区别</h3><p><strong>并发</strong>：不同代码块交替执行的性能；并发的关键是你有处理多个任务的能力，不一定要同时。<br><strong>并行</strong>：不同代码块同时执行的性能；并行的关键是你有同时处理多个任务的能力。<br>并发是指同时有很多事要做，你可以串行处理也可以并行处理，并发和并行是相关的。</p>\r\n<h3 id=\"h3-u8FDBu7A0Bu4E0Eu7EBFu7A0Bu7684u8054u7CFB\"><a name=\"进程与线程的联系\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>进程与线程的联系</h3><p>进程是资源（CPU时间、内存等）分配的最小单位；线程是程序执行的最小单位。</p>\r\n<h3 id=\"h3--\"><a name=\"同步与异步，阻塞与非阻塞。\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>同步与异步，阻塞与非阻塞。</h3><p><strong>同步</strong>: 在发出一个功能调用时，在没有得到结果之前，该调用就不返回。所有的操作都做完，才返回给用户。<br><strong>异步</strong>: 当一个异步过程调用发出后，调用者不能立刻得到结果，不用等所有操作做完，就响应用户请求。实际处理这个调用的部件在完成后通过状态、通知和回调来通知调用者。<br><strong>阻塞</strong>: 阻塞调用是指调用结果返回之前，当前线程会被挂起（线程进入非可执行状态，在这个状态下，cpu不会给线程分配时间片，即线程暂停运行，把计算资源让给其他活动线程，当I/O操作结束，该线程阻塞状态解除，重新变成活动线程，继续争用CPU）。函数只有在得到结果之后才会返回。<br><strong>非阻塞</strong>: 非阻塞和阻塞的概念相对应,指在不能立刻得到结果之前,该函数不会阻塞当前线程,而会立刻返回。<br><strong>同步与异步</strong>是针对数据访问的方式，程序是主动去询问操作系统数据准备好了么，还是操作系统在数据准备好的时候通知程序。<br><strong>阻塞与非阻塞</strong>是针对函数（程序）运行的方式，在IO未就绪时，是等待就绪还是直接返回（执行别的操作）。</p>\r\n<table>\r\n<thead>\r\n<tr>\r\n<th>组合</th>\r\n<th>同步</th>\r\n<th>异步</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr>\r\n<td>阻塞</td>\r\n<td>调用者发出某调用之后，如果函数不能立即返回，则挂起所在线程，等待结果</td>\r\n<td>调用者发出调用之后（如async_recv），线程挂起，被调用的读操作由系统（或者库）来进行，等待有结果之后，系统（或者库）通过某种机制来通知调用者（在调用者获得结果之前，调用者所在线程一直阻塞。这个看起来和同步阻塞很像，但可以这样理解，同步阻塞相当于调用者A调用了一个函数F，F是在调用者A所在的线程中完成的，而异步阻塞相当于调用者A发出对F的调用，然后A所在线程挂起，而实际F是在另一个线程中完成，然后另一个线程通知给A所在的线程，更准确的是将两个线程分别换成用户进程和内核）</td>\r\n</tr>\r\n<tr>\r\n<td>非阻塞</td>\r\n<td>调用者发出调用之后，如果有数据可返回则返回，如果没有数据可读，则线程继续向下执行。程序循环执行，不断地发出调用请求获取数据直到获取到数据。</td>\r\n<td>调用者发出调用之后（如async_recv），线程继续进行别的操作，被调用的读操作由系统（或者库）来进行，等待有结果之后，系统（或者库）通过某种机制（一般为调用调用者设置的回调函数）来通知调用者</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<h3 id=\"h3-u8DE8u57DFu89E3u51B3u65B9u6CD5\"><a name=\"跨域解决方法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>跨域解决方法</h3><h2 id=\"h2-u4E2Du7EA7\"><a name=\"中级\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>中级</h2><h3 id=\"h3--\"><a name=\"秒杀功能，如何实现，会出现什么问题？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>秒杀功能，如何实现，会出现什么问题？</h3><h3 id=\"h3-fastcgi-\"><a name=\"fastcgi 通过端口监听和通过文件监听的区别\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>fastcgi 通过端口监听和通过文件监听的区别</h3><h3 id=\"h3-nginx-php-fpm-\"><a name=\"Nginx + PHP-FPM 的工作原理\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Nginx + PHP-FPM 的工作原理</h3><p>CGI 是 Web Server 与后台语言交互的协议，有了这个协议，开发者可以使用任何语言处理 Web Server 发来的请求，动态的生成内容。但 CGI 每处理一个请求都需要 fork 一个全新的进程。<br>FastCGI，顾名思义为更快的 CGI，它允许在一个进程内处理多个请求，而不是一个请求处理完毕就直接结束进程，性能上有了很大的提高。<br>至于 FPM (FastCGI Process Manager)，它是 FastCGI 的实现，任何实现了 FastCGI 协议的 Web Server 都能够与之通信。FPM 之于标准的 FastCGI，也提供了一些增强功能。<br>PHP-FPM 是一个 PHP 进程管理器，包含 master 进程和 worker 进程两种进程：master 进程只有一个，负责监听端口，接收来自 Web Server 的请求，而 worker 进程则一般有多个 (具体数量根据实际需要配置)，每个进程内部都嵌入了一个 PHP 解释器，是 PHP 代码真正执行的地方。<br>502错误：master 进程根据配置指派特定的 worker 进程进行请求处理，如果没有可用进程，返回错误。 504错误：worker 进程处理请求，如果超时。<br>参考：<a href=\"https://zhuanlan.zhihu.com/p/20694204\">https://zhuanlan.zhihu.com/p/20694204</a></p>\r\n<h3 id=\"h3-php-\"><a name=\"PHP 线程安全的原理\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>PHP 线程安全的原理</h3><p>Windows下的PHP版本分两种:线程安全版本与非线程安全版本。线程安全通过 PHP-TSRM 线程安全管理器实现。<br>正常多线程环境下操作公共的资源都是加上互斥锁，而PHP没有选择加锁，因为加锁可能多少会有些性能损耗，PHP的解决方法是为每一个线程都copy一份当前PHP内核所有的公共资源过来，每个线程指向自己的公共资源区，互不影响，各操作各的公共资源。<br>因为 TSRM 就是让每一个线程都指向自己的这一堆公共资源(数组)，而想在这这一堆公共资源找到你想要的资源就要通过对应的资源id才可以，如果不是这种线程安全版本的，那就不会把这些公共资源都聚合到一堆，直接通过对应的名字获取就好了。</p>\r\n<h3 id=\"h3-php-\"><a name=\"PHP 垃圾回收的原理\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>PHP 垃圾回收的原理</h3><p><a href=\"https://secure.php.net/manual/zh/features.gc.php\">https://secure.php.net/manual/zh/features.gc.php</a></p>\r\n<h3 id=\"h3-php-\"><a name=\"PHP 各种数据类型实现原理\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>PHP 各种数据类型实现原理</h3><h3 id=\"h3-ajax-\"><a name=\"ajax 的实现原理\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>ajax 的实现原理</h3><h3 id=\"h3--tcp-3-4-\"><a name=\"描述 tcp 的3次握手4次挥手\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>描述 tcp 的3次握手4次挥手</h3><h3 id=\"h3--session-\"><a name=\"如何实现单点登录（如何管理session）\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>如何实现单点登录（如何管理session）</h3><h3 id=\"h3-php-\"><a name=\"PHP 代码实现一个双向队列\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>PHP 代码实现一个双向队列</h3><h3 id=\"h3-js-\"><a name=\"JS 闭包\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>JS 闭包</h3><h2 id=\"h2-u9AD8u7EA7\"><a name=\"高级\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>高级</h2><h1 id=\"h1-u603Bu7ED3\"><a name=\"总结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>总结</h1><h2 id=\"h2-u53C2u8003u8D44u6599\"><a name=\"参考资料\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>参考资料</h2>', '', 0, 'draft', 1, 0, '/article/85.html', '', 0, 0, '2018-04-01 16:32:08', '2018-04-01 16:32:08', '2018-04-01 16:32:08', NULL);
INSERT INTO `pt_post` VALUES (86, 10, 'article', '后端程序员在 Linux 下工作必须会的命令清单【更新中......】', '以前用 Linux，都是偶尔上去处理一下服务部署和一些配置，搭建一下环境，所以对于 Linux 的使用，还处于比较基础的阶段，只会一些基础的命令就好了，有一些命令甚至没记住，用的时候再来翻一下。\r\n最近换了新工作，开始频繁地接触 Linux 了，应该说需要具备能够在 Linux 下开发的能力，觉得很是刺激，之前一直没这样的机会，现在机会来了，但是也暴露了在这一块的不足。最近确实是熟悉了很多东西，现在来整理一下在 Linux 下工作，我们必须会的命令！我碰到了就来下来。\r\n\r\n这里不再记录一些基本的概念的东西，或者是最基础的比如 `ls` 啊之类的命令了。只记录一些具有实际用途，需要记下来，或者我之前经常会忘记参数的命令或操作。\r\n\r\n# 基本操作\r\n这里是最基本的 Linux 操作\r\n## 文件/目录操作\r\n- **mkdir - 创建目录**\r\n	- 语法：`mkdir [参数] [目录名]`\r\n	- 参数：\r\n		- -m<目标属性> 或 --mode<目标属性>：建立目录的同时设置目录的权限，如 `-m 777`\r\n		- -p 或 `--parents`：若所要建立目录的上层目录目前尚未建立，则会一并建立上层目录\r\n\r\n- **mv - 修改文件名/自改目录名/移动目录**\r\n	mv 命令的不同使用方式会有不同的效果\r\n	- 语法：\r\n		- `mv [文件名] [文件名]`：将源文件名（前）改为目标文件名（后）\r\n		- `mv [文件名] [目录名]`：将文件移动到目标目录\r\n		- `mv [目录名] [目录名]`：目标目录已存在，将源目录移动到目标目录；目标目录不存在则改名\r\n		- ~~`mv [目录名] [文件名]`：出错，没有这个操作~~\r\n	- 参数：\r\n		- -i: 先询问是否覆盖旧文件\r\n    	- -f: 不指示覆盖某已有的目标文件\r\n\r\n- **rm - 删除文件/目录**\r\n	- 语法：`rm [参数] [名称]...`\r\n	- 参数：\r\n		- -i：删除前逐一询问\r\n		- -f：直接删除不进行询问\r\n		- -r：递归删除目录\r\n\r\n- **cp - 复制文件/目录**\r\n	- 语法：`cp [参数] [源文件/目录] [目标文件/目录]`\r\n	- 参数：\r\n		- -a：此选项通常在复制目录时使用，它保留链接、文件属性，并复制目录下的所有内容。其作用等于`-dpR`参数组合。\r\n		- -d：复制时保留链接。这里所说的链接相当于Windows系统中的快捷方式。\r\n		- -f：不询问文件覆盖\r\n		- -i：覆盖目标文件之前询问是否覆盖\r\n		- -p：除复制文件的内容外，还把修改时间和访问权限也复制到新文件中\r\n		- -r：若给出的源文件是一个目录文件，递归复制子目录和文件\r\n		- -l：不复制文件，只是生成链接文件。\r\n\r\n- **touch - 新建文件/修改文件或者目录的时间属性**\r\n	- 语法：`touch [-acfm][-d<日期时间>][-r<参考文件或目录>] [-t<日期时间>] [文件或目录...]`\r\n	- 参数：\r\n		- -a：改变文件的读取时间记录\r\n		- -m：改变文件的修改时间记录\r\n		- -c：如果文件不存在不建立新的文件，与 `--no-create` 的效果一样\r\n		- -f：不使用，是为了与其他 unix 系统的相容性而保留\r\n		- -r：使用参考文件的时间记录，与 `--file` 的效果一样\r\n		- -d：设定时间与日期，可以使用各种不同的格式\r\n		- -t：设定档案的时间记录，格式与 date 指令相同\r\n		- `--no-create`：不会建立新档案\r\n		- `--help`：列出指令格式\r\n		- `--version`：列出版本讯息\r\n	- 例子：\r\n		```\r\n		# 文件不存在时\r\n		touch exampleFile	#创建一个名为新的空白文件\r\n\r\n		# 文件存在时\r\n		$ touch exampleFile                #修改文件时间属性为当前系统时间\r\n		$ ls -l exampleFile                #查看文件的时间属性\r\n		```\r\n\r\n- **ln - 创建文件同步链接**\r\n	当我们需要在不同的目录，用到相同的文件时，我们不需要在每一个需要的目录下都放一个必须相同的文件，我们只要在某个固定的目录，放上该文件，然后在 其它的目录下用 ln 命令链接（link）它就可以，不必重复的占用磁盘空间。\r\n	- 语法：` ln [参数] [源文件或目录] [目标文件或目录]`\r\n	- 参数：\r\n		- -b：删除、覆盖以前建立的链接\r\n		- -d：建立硬连接\r\n		- -f：强制执行，不论文件或目录是否存在\r\n		- -i：文件存在则提示用户是否覆盖\r\n		- -n：把符号链接视为一般目录\r\n		- -s：建立软链接（符号链接）\r\n		- -v：显示指令执行过程\r\n	- 例子：\r\n	```\r\n	# 创建链接\r\n	ln /usr/local/example.txt /usr/exmaple/example.txt\r\n\r\n	# 创建软链，将 /usr/exmaple/a 软链到 /usr/me/abc\r\n	ln -s /usr/exmaple/a /usr/me/abc\r\n	```\r\n\r\n- **cat - 打印文件内容**\r\n	- 语法：`cat [参数] [file]`\r\n	- 参数：主要都是一些展示相关的参数\r\n		- -n 或 `--number`：由 1 开始对所有输出的行数编号。\r\n		- -b 或 `--number-nonblank`：和 -n 相似，只不过对于空白行不编号。\r\n		- -s 或 `--squeeze-blank`：当遇到有连续两行以上的空白行，就代换为一行的空白行。\r\n		- -v 或 `--show-nonprinting`：使用 ^ 和 M- 符号，除了 LFD 和 TAB 之外。\r\n		- -E 或 `--show-ends`: 在每行结束处显示 $。\r\n		- -T 或 `--show-tabs`: 将 TAB 字符显示为 ^I。\r\n		- -e : 等价于 `-vE`。\r\n		- -A 或 `--show-all`：等价于 `-vET`。\r\n		- -e：等价于 `-vE` 选项；\r\n		- -t：等价于 `-vT` 选项；\r\n\r\n- **tail - 查看文件尾部内容**\r\n	- 语法：`tail [参数] [文件] `\r\n	- 参数：\r\n		- -f：循环读取\r\n    	- -q：不显示处理信息\r\n    	- -v：显示详细的处理信息\r\n    	- -c<数目>：显示的字节数\r\n    	- -n<行数>：显示行数\r\n    	- `--pid=PID`：与-f合用，表示在进程 ID，PID 死掉之后结束\r\n    	- -q 或 `--quiet` 或 `--silent`：从不输出给出文件名的首部\r\n    	- -s 或 `--sleep-interval=S`：与-f合用，表示在每次反复的间隔休眠 S 秒\r\n	- 例子：\r\n	```\r\n	# 显示 example.log 最尾部的内容，并且不断刷新。可以用于查看日志变化。\r\n	tail -f example.log\r\n\r\n	# 显示最后10个字符\r\n	tail -c 10 example.log\r\n	```\r\n\r\n- **chmod - 设置文件权限**\r\n	- 语法：`chmod [参数] [mode] [file]...`\r\n	- 参数：\r\n		- -c：若该文件权限确实已经更改，才显示其更改动作\r\n		- -f：若该文件权限无法被更改也不要显示错误讯息\r\n		- -v：显示权限变更的详细资料\r\n		- -R：对目前目录下的所有文件与子目录进行相同的权限变更\r\n	- 例子：\r\n	`chmod 777 file`\r\n	`chmod ug=rwx,o=x file`\r\n\r\n\r\n# Vi/Vim 操作\r\n- 跳到开头\r\n`0`\r\n`gg`\r\n\r\n- 跳到末尾\r\n`G`\r\n\r\n- 跳到指定行\r\n`ngg`\r\n`nG`\r\n`:n`\r\nn为行数\r\n\r\n- 移动光标\r\n按「ctrl」+「b」：屏幕往“后”移动一页。\r\n按「ctrl」+「f」：屏幕往“前”移动一页。\r\n按「$」：移动到光标所在行的“行尾”。\r\n按「^」：移动到光标所在行的“行首”\r\n\r\n- 删除光标所在行\r\n`dd`\r\n\r\n- 复制光标所在行到缓冲区\r\n`yy`\r\n\r\n- 光标开启选择 \r\n`v`\r\n\r\n- 剪切\r\n`c`\r\n\r\n- 粘贴\r\n`p`\r\n\r\n# Git 操作\r\n一些实用的 Git 操作\r\n## 基本操作\r\n- **查看历史版本**\r\n语法：`git log`\r\n查看指定文件的历史版本：`git log <filename>`\r\n\r\n- **删除一个远程分支**\r\n先删除本地的远程分支，然后推送到远程。\r\n例如，删除远程 origin/confshop 分支：\r\n```\r\n# 删除分支\r\ngit branch -r -d origin/confshop\r\n# 推送到远程\r\ngit push origin :confshop\r\n```\r\n\r\n## 撤销操作\r\n- **取消已经暂存的文件**\r\n语法：`git reset HEAD <filename>...`\r\n如果撤销所有已暂存文件：`git reset HEAD .`\r\n\r\n- **撤销还未暂存的文件的修改**\r\n语法：`git checkout -- <filename>`\r\n如果撤销所有：`git checkout .`\r\n\r\n- **修改最后一次提交**\r\n语法：`git commit --amend`\r\n例子：\r\n```\r\n# 提交\r\ngit commit -m \'initial commit\'\r\n# 新增了一个刚才忘了提交的文件\r\ngit add forgotten_file\r\n# 修改最后一次提交\r\ngit commit --amend\r\n```\r\n\r\n## 回滚操作\r\n- **切换到某个 tag 标签版本**\r\n切换到某个 tag 标签版本：`git checkout <tag>`\r\n说明上线前打 tag 的重要性。\r\n\r\n- **撤销到指定版本**\r\n先查看历史版本，然后指定 ID 回滚到指定版本：\r\n ```\r\n # 查看历史版本\r\n git log <filename>\r\n # 回滚到指定的 commitID\r\n git checkout <commitID> <filename>\r\n ```\r\n\r\n- **删除最后一次远程提交（保留历史记录，生成新的提交）**\r\n ```\r\n # 删除当前指针指向的提交（最后一次提交）\r\n git revert HEAD\r\n # 推送到远程\r\n git push origin master\r\n ```\r\n\r\n- **删除最后一次远程提交（不保留放弃的提交记录，将 HEAD 指针指到指定提交）**\r\n ```\r\n # 重置到当前提交的前一次提交，符号 ^ 表示前一次提交\r\n git reset --hard HEAD^\r\n # 推送到远程\r\n git push origin master -f\r\n```\r\n\r\n# Docker 操作\r\n- **docker exec - 进入 Docker 容器**\r\n	- 语法：`docker exec [参数] [container] [COMMAND] [ARG...]`\r\n	- 参数：\r\n		- -d：分离模式，在后台运行\r\n		- -i：即使没有附加也保持 STDIN 打开\r\n		- -t：分配一个伪终端\r\n	- 例子：在容器 php-fpm 中开启一个交互模式的终端：`docker exec -it php-fpm bash`', '<p>以前用 Linux，都是偶尔上去处理一下服务部署和一些配置，搭建一下环境，所以对于 Linux 的使用，还处于比较基础的阶段，只会一些基础的命令就好了，有一些命令甚至没记住，用的时候再来翻一下。<br>最近换了新工作，开始频繁地接触 Linux 了，应该说需要具备能够在 Linux 下开发的能力，觉得很是刺激，之前一直没这样的机会，现在机会来了，但是也暴露了在这一块的不足。最近确实是熟悉了很多东西，现在来整理一下在 Linux 下工作，我们必须会的命令！我碰到了就来下来。</p>\r\n<p>这里不再记录一些基本的概念的东西，或者是最基础的比如 <code>ls</code> 啊之类的命令了。只记录一些具有实际用途，需要记下来，或者我之前经常会忘记参数的命令或操作。</p>\r\n<h1 id=\"h1-u57FAu672Cu64CDu4F5C\"><a name=\"基本操作\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>基本操作</h1><p>这里是最基本的 Linux 操作</p>\r\n<h2 id=\"h2--\"><a name=\"文件/目录操作\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>文件/目录操作</h2><ul>\r\n<li><p><strong>mkdir - 创建目录</strong></p>\r\n<ul>\r\n<li>语法：<code>mkdir [参数] [目录名]</code></li><li>参数：<ul>\r\n<li>-m&lt;目标属性&gt; 或 —mode&lt;目标属性&gt;：建立目录的同时设置目录的权限，如 <code>-m 777</code></li><li>-p 或 <code>--parents</code>：若所要建立目录的上层目录目前尚未建立，则会一并建立上层目录</li></ul>\r\n</li></ul>\r\n</li><li><p><strong>mv - 修改文件名/自改目录名/移动目录</strong><br>  mv 命令的不同使用方式会有不同的效果</p>\r\n<ul>\r\n<li>语法：<ul>\r\n<li><code>mv [文件名] [文件名]</code>：将源文件名（前）改为目标文件名（后）</li><li><code>mv [文件名] [目录名]</code>：将文件移动到目标目录</li><li><code>mv [目录名] [目录名]</code>：目标目录已存在，将源目录移动到目标目录；目标目录不存在则改名</li><li><del><code>mv [目录名] [文件名]</code>：出错，没有这个操作</del></li></ul>\r\n</li><li>参数：<ul>\r\n<li>-i: 先询问是否覆盖旧文件</li><li>-f: 不指示覆盖某已有的目标文件</li></ul>\r\n</li></ul>\r\n</li><li><p><strong>rm - 删除文件/目录</strong></p>\r\n<ul>\r\n<li>语法：<code>rm [参数] [名称]...</code></li><li>参数：<ul>\r\n<li>-i：删除前逐一询问</li><li>-f：直接删除不进行询问</li><li>-r：递归删除目录</li></ul>\r\n</li></ul>\r\n</li><li><p><strong>cp - 复制文件/目录</strong></p>\r\n<ul>\r\n<li>语法：<code>cp [参数] [源文件/目录] [目标文件/目录]</code></li><li>参数：<ul>\r\n<li>-a：此选项通常在复制目录时使用，它保留链接、文件属性，并复制目录下的所有内容。其作用等于<code>-dpR</code>参数组合。</li><li>-d：复制时保留链接。这里所说的链接相当于Windows系统中的快捷方式。</li><li>-f：不询问文件覆盖</li><li>-i：覆盖目标文件之前询问是否覆盖</li><li>-p：除复制文件的内容外，还把修改时间和访问权限也复制到新文件中</li><li>-r：若给出的源文件是一个目录文件，递归复制子目录和文件</li><li>-l：不复制文件，只是生成链接文件。</li></ul>\r\n</li></ul>\r\n</li><li><p><strong>touch - 新建文件/修改文件或者目录的时间属性</strong></p>\r\n<ul>\r\n<li>语法：<code>touch [-acfm][-d&lt;日期时间&gt;][-r&lt;参考文件或目录&gt;] [-t&lt;日期时间&gt;] [文件或目录...]</code></li><li>参数：<ul>\r\n<li>-a：改变文件的读取时间记录</li><li>-m：改变文件的修改时间记录</li><li>-c：如果文件不存在不建立新的文件，与 <code>--no-create</code> 的效果一样</li><li>-f：不使用，是为了与其他 unix 系统的相容性而保留</li><li>-r：使用参考文件的时间记录，与 <code>--file</code> 的效果一样</li><li>-d：设定时间与日期，可以使用各种不同的格式</li><li>-t：设定档案的时间记录，格式与 date 指令相同</li><li><code>--no-create</code>：不会建立新档案</li><li><code>--help</code>：列出指令格式</li><li><code>--version</code>：列出版本讯息</li></ul>\r\n</li><li><p>例子：</p>\r\n<pre><code>  # 文件不存在时\r\n  touch exampleFile    #创建一个名为新的空白文件\r\n\r\n  # 文件存在时\r\n  $ touch exampleFile                #修改文件时间属性为当前系统时间\r\n  $ ls -l exampleFile                #查看文件的时间属性\r\n</code></pre></li></ul>\r\n</li><li><p><strong>ln - 创建文件同步链接</strong><br>  当我们需要在不同的目录，用到相同的文件时，我们不需要在每一个需要的目录下都放一个必须相同的文件，我们只要在某个固定的目录，放上该文件，然后在 其它的目录下用 ln 命令链接（link）它就可以，不必重复的占用磁盘空间。</p>\r\n<ul>\r\n<li>语法：<code>ln [参数] [源文件或目录] [目标文件或目录]</code></li><li>参数：<ul>\r\n<li>-b：删除、覆盖以前建立的链接</li><li>-d：建立硬连接</li><li>-f：强制执行，不论文件或目录是否存在</li><li>-i：文件存在则提示用户是否覆盖</li><li>-n：把符号链接视为一般目录</li><li>-s：建立软链接（符号链接）</li><li>-v：显示指令执行过程</li></ul>\r\n</li><li><p>例子：</p>\r\n<pre><code># 创建链接\r\nln /usr/local/example.txt /usr/exmaple/example.txt\r\n\r\n# 创建软链，将 /usr/exmaple/a 软链到 /usr/me/abc\r\nln -s /usr/exmaple/a /usr/me/abc\r\n</code></pre></li></ul>\r\n</li><li><p><strong>cat - 打印文件内容</strong></p>\r\n<ul>\r\n<li>语法：<code>cat [参数] [file]</code></li><li>参数：主要都是一些展示相关的参数<ul>\r\n<li>-n 或 <code>--number</code>：由 1 开始对所有输出的行数编号。</li><li>-b 或 <code>--number-nonblank</code>：和 -n 相似，只不过对于空白行不编号。</li><li>-s 或 <code>--squeeze-blank</code>：当遇到有连续两行以上的空白行，就代换为一行的空白行。</li><li>-v 或 <code>--show-nonprinting</code>：使用 ^ 和 M- 符号，除了 LFD 和 TAB 之外。</li><li>-E 或 <code>--show-ends</code>: 在每行结束处显示 $。</li><li>-T 或 <code>--show-tabs</code>: 将 TAB 字符显示为 ^I。</li><li>-e : 等价于 <code>-vE</code>。</li><li>-A 或 <code>--show-all</code>：等价于 <code>-vET</code>。</li><li>-e：等价于 <code>-vE</code> 选项；</li><li>-t：等价于 <code>-vT</code> 选项；</li></ul>\r\n</li></ul>\r\n</li><li><p><strong>tail - 查看文件尾部内容</strong></p>\r\n<ul>\r\n<li>语法：<code>tail [参数] [文件]</code></li><li>参数：<ul>\r\n<li>-f：循环读取</li><li>-q：不显示处理信息</li><li>-v：显示详细的处理信息</li><li>-c&lt;数目&gt;：显示的字节数</li><li>-n&lt;行数&gt;：显示行数</li><li><code>--pid=PID</code>：与-f合用，表示在进程 ID，PID 死掉之后结束</li><li>-q 或 <code>--quiet</code> 或 <code>--silent</code>：从不输出给出文件名的首部</li><li>-s 或 <code>--sleep-interval=S</code>：与-f合用，表示在每次反复的间隔休眠 S 秒</li></ul>\r\n</li><li><p>例子：</p>\r\n<pre><code># 显示 example.log 最尾部的内容，并且不断刷新。可以用于查看日志变化。\r\ntail -f example.log\r\n\r\n# 显示最后10个字符\r\ntail -c 10 example.log\r\n</code></pre></li></ul>\r\n</li><li><p><strong>chmod - 设置文件权限</strong></p>\r\n<ul>\r\n<li>语法：<code>chmod [参数] [mode] [file]...</code></li><li>参数：<ul>\r\n<li>-c：若该文件权限确实已经更改，才显示其更改动作</li><li>-f：若该文件权限无法被更改也不要显示错误讯息</li><li>-v：显示权限变更的详细资料</li><li>-R：对目前目录下的所有文件与子目录进行相同的权限变更</li></ul>\r\n</li><li>例子：<br><code>chmod 777 file</code><br><code>chmod ug=rwx,o=x file</code></li></ul>\r\n</li></ul>\r\n<h1 id=\"h1-vi-vim-\"><a name=\"Vi/Vim 操作\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Vi/Vim 操作</h1><ul>\r\n<li><p>跳到开头<br><code>0</code><br><code>gg</code></p>\r\n</li><li><p>跳到末尾<br><code>G</code></p>\r\n</li><li><p>跳到指定行<br><code>ngg</code><br><code>nG</code><br><code>:n</code><br>n为行数</p>\r\n</li><li><p>移动光标<br>按「ctrl」+「b」：屏幕往“后”移动一页。<br>按「ctrl」+「f」：屏幕往“前”移动一页。<br>按「$」：移动到光标所在行的“行尾”。<br>按「^」：移动到光标所在行的“行首”</p>\r\n</li><li><p>删除光标所在行<br><code>dd</code></p>\r\n</li><li><p>复制光标所在行到缓冲区<br><code>yy</code></p>\r\n</li><li><p>光标开启选择<br><code>v</code></p>\r\n</li><li><p>剪切<br><code>c</code></p>\r\n</li><li><p>粘贴<br><code>p</code></p>\r\n</li></ul>\r\n<h1 id=\"h1-git-\"><a name=\"Git 操作\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Git 操作</h1><p>一些实用的 Git 操作</p>\r\n<h2 id=\"h2-u57FAu672Cu64CDu4F5C\"><a name=\"基本操作\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>基本操作</h2><ul>\r\n<li><p><strong>查看历史版本</strong><br>语法：<code>git log</code><br>查看指定文件的历史版本：<code>git log &lt;filename&gt;</code></p>\r\n</li><li><p><strong>删除一个远程分支</strong><br>先删除本地的远程分支，然后推送到远程。<br>例如，删除远程 origin/confshop 分支：</p>\r\n<pre><code># 删除分支\r\ngit branch -r -d origin/confshop\r\n# 推送到远程\r\ngit push origin :confshop\r\n</code></pre></li></ul>\r\n<h2 id=\"h2-u64A4u9500u64CDu4F5C\"><a name=\"撤销操作\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>撤销操作</h2><ul>\r\n<li><p><strong>取消已经暂存的文件</strong><br>语法：<code>git reset HEAD &lt;filename&gt;...</code><br>如果撤销所有已暂存文件：<code>git reset HEAD .</code></p>\r\n</li><li><p><strong>撤销还未暂存的文件的修改</strong><br>语法：<code>git checkout -- &lt;filename&gt;</code><br>如果撤销所有：<code>git checkout .</code></p>\r\n</li><li><p><strong>修改最后一次提交</strong><br>语法：<code>git commit --amend</code><br>例子：</p>\r\n<pre><code># 提交\r\ngit commit -m &#39;initial commit&#39;\r\n# 新增了一个刚才忘了提交的文件\r\ngit add forgotten_file\r\n# 修改最后一次提交\r\ngit commit --amend\r\n</code></pre></li></ul>\r\n<h2 id=\"h2-u56DEu6EDAu64CDu4F5C\"><a name=\"回滚操作\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>回滚操作</h2><ul>\r\n<li><p><strong>切换到某个 tag 标签版本</strong><br>切换到某个 tag 标签版本：<code>git checkout &lt;tag&gt;</code><br>说明上线前打 tag 的重要性。</p>\r\n</li><li><p><strong>撤销到指定版本</strong><br>先查看历史版本，然后指定 ID 回滚到指定版本：</p>\r\n<pre><code># 查看历史版本\r\ngit log &lt;filename&gt;\r\n# 回滚到指定的 commitID\r\ngit checkout &lt;commitID&gt; &lt;filename&gt;\r\n</code></pre></li><li><p><strong>删除最后一次远程提交（保留历史记录，生成新的提交）</strong></p>\r\n<pre><code># 删除当前指针指向的提交（最后一次提交）\r\ngit revert HEAD\r\n# 推送到远程\r\ngit push origin master\r\n</code></pre></li><li><p><strong>删除最后一次远程提交（不保留放弃的提交记录，将 HEAD 指针指到指定提交）</strong></p>\r\n<pre><code># 重置到当前提交的前一次提交，符号 ^ 表示前一次提交\r\ngit reset --hard HEAD^\r\n# 推送到远程\r\ngit push origin master -f\r\n</code></pre></li></ul>\r\n<h1 id=\"h1-docker-\"><a name=\"Docker 操作\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Docker 操作</h1><ul>\r\n<li><strong>docker exec - 进入 Docker 容器</strong><ul>\r\n<li>语法：<code>docker exec [参数] [container] [COMMAND] [ARG...]</code></li><li>参数：<ul>\r\n<li>-d：分离模式，在后台运行</li><li>-i：即使没有附加也保持 STDIN 打开</li><li>-t：分配一个伪终端</li></ul>\r\n</li><li>例子：在容器 php-fpm 中开启一个交互模式的终端：<code>docker exec -it php-fpm bash</code></li></ul>\r\n</li></ul>\r\n', '', 0, 'publish', 1, 0, '/article/86.html', '', 0, 174, '2018-05-01 20:14:22', '2018-05-01 20:14:22', '2018-05-27 03:49:45', NULL);
INSERT INTO `pt_post` VALUES (87, 10, 'article', 'test article', '**test article**\n123\ntest articletest articletest article++下划线++', '<p><strong>test article</strong><br />\n123<br />\ntest articletest articletest article<ins>下划线</ins></p>\n', '', 0, 'publish', 1, 0, '/article/87.html', '', 0, 0, '2019-01-27 11:54:03', '2019-01-27 11:52:59', '2019-01-27 11:54:29', NULL);
INSERT INTO `pt_post` VALUES (88, 10, 'page', 'test page', '## test page\ntest page\ntest page', '<h2><a id=\"test_page_0\"></a>test page</h2>\n<p>test page<br />\ntest page</p>\n', 'testpage', 0, 'publish', 1, 0, '/testpage', '', 0, 0, '2019-01-27 11:55:27', '2019-01-27 11:55:28', '2019-01-27 11:55:28', NULL);

-- ----------------------------
-- Table structure for pt_post_meta
-- ----------------------------
DROP TABLE IF EXISTS `pt_post_meta`;
CREATE TABLE `pt_post_meta`  (
  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT 'id',
  `post_id` int(11) UNSIGNED NOT NULL DEFAULT 0 COMMENT 'post_id',
  `meta_key` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT '' COMMENT '设置的key',
  `meta_value` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '设置的value',
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `post_id`(`post_id`) USING BTREE,
  INDEX `meta_key`(`meta_key`(191)) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 33 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of pt_post_meta
-- ----------------------------
INSERT INTO `pt_post_meta` VALUES (29, 7, 'description', '2017年回顾总结，以及2018年的展望。');
INSERT INTO `pt_post_meta` VALUES (32, 60, '_zp_page_template', 'default');
INSERT INTO `pt_post_meta` VALUES (33, 60, 'description', '关于我（咖灰怪），和本站点（咖啡与代码）。');
INSERT INTO `pt_post_meta` VALUES (34, 87, 'description', 'test articletest article');
INSERT INTO `pt_post_meta` VALUES (35, 88, 'description', 'test pagetest pagetest pagetest page');
INSERT INTO `pt_post_meta` VALUES (36, 88, 'page_template', 'default');

-- ----------------------------
-- Table structure for pt_resource
-- ----------------------------
DROP TABLE IF EXISTS `pt_resource`;
CREATE TABLE `pt_resource`  (
  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT '资源id',
  `upload_user_id` int(11) UNSIGNED NOT NULL DEFAULT 0 COMMENT '拥有者id',
  `post_id` int(11) UNSIGNED NOT NULL DEFAULT 0 COMMENT '归属的post_id\r\n',
  `title` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '资源名称',
  `slug` varchar(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '缩略名',
  `description` varchar(500) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT '' COMMENT '资源说明',
  `guid` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT '' COMMENT '唯一链接',
  `type` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT 'picture' COMMENT '资源类型；默认picture',
  `mime_type` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '资源文件类型',
  `status` int(11) NOT NULL DEFAULT 1 COMMENT '资源状态;1正常',
  `created_time` datetime(0) NOT NULL COMMENT '上传时间(UTC)',
  `updated_time` datetime(0) NOT NULL COMMENT '更新时间(UTC)',
  `deleted_time` datetime(0) NULL DEFAULT NULL COMMENT '删除时间(UTC)',
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `resource_parent`(`post_id`) USING BTREE,
  INDEX `resource_type`(`id`, `type`, `status`) USING BTREE,
  INDEX `resource_name`(`slug`(191)) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 235 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci COMMENT = '资源表' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of pt_resource
-- ----------------------------
INSERT INTO `pt_resource` VALUES (1, 10, 0, 'php-logo.png', 'php-logo.png', '', '/uploads/cover/php-logo.png', 'picture', 'image/png', 1, '2018-01-04 02:01:08', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (2, 10, 0, 'php-logo.jpg', 'php-logo.jpg', '', '/uploads/cover/php-logo.jpg', 'picture', 'image/jpeg', 1, '2018-01-04 02:04:41', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (3, 10, 0, 'phalcon-logo.png', 'phalcon-logo.png', '', '/uploads/cover/phalcon-logo.png', 'picture', 'image/png', 1, '2018-01-04 02:26:21', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (4, 10, 0, 'ThinkPHP-logo.jpg', 'ThinkPHP-logo.jpg', '', '/uploads/cover/ThinkPHP-logo.jpg', 'picture', 'image/jpeg', 1, '2018-01-04 02:30:52', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (5, 10, 0, 'workerman-logo.png', 'workerman-logo.png', '', '/uploads/cover/workerman-logo.png', 'picture', 'image/png', 1, '2018-01-04 02:43:02', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (6, 10, 0, 'workerman-logo2.png', 'workerman-logo2.png', '', '/uploads/cover/workerman-logo2.png', 'picture', 'image/png', 1, '2018-01-04 02:46:14', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (7, 10, 0, 'golang-logo.png', 'golang-logo.png', '', '/uploads/cover/golang-logo.png', 'picture', 'image/png', 1, '2018-01-04 03:09:13', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (8, 10, 0, 'thinkphp-logo-yellow.jpg', 'thinkphp-logo-yellow.jpg', '', '/uploads/cover/thinkphp-logo-yellow.jpg', 'picture', 'image/jpeg', 1, '2018-01-04 08:13:51', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (9, 10, 0, 'swoole-logo.jpg', 'swoole-logo.jpg', '', '/uploads/cover/swoole-logo.jpg', 'picture', 'image/jpeg', 1, '2018-01-04 10:09:15', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (10, 10, 0, 'php-basic.png', 'php-basic.png', '', '/uploads/cover/php-basic.png', 'picture', 'image/png', 1, '2018-01-04 16:32:38', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (11, 10, 0, 'php-development.jpg', 'php-development.jpg', '', '/uploads/cover/php-development.jpg', 'picture', 'image/jpeg', 1, '2018-01-04 16:34:38', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (12, 10, 0, 'go-logo-none.png', 'go-logo-none.png', '', '/uploads/cover/go-logo-none.png', 'picture', 'image/png', 1, '2018-01-04 16:35:58', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (13, 10, 0, 'database-logo.png', 'database-logo.png', '', '/uploads/cover/database-logo.png', 'picture', 'image/png', 1, '2018-01-04 16:40:08', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (14, 10, 0, 'mysql-logo.png', 'mysql-logo.png', '', '/uploads/cover/mysql-logo.png', 'picture', 'image/png', 1, '2018-01-04 16:41:36', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (15, 10, 0, 'redis-logo.png', 'redis-logo.png', '', '/uploads/cover/redis-logo.png', 'picture', 'image/png', 1, '2018-01-04 16:43:00', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (16, 10, 0, 'using-computer.png', 'using-computer.png', '', '/uploads/cover/using-computer.png', 'picture', 'image/png', 1, '2018-01-04 17:16:13', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (17, 10, 0, 'data-structure.png', 'data-structure.png', '', '/uploads/cover/data-structure.png', 'picture', 'image/png', 1, '2018-01-04 17:17:32', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (18, 10, 0, 'suanfa.png', 'suanfa.png', '', '/uploads/cover/suanfa.png', 'picture', 'image/png', 1, '2018-01-04 17:18:42', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (19, 10, 0, 'javascript-logo.png', 'javascript-logo.png', '', '/uploads/cover/javascript-logo.png', 'picture', 'image/png', 1, '2018-01-04 17:25:38', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (20, 10, 0, 'jquery-logo.png', 'jquery-logo.png', '', '/uploads/cover/jquery-logo.png', 'picture', 'image/png', 1, '2018-01-04 17:26:37', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (21, 10, 0, '2016huigu.jpg', '2016huigu.jpg', '', '/uploads/2018/01/2016huigu.jpg', 'picture', 'image/jpeg', 1, '2018-01-04 18:13:15', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (22, 10, 0, '2018_min.jpg', '2018_min.jpg', '', '/uploads/2018/01/2018_min.jpg', 'picture', 'image/jpeg', 1, '2018-01-05 07:18:56', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (23, 10, 0, '播放器架构.png', '播放器架构.png', '', '/uploads/2018/01/播放器架构.png', 'picture', 'image/png', 1, '2018-01-05 07:40:26', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (24, 10, 0, 'RabbitMQ_work_queues.png', 'RabbitMQ_work_queues.png', '', '/uploads/2018/01/RabbitMQ_work_queues.png', 'picture', 'image/png', 1, '2018-01-05 08:02:25', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (25, 10, 0, 'RabbitMQ架构和原理.png', 'RabbitMQ架构和原理.png', '', '/uploads/2018/01/RabbitMQ架构和原理.png', 'picture', 'image/png', 1, '2018-01-05 08:02:25', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (26, 10, 0, '秒杀案例架构设计.png', '秒杀案例架构设计.png', '', '/uploads/2018/01/秒杀案例架构设计.png', 'picture', 'image/png', 1, '2018-01-05 08:02:25', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (27, 10, 0, '消息队列.png', '消息队列.png', '', '/uploads/2018/01/消息队列.png', 'picture', 'image/png', 1, '2018-01-05 08:02:25', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (28, 10, 0, '消息队列解耦案例.png', '消息队列解耦案例.png', '', '/uploads/2018/01/消息队列解耦案例.png', 'picture', 'image/png', 1, '2018-01-05 08:02:25', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (29, 10, 0, '消息队列解耦案例程序流程.png', '消息队列解耦案例程序流程.png', '', '/uploads/2018/01/消息队列解耦案例程序流程.png', 'picture', 'image/png', 1, '2018-01-05 08:02:25', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (30, 10, 0, '2152528169.jpg', '2152528169.jpg', '', '/uploads/2018/01/2152528169.jpg', 'picture', 'image/jpeg', 1, '2018-01-07 18:35:53', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (31, 10, 0, '1269685963_576x1024.png', '1269685963_576x1024.png', '', '/uploads/2018/01/1269685963_576x1024.png', 'picture', 'image/png', 1, '2018-01-07 18:35:53', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (32, 10, 0, '2760593199.jpg', '2760593199.jpg', '', '/uploads/2018/01/2760593199.jpg', 'picture', 'image/jpeg', 1, '2018-01-07 18:35:53', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (33, 10, 0, '1474477264.png', '1474477264.png', '', '/uploads/2018/01/1474477264.png', 'picture', 'image/png', 1, '2018-01-07 18:35:53', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (34, 10, 0, '3115824438.jpg', '3115824438.jpg', '', '/uploads/2018/01/3115824438.jpg', 'picture', 'image/jpeg', 1, '2018-01-07 18:35:53', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (35, 10, 0, '1763035875.jpg', '1763035875.jpg', '', '/uploads/2018/01/1763035875.jpg', 'picture', 'image/jpeg', 1, '2018-01-07 18:35:53', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (36, 10, 0, '2595756476.jpg', '2595756476.jpg', '', '/uploads/2018/01/2595756476.jpg', 'picture', 'image/jpeg', 1, '2018-01-07 18:35:53', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (37, 10, 0, '2593195352.jpg', '2593195352.jpg', '', '/uploads/2018/01/2593195352.jpg', 'picture', 'image/jpeg', 1, '2018-01-07 18:35:53', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (38, 10, 0, '2705660894.png', '2705660894.png', '', '/uploads/2018/01/2705660894.png', 'picture', 'image/png', 1, '2018-01-07 18:43:00', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (39, 10, 0, '1946475855.png', '1946475855.png', '', '/uploads/2018/01/1946475855.png', 'picture', 'image/png', 1, '2018-01-07 18:49:10', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (40, 10, 0, '31446533.png', '31446533.png', '', '/uploads/2018/01/31446533.png', 'picture', 'image/png', 1, '2018-01-07 18:49:10', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (41, 10, 0, '2505066357.png', '2505066357.png', '', '/uploads/2018/01/2505066357.png', 'picture', 'image/png', 1, '2018-01-07 19:07:08', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (42, 10, 0, '926381641.png', '926381641.png', '', '/uploads/2018/01/926381641.png', 'picture', 'image/png', 1, '2018-01-07 19:07:49', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (43, 10, 0, '2323188462.png', '2323188462.png', '', '/uploads/2018/01/2323188462.png', 'picture', 'image/png', 1, '2018-01-07 19:09:08', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (44, 10, 0, '4030579334.jpg', '4030579334.jpg', '', '/uploads/2018/01/4030579334.jpg', 'picture', 'image/jpeg', 1, '2018-01-07 19:25:17', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (45, 10, 0, '3523161483.jpg', '3523161483.jpg', '', '/uploads/2018/01/3523161483.jpg', 'picture', 'image/jpeg', 1, '2018-01-07 19:25:17', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (46, 10, 0, '1482183358.jpg', '1482183358.jpg', '', '/uploads/2018/01/1482183358.jpg', 'picture', 'image/jpeg', 1, '2018-01-07 19:25:17', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (47, 10, 0, '4106656255.jpg', '4106656255.jpg', '', '/uploads/2018/01/4106656255.jpg', 'picture', 'image/jpeg', 1, '2018-01-07 19:25:17', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (48, 10, 0, '915657141.jpg', '915657141.jpg', '', '/uploads/2018/01/915657141.jpg', 'picture', 'image/jpeg', 1, '2018-01-07 19:25:17', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (49, 10, 0, '331199711.jpg', '331199711.jpg', '', '/uploads/2018/01/331199711.jpg', 'picture', 'image/jpeg', 1, '2018-01-07 19:25:17', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (50, 10, 0, '3002222694.jpg', '3002222694.jpg', '', '/uploads/2018/01/3002222694.jpg', 'picture', 'image/jpeg', 1, '2018-01-07 19:31:41', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (51, 10, 0, 'js-shili.jpg', 'js-shili.jpg', '', '/uploads/cover/js-shili.jpg', 'picture', 'image/jpeg', 1, '2018-01-07 19:37:46', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (52, 10, 0, '1567451059.png', '1567451059.png', '', '/uploads/2018/01/1567451059.png', 'picture', 'image/png', 1, '2018-01-07 19:46:41', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (53, 10, 0, '1824703186.png', '1824703186.png', '', '/uploads/2018/01/1824703186.png', 'picture', 'image/png', 1, '2018-01-07 19:46:41', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (54, 10, 0, '2033684534.png', '2033684534.png', '', '/uploads/2018/01/2033684534.png', 'picture', 'image/png', 1, '2018-01-07 19:46:42', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (55, 10, 0, '2636851374.png', '2636851374.png', '', '/uploads/2018/01/2636851374.png', 'picture', 'image/png', 1, '2018-01-07 19:46:42', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (56, 10, 0, '3834160044.png', '3834160044.png', '', '/uploads/2018/01/3834160044.png', 'picture', 'image/png', 1, '2018-01-07 19:46:44', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (57, 10, 0, '3236160541.png', '3236160541.png', '', '/uploads/2018/01/3236160541.png', 'picture', 'image/png', 1, '2018-01-07 19:46:44', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (58, 10, 0, '4069227203.png', '4069227203.png', '', '/uploads/2018/01/4069227203.png', 'picture', 'image/png', 1, '2018-01-07 19:55:10', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (59, 10, 0, '1398985470.png', '1398985470.png', '', '/uploads/2018/01/1398985470.png', 'picture', 'image/png', 1, '2018-01-07 19:55:10', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (60, 10, 0, '3581344272.png', '3581344272.png', '', '/uploads/2018/01/3581344272.png', 'picture', 'image/png', 1, '2018-01-07 19:55:10', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (61, 10, 0, 'database-logo-white.jpg', 'database-logo-white.jpg', '', '/uploads/cover/database-logo-white.jpg', 'picture', 'image/jpeg', 1, '2018-01-07 20:15:36', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (62, 10, 0, '2652457207.png', '2652457207.png', '', '/uploads/2018/01/2652457207.png', 'picture', 'image/png', 1, '2018-01-08 02:49:13', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (63, 10, 0, '1867581207.png', '1867581207.png', '', '/uploads/2018/01/1867581207.png', 'picture', 'image/png', 1, '2018-01-08 02:49:13', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (64, 10, 0, 'mysql_jiagou.jpg', 'mysql_jiagou.jpg', '', '/uploads/2018/01/mysql_jiagou.jpg', 'picture', 'image/jpeg', 1, '2018-01-08 05:50:10', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (65, 10, 0, 'mysql_geli.jpg', 'mysql_geli.jpg', '', '/uploads/2018/01/mysql_geli.jpg', 'picture', 'image/jpeg', 1, '2018-01-08 05:50:11', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (66, 10, 0, 'php_jiami.jpg', 'php_jiami.jpg', '', '/uploads/2018/01/php_jiami.jpg', 'picture', 'image/jpeg', 1, '2018-01-08 08:21:02', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (67, 10, 0, 'datastruct-three.png', 'datastruct-three.png', '', '/uploads/cover/datastruct-three.png', 'picture', 'image/png', 1, '2018-01-08 16:53:39', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (68, 10, 0, 'server-operating-system.png', 'server-operating-system.png', '', '/uploads/cover/server-operating-system.png', 'picture', 'image/png', 1, '2018-01-08 17:30:51', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (69, 10, 0, 'linux-logo.jpg', 'linux-logo.jpg', '', '/uploads/cover/linux-logo.jpg', 'picture', 'image/jpeg', 1, '2018-01-08 17:32:03', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (70, 10, 0, 'docker-logo.png', 'docker-logo.png', '', '/uploads/cover/docker-logo.png', 'picture', 'image/png', 1, '2018-01-08 17:32:38', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (71, 10, 0, 'git-logo.jpg', 'git-logo.jpg', '', '/uploads/cover/git-logo.jpg', 'picture', 'image/jpeg', 1, '2018-01-08 18:22:43', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (72, 10, 0, 'Information-communication.jpg', 'Information-communication.jpg', '', '/uploads/cover/Information-communication.jpg', 'picture', 'image/jpeg', 1, '2018-01-08 18:26:17', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (73, 10, 0, 'junior-mechanical-system.png', 'junior-mechanical-system.png', '', '/uploads/cover/junior-mechanical-system.png', 'picture', 'image/png', 1, '2018-01-08 18:27:53', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (74, 10, 0, 'Install_composer2.png', 'Install_composer2.png', '', '/uploads/2018/01/Install_composer2.png', 'picture', 'image/png', 1, '2018-01-09 02:39:46', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (75, 10, 0, 'Install_composer3.png', 'Install_composer3.png', '', '/uploads/2018/01/Install_composer3.png', 'picture', 'image/png', 1, '2018-01-09 02:39:46', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (76, 10, 0, 'Install_composer1.png', 'Install_composer1.png', '', '/uploads/2018/01/Install_composer1.png', 'picture', 'image/png', 1, '2018-01-09 02:39:46', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (77, 10, 0, 'composer_logo.png', 'composer_logo.png', '', '/uploads/2018/01/composer_logo.png', 'picture', 'image/png', 1, '2018-01-09 02:44:18', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (78, 10, 0, 'git_1.png', 'git_1.png', '', '/uploads/2018/01/git_1.png', 'picture', 'image/png', 1, '2018-01-09 03:58:42', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (79, 10, 0, 'git_2.png', 'git_2.png', '', '/uploads/2018/01/git_2.png', 'picture', 'image/png', 1, '2018-01-09 03:58:42', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (80, 10, 0, 'git_square_logo.png', 'git_square_logo.png', '', '/uploads/2018/01/git_square_logo.png', 'picture', 'image/png', 1, '2018-01-09 04:06:54', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (81, 10, 0, 'bg2015120901.png', 'bg2015120901.png', '', '/uploads/2018/01/bg2015120901.png', 'picture', 'image/png', 1, '2018-01-09 04:15:24', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (82, 10, 0, 'xxfpm1.png', 'xxfpm1.png', '', '/uploads/2018/01/xxfpm1.png', 'picture', 'image/png', 1, '2018-01-09 05:41:14', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (83, 10, 0, 'xxfpm2.png', 'xxfpm2.png', '', '/uploads/2018/01/xxfpm2.png', 'picture', 'image/png', 1, '2018-01-09 05:41:14', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (84, 10, 0, 'xxfpm3.png', 'xxfpm3.png', '', '/uploads/2018/01/xxfpm3.png', 'picture', 'image/png', 1, '2018-01-09 05:41:14', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (85, 10, 0, 'wp_nav_menu1.png', 'wp_nav_menu1.png', '', '/uploads/2018/01/wp_nav_menu1.png', 'picture', 'image/png', 1, '2018-01-09 05:53:41', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (86, 10, 0, 'wp_nav_menu2.png', 'wp_nav_menu2.png', '', '/uploads/2018/01/wp_nav_menu2.png', 'picture', 'image/png', 1, '2018-01-09 05:53:41', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (87, 10, 0, 'wp_nav_menu3.png', 'wp_nav_menu3.png', '', '/uploads/2018/01/wp_nav_menu3.png', 'picture', 'image/png', 1, '2018-01-09 05:53:41', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (88, 10, 0, 'jumping_3.png', 'jumping_3.png', '', '/uploads/2018/01/jumping_3.png', 'picture', 'image/png', 1, '2018-01-09 06:29:26', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (89, 10, 0, 'jumping_2.png', 'jumping_2.png', '', '/uploads/2018/01/jumping_2.png', 'picture', 'image/png', 1, '2018-01-09 06:29:26', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (90, 10, 0, 'jumping_1.png', 'jumping_1.png', '', '/uploads/2018/01/jumping_1.png', 'picture', 'image/png', 1, '2018-01-09 06:29:26', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (91, 10, 0, 'spa3.png', 'spa3.png', '', '/uploads/2018/01/spa3.png', 'picture', 'image/png', 1, '2018-01-09 06:48:27', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (92, 10, 0, 'spa4.png', 'spa4.png', '', '/uploads/2018/01/spa4.png', 'picture', 'image/png', 1, '2018-01-09 06:48:27', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (93, 10, 0, 'spa1.png', 'spa1.png', '', '/uploads/2018/01/spa1.png', 'picture', 'image/png', 1, '2018-01-09 06:48:27', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (94, 10, 0, 'spa2.png', 'spa2.png', '', '/uploads/2018/01/spa2.png', 'picture', 'image/png', 1, '2018-01-09 06:48:27', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (95, 10, 0, 'LNMP4.png', 'LNMP4.png', '', '/uploads/2018/01/LNMP4.png', 'picture', 'image/png', 1, '2018-01-09 07:06:39', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (96, 10, 0, 'LNMP7.png', 'LNMP7.png', '', '/uploads/2018/01/LNMP7.png', 'picture', 'image/png', 1, '2018-01-09 07:06:39', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (97, 10, 0, 'LNMP6.png', 'LNMP6.png', '', '/uploads/2018/01/LNMP6.png', 'picture', 'image/png', 1, '2018-01-09 07:06:39', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (98, 10, 0, 'LNMP8.png', 'LNMP8.png', '', '/uploads/2018/01/LNMP8.png', 'picture', 'image/png', 1, '2018-01-09 07:06:39', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (99, 10, 0, 'LNMP9.png', 'LNMP9.png', '', '/uploads/2018/01/LNMP9.png', 'picture', 'image/png', 1, '2018-01-09 07:06:39', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (100, 10, 0, 'LNMP2.png', 'LNMP2.png', '', '/uploads/2018/01/LNMP2.png', 'picture', 'image/png', 1, '2018-01-09 07:06:39', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (101, 10, 0, 'LNMP10.png', 'LNMP10.png', '', '/uploads/2018/01/LNMP10.png', 'picture', 'image/png', 1, '2018-01-09 07:06:39', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (102, 10, 0, 'LNMP3.png', 'LNMP3.png', '', '/uploads/2018/01/LNMP3.png', 'picture', 'image/png', 1, '2018-01-09 07:06:39', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (103, 10, 0, 'tohttps4.png', 'tohttps4.png', '', '/uploads/2018/01/tohttps4.png', 'picture', 'image/png', 1, '2018-01-09 08:43:31', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (104, 10, 0, 'tohttps5.png', 'tohttps5.png', '', '/uploads/2018/01/tohttps5.png', 'picture', 'image/png', 1, '2018-01-09 08:43:31', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (105, 10, 0, 'tohttps6.png', 'tohttps6.png', '', '/uploads/2018/01/tohttps6.png', 'picture', 'image/png', 1, '2018-01-09 08:43:31', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (106, 10, 0, 'tohttps7.png', 'tohttps7.png', '', '/uploads/2018/01/tohttps7.png', 'picture', 'image/png', 1, '2018-01-09 08:43:31', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (107, 10, 0, 'tohttps8.png', 'tohttps8.png', '', '/uploads/2018/01/tohttps8.png', 'picture', 'image/png', 1, '2018-01-09 08:43:31', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (108, 10, 0, 'tohttps10.png', 'tohttps10.png', '', '/uploads/2018/01/tohttps10.png', 'picture', 'image/png', 1, '2018-01-09 08:43:31', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (109, 10, 0, 'tohttps11.png', 'tohttps11.png', '', '/uploads/2018/01/tohttps11.png', 'picture', 'image/png', 1, '2018-01-09 08:43:31', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (110, 10, 0, 'tohttps9.png', 'tohttps9.png', '', '/uploads/2018/01/tohttps9.png', 'picture', 'image/png', 1, '2018-01-09 08:43:31', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (111, 10, 0, 'tohttps12_300x109.png', 'tohttps12_300x109.png', '', '/uploads/2018/01/tohttps12_300x109.png', 'picture', 'image/png', 1, '2018-01-09 08:43:31', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (112, 10, 0, 'tohttps14.png', 'tohttps14.png', '', '/uploads/2018/01/tohttps14.png', 'picture', 'image/png', 1, '2018-01-09 08:43:31', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (113, 10, 0, 'tohttps13.png', 'tohttps13.png', '', '/uploads/2018/01/tohttps13.png', 'picture', 'image/png', 1, '2018-01-09 08:43:31', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (114, 10, 0, 'tohttps2.png', 'tohttps2.png', '', '/uploads/2018/01/tohttps2.png', 'picture', 'image/png', 1, '2018-01-09 08:43:31', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (115, 10, 0, 'tohttps3.png', 'tohttps3.png', '', '/uploads/2018/01/tohttps3.png', 'picture', 'image/png', 1, '2018-01-09 08:43:31', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (116, 10, 0, 'Apache500_2.png', 'Apache500_2.png', '', '/uploads/2018/01/Apache500_2.png', 'picture', 'image/png', 1, '2018-01-09 09:08:49', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (117, 10, 0, 'Apache500_3.png', 'Apache500_3.png', '', '/uploads/2018/01/Apache500_3.png', 'picture', 'image/png', 1, '2018-01-09 09:08:49', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (118, 10, 0, 'Apache500_4.png', 'Apache500_4.png', '', '/uploads/2018/01/Apache500_4.png', 'picture', 'image/png', 1, '2018-01-09 09:08:49', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (119, 10, 0, 'Apache500_5.png', 'Apache500_5.png', '', '/uploads/2018/01/Apache500_5.png', 'picture', 'image/png', 1, '2018-01-09 09:08:49', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (120, 10, 0, 'Apache500_6.png', 'Apache500_6.png', '', '/uploads/2018/01/Apache500_6.png', 'picture', 'image/png', 1, '2018-01-09 09:08:49', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (121, 10, 0, 'Apache500_7.png', 'Apache500_7.png', '', '/uploads/2018/01/Apache500_7.png', 'picture', 'image/png', 1, '2018-01-09 09:08:49', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (122, 10, 0, 'Apache500_1.png', 'Apache500_1.png', '', '/uploads/2018/01/Apache500_1.png', 'picture', 'image/png', 1, '2018-01-09 09:08:49', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (123, 10, 0, 'http2_3_1024x96.png', 'http2_3_1024x96.png', '', '/uploads/2018/01/http2_3_1024x96.png', 'picture', 'image/png', 1, '2018-01-09 09:30:13', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (124, 10, 0, 'http2_4.png', 'http2_4.png', '', '/uploads/2018/01/http2_4.png', 'picture', 'image/png', 1, '2018-01-09 09:30:13', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (125, 10, 0, 'http2_6.png', 'http2_6.png', '', '/uploads/2018/01/http2_6.png', 'picture', 'image/png', 1, '2018-01-09 09:30:13', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (126, 10, 0, 'http2_5_1024x77.png', 'http2_5_1024x77.png', '', '/uploads/2018/01/http2_5_1024x77.png', 'picture', 'image/png', 1, '2018-01-09 09:30:13', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (127, 10, 0, 'http2_7.png', 'http2_7.png', '', '/uploads/2018/01/http2_7.png', 'picture', 'image/png', 1, '2018-01-09 09:30:13', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (128, 10, 0, 'http2_8_300x126.png', 'http2_8_300x126.png', '', '/uploads/2018/01/http2_8_300x126.png', 'picture', 'image/png', 1, '2018-01-09 09:30:13', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (129, 10, 0, 'http2_1_768x650.png', 'http2_1_768x650.png', '', '/uploads/2018/01/http2_1_768x650.png', 'picture', 'image/png', 1, '2018-01-09 09:30:13', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (130, 10, 0, 'http2_2_1024x516.png', 'http2_2_1024x516.png', '', '/uploads/2018/01/http2_2_1024x516.png', 'picture', 'image/png', 1, '2018-01-09 09:30:13', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (131, 10, 0, 'https_youhua2_768x546.png', 'https_youhua2_768x546.png', '', '/uploads/2018/01/https_youhua2_768x546.png', 'picture', 'image/png', 1, '2018-01-09 09:59:04', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (132, 10, 0, 'https_youhua5.png', 'https_youhua5.png', '', '/uploads/2018/01/https_youhua5.png', 'picture', 'image/png', 1, '2018-01-09 09:59:04', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (133, 10, 0, 'https_youhua4.png', 'https_youhua4.png', '', '/uploads/2018/01/https_youhua4.png', 'picture', 'image/png', 1, '2018-01-09 09:59:04', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (134, 10, 0, 'https_youhua6.png', 'https_youhua6.png', '', '/uploads/2018/01/https_youhua6.png', 'picture', 'image/png', 1, '2018-01-09 09:59:04', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (135, 10, 0, 'https_youhua3_768x584.png', 'https_youhua3_768x584.png', '', '/uploads/2018/01/https_youhua3_768x584.png', 'picture', 'image/png', 1, '2018-01-09 09:59:04', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (136, 10, 0, 'https_youhua7_768x512.png', 'https_youhua7_768x512.png', '', '/uploads/2018/01/https_youhua7_768x512.png', 'picture', 'image/png', 1, '2018-01-09 09:59:04', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (137, 10, 0, 'aliyun_tp5_look_like.png', 'aliyun_tp5_look_like.png', '', '/uploads/2018/01/aliyun_tp5_look_like.png', 'picture', 'image/png', 1, '2018-01-09 15:43:53', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (138, 10, 0, 'git_start2.png', 'git_start2.png', '', '/uploads/2018/01/git_start2.png', 'picture', 'image/png', 1, '2018-01-09 16:01:14', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (139, 10, 0, 'git_start1.png', 'git_start1.png', '', '/uploads/2018/01/git_start1.png', 'picture', 'image/png', 1, '2018-01-09 16:01:14', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (140, 10, 0, 'wordpress_reply3.png', 'wordpress_reply3.png', '', '/uploads/2018/01/wordpress_reply3.png', 'picture', 'image/png', 1, '2018-01-09 17:55:11', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (141, 10, 0, 'wordpress_reply1.png', 'wordpress_reply1.png', '', '/uploads/2018/01/wordpress_reply1.png', 'picture', 'image/png', 1, '2018-01-09 17:55:11', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (142, 10, 0, 'wordpress_reply2.png', 'wordpress_reply2.png', '', '/uploads/2018/01/wordpress_reply2.png', 'picture', 'image/png', 1, '2018-01-09 17:55:11', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (143, 10, 0, 'ab测试.png', 'ab测试.png', '', '/uploads/2018/01/ab测试.png', 'picture', 'image/png', 1, '2018-01-09 18:02:53', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (144, 10, 0, 'SupportApache_small.png', 'SupportApache_small.png', '', '/uploads/2018/01/SupportApache_small.png', 'picture', 'image/png', 1, '2018-01-09 18:13:07', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (145, 10, 0, 'SaltedFish_4_768x426.png', 'SaltedFish_4_768x426.png', '', '/uploads/2018/01/SaltedFish_4_768x426.png', 'picture', 'image/png', 1, '2018-01-09 18:15:31', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (146, 10, 0, 'SaltedFish_1_768x589.png', 'SaltedFish_1_768x589.png', '', '/uploads/2018/01/SaltedFish_1_768x589.png', 'picture', 'image/png', 1, '2018-01-09 18:15:31', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (147, 10, 0, 'SaltedFish_2_768x615.png', 'SaltedFish_2_768x615.png', '', '/uploads/2018/01/SaltedFish_2_768x615.png', 'picture', 'image/png', 1, '2018-01-09 18:15:31', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (148, 10, 0, 'SaltedFish_3.png', 'SaltedFish_3.png', '', '/uploads/2018/01/SaltedFish_3.png', 'picture', 'image/png', 1, '2018-01-09 18:15:31', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (149, 10, 0, 'timthumb.php.png', 'timthumb.php.png', '', '/uploads/2018/01/timthumb.php.png', 'picture', 'image/png', 1, '2018-01-09 18:21:41', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (150, 10, 0, '使用gitbook.com3_.png', '使用gitbook.com3_.png', '', '/uploads/2018/01/使用gitbook.com3_.png', 'picture', 'image/png', 1, '2018-01-10 01:52:10', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (151, 10, 0, '使用gitbook.com4__768x578.png', '使用gitbook.com4__768x578.png', '', '/uploads/2018/01/使用gitbook.com4__768x578.png', 'picture', 'image/png', 1, '2018-01-10 01:52:10', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (152, 10, 0, '使用gitbook.com5_.png', '使用gitbook.com5_.png', '', '/uploads/2018/01/使用gitbook.com5_.png', 'picture', 'image/png', 1, '2018-01-10 01:52:10', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (153, 10, 0, 'Gitbook使用流程.png', 'Gitbook使用流程.png', '', '/uploads/2018/01/Gitbook使用流程.png', 'picture', 'image/png', 1, '2018-01-10 01:52:10', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (154, 10, 0, '使用gitbook.com1__768x478.png', '使用gitbook.com1__768x478.png', '', '/uploads/2018/01/使用gitbook.com1__768x478.png', 'picture', 'image/png', 1, '2018-01-10 01:52:10', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (155, 10, 0, '使用gitbook.com2__1024x514.png', '使用gitbook.com2__1024x514.png', '', '/uploads/2018/01/使用gitbook.com2__1024x514.png', 'picture', 'image/png', 1, '2018-01-10 01:52:10', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (156, 10, 0, 'gitbook.jpg', 'gitbook.jpg', '', '/uploads/2018/01/gitbook.jpg', 'picture', 'image/jpeg', 1, '2018-01-10 02:27:56', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (157, 10, 0, 'docker_logo_square.png', 'docker_logo_square.png', '', '/uploads/2018/01/docker_logo_square.png', 'picture', 'image/png', 1, '2018-01-10 02:37:42', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (158, 10, 0, 'php-library-logo.jpg', 'php-library-logo.jpg', '', '/uploads/cover/php-library-logo.jpg', 'picture', 'image/jpeg', 1, '2018-01-10 02:50:08', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (159, 10, 0, 'qrcode_error.png', 'qrcode_error.png', '', '/uploads/2018/01/qrcode_error.png', 'picture', 'image/png', 1, '2018-01-10 15:32:20', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (160, 10, 0, 'javascript_libraries.jpg', 'javascript_libraries.jpg', '', '/uploads/2018/01/javascript_libraries.jpg', 'picture', 'image/jpeg', 1, '2018-01-10 15:41:58', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (161, 10, 0, 'javascript-libraries.jpg', 'javascript-libraries.jpg', '', '/uploads/cover/javascript-libraries.jpg', 'picture', 'image/jpeg', 1, '2018-01-10 15:43:53', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (162, 10, 0, 'wechat_qrcode.png', 'wechat_qrcode.png', '', '/uploads/2018/01/wechat_qrcode.png', 'picture', 'image/png', 1, '2018-01-10 15:45:21', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (163, 10, 0, 'pace1.png', 'pace1.png', '', '/uploads/2018/01/pace1.png', 'picture', 'image/png', 1, '2018-01-10 15:51:23', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (164, 10, 0, 'Wireshark3.png', 'Wireshark3.png', '', '/uploads/2018/01/Wireshark3.png', 'picture', 'image/png', 1, '2018-01-11 02:01:30', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (165, 10, 0, 'Wireshark4.png', 'Wireshark4.png', '', '/uploads/2018/01/Wireshark4.png', 'picture', 'image/png', 1, '2018-01-11 02:01:30', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (166, 10, 0, 'Wireshark5.png', 'Wireshark5.png', '', '/uploads/2018/01/Wireshark5.png', 'picture', 'image/png', 1, '2018-01-11 02:01:30', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (167, 10, 0, 'Wireshark7.png', 'Wireshark7.png', '', '/uploads/2018/01/Wireshark7.png', 'picture', 'image/png', 1, '2018-01-11 02:01:30', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (168, 10, 0, 'Wireshark8.png', 'Wireshark8.png', '', '/uploads/2018/01/Wireshark8.png', 'picture', 'image/png', 1, '2018-01-11 02:01:30', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (169, 10, 0, 'Wireshark1.png', 'Wireshark1.png', '', '/uploads/2018/01/Wireshark1.png', 'picture', 'image/png', 1, '2018-01-11 02:01:30', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (170, 10, 0, 'Wireshark6_768x715.png', 'Wireshark6_768x715.png', '', '/uploads/2018/01/Wireshark6_768x715.png', 'picture', 'image/png', 1, '2018-01-11 02:01:30', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (171, 10, 0, 'Wireshark2_768x724.png', 'Wireshark2_768x724.png', '', '/uploads/2018/01/Wireshark2_768x724.png', 'picture', 'image/png', 1, '2018-01-11 02:01:30', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (172, 10, 0, 'Fiddler2.png', 'Fiddler2.png', '', '/uploads/2018/01/Fiddler2.png', 'picture', 'image/png', 1, '2018-01-11 02:13:00', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (173, 10, 0, 'Fiddler3.png', 'Fiddler3.png', '', '/uploads/2018/01/Fiddler3.png', 'picture', 'image/png', 1, '2018-01-11 02:13:00', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (174, 10, 0, 'Fiddler5.png', 'Fiddler5.png', '', '/uploads/2018/01/Fiddler5.png', 'picture', 'image/png', 1, '2018-01-11 02:13:00', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (175, 10, 0, 'Fiddler4.png', 'Fiddler4.png', '', '/uploads/2018/01/Fiddler4.png', 'picture', 'image/png', 1, '2018-01-11 02:13:00', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (176, 10, 0, 'Fiddler6.png', 'Fiddler6.png', '', '/uploads/2018/01/Fiddler6.png', 'picture', 'image/png', 1, '2018-01-11 02:13:00', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (177, 10, 0, 'Fiddler7.png', 'Fiddler7.png', '', '/uploads/2018/01/Fiddler7.png', 'picture', 'image/png', 1, '2018-01-11 02:13:00', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (178, 10, 0, 'Fiddler8.png', 'Fiddler8.png', '', '/uploads/2018/01/Fiddler8.png', 'picture', 'image/png', 1, '2018-01-11 02:13:00', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (179, 10, 0, 'Fiddler10.png', 'Fiddler10.png', '', '/uploads/2018/01/Fiddler10.png', 'picture', 'image/png', 1, '2018-01-11 02:13:00', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (180, 10, 0, 'Fiddler9_1024x394.png', 'Fiddler9_1024x394.png', '', '/uploads/2018/01/Fiddler9_1024x394.png', 'picture', 'image/png', 1, '2018-01-11 02:13:00', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (181, 10, 0, 'Fiddler13.png', 'Fiddler13.png', '', '/uploads/2018/01/Fiddler13.png', 'picture', 'image/png', 1, '2018-01-11 02:13:00', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (182, 10, 0, 'Fiddler12_1024x581.png', 'Fiddler12_1024x581.png', '', '/uploads/2018/01/Fiddler12_1024x581.png', 'picture', 'image/png', 1, '2018-01-11 02:13:00', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (183, 10, 0, 'Fiddler16.png', 'Fiddler16.png', '', '/uploads/2018/01/Fiddler16.png', 'picture', 'image/png', 1, '2018-01-11 02:13:00', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (184, 10, 0, 'Fiddler17_1024x33.png', 'Fiddler17_1024x33.png', '', '/uploads/2018/01/Fiddler17_1024x33.png', 'picture', 'image/png', 1, '2018-01-11 02:13:00', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (185, 10, 0, 'Fiddler15.png', 'Fiddler15.png', '', '/uploads/2018/01/Fiddler15.png', 'picture', 'image/png', 1, '2018-01-11 02:13:00', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (186, 10, 0, 'Fiddler14_768x568.png', 'Fiddler14_768x568.png', '', '/uploads/2018/01/Fiddler14_768x568.png', 'picture', 'image/png', 1, '2018-01-11 02:13:00', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (187, 10, 0, 'Fiddler1.png', 'Fiddler1.png', '', '/uploads/2018/01/Fiddler1.png', 'picture', 'image/png', 1, '2018-01-11 02:13:00', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (188, 10, 0, 'Fiddler11_768x514.png', 'Fiddler11_768x514.png', '', '/uploads/2018/01/Fiddler11_768x514.png', 'picture', 'image/png', 1, '2018-01-11 02:13:00', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (189, 10, 0, 'Fiddler19_1024x72.png', 'Fiddler19_1024x72.png', '', '/uploads/2018/01/Fiddler19_1024x72.png', 'picture', 'image/png', 1, '2018-01-11 02:13:00', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (190, 10, 0, 'Fiddler18_1024x522.png', 'Fiddler18_1024x522.png', '', '/uploads/2018/01/Fiddler18_1024x522.png', 'picture', 'image/png', 1, '2018-01-11 02:13:00', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (191, 10, 0, 'wireshark_logo.png', 'wireshark_logo.png', '', '/uploads/2018/01/wireshark_logo.png', 'picture', 'image/png', 1, '2018-01-11 02:35:24', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (192, 10, 0, 'docker_for_windows9.png', 'docker_for_windows9.png', '', '/uploads/2018/01/docker_for_windows9.png', 'picture', 'image/png', 1, '2018-01-11 03:50:12', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (193, 10, 0, 'docker_for_windows10.png', 'docker_for_windows10.png', '', '/uploads/2018/01/docker_for_windows10.png', 'picture', 'image/png', 1, '2018-01-11 03:50:12', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (194, 10, 0, 'docker_for_windows11.png', 'docker_for_windows11.png', '', '/uploads/2018/01/docker_for_windows11.png', 'picture', 'image/png', 1, '2018-01-11 03:50:12', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (195, 10, 0, 'docker_for_windows13.png', 'docker_for_windows13.png', '', '/uploads/2018/01/docker_for_windows13.png', 'picture', 'image/png', 1, '2018-01-11 03:50:12', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (196, 10, 0, 'docker_for_windows15.png', 'docker_for_windows15.png', '', '/uploads/2018/01/docker_for_windows15.png', 'picture', 'image/png', 1, '2018-01-11 03:50:12', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (197, 10, 0, 'docker_for_windows12_768x201.png', 'docker_for_windows12_768x201.png', '', '/uploads/2018/01/docker_for_windows12_768x201.png', 'picture', 'image/png', 1, '2018-01-11 03:50:12', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (198, 10, 0, 'docker_for_windows14.png', 'docker_for_windows14.png', '', '/uploads/2018/01/docker_for_windows14.png', 'picture', 'image/png', 1, '2018-01-11 03:50:12', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (199, 10, 0, 'docker_for_windows4.png', 'docker_for_windows4.png', '', '/uploads/2018/01/docker_for_windows4.png', 'picture', 'image/png', 1, '2018-01-11 03:50:12', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (200, 10, 0, 'docker_for_windows17_300x195.png', 'docker_for_windows17_300x195.png', '', '/uploads/2018/01/docker_for_windows17_300x195.png', 'picture', 'image/png', 1, '2018-01-11 03:50:12', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (201, 10, 0, 'docker_for_windows16_768x321.png', 'docker_for_windows16_768x321.png', '', '/uploads/2018/01/docker_for_windows16_768x321.png', 'picture', 'image/png', 1, '2018-01-11 03:50:12', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (202, 10, 0, 'docker_for_windows5.png', 'docker_for_windows5.png', '', '/uploads/2018/01/docker_for_windows5.png', 'picture', 'image/png', 1, '2018-01-11 03:50:12', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (203, 10, 0, 'docker_for_windows7.png', 'docker_for_windows7.png', '', '/uploads/2018/01/docker_for_windows7.png', 'picture', 'image/png', 1, '2018-01-11 03:50:12', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (204, 10, 0, 'docker_for_windows6.png', 'docker_for_windows6.png', '', '/uploads/2018/01/docker_for_windows6.png', 'picture', 'image/png', 1, '2018-01-11 03:50:12', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (205, 10, 0, 'docker_for_windows8_768x601.png', 'docker_for_windows8_768x601.png', '', '/uploads/2018/01/docker_for_windows8_768x601.png', 'picture', 'image/png', 1, '2018-01-11 03:50:12', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (206, 10, 0, 'coffee.png', 'coffee.png', '', '/uploads/2018/01/coffee.png', 'picture', 'image/png', 1, '2018-01-12 03:55:42', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (207, 10, 0, 'zphal-logo.png', 'zphal-logo.png', '', '/uploads/cover/zphal-logo.png', 'picture', 'image/png', 1, '2018-01-12 09:08:40', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (208, 10, 0, 'demo_for_zphal.gif', 'demo_for_zphal.gif', '', '/uploads/2018/01/demo_for_zphal.gif', 'picture', 'image/gif', 1, '2018-01-12 09:21:42', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (209, 10, 0, 'zphal1_1.png', 'zphal1_1.png', '', '/uploads/2018/01/zphal1_1.png', 'picture', 'image/png', 1, '2018-01-12 10:05:20', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (210, 10, 0, 'php_phalcon_logo_1.jpg', 'php_phalcon_logo_1.jpg', '', '/uploads/2018/01/php_phalcon_logo_1.jpg', 'picture', 'image/jpeg', 1, '2018-01-14 14:52:56', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (211, 10, 0, 'fenye_class_1.png', 'fenye_class_1.png', '', '/uploads/2018/01/fenye_class_1.png', 'picture', 'image/png', 1, '2018-01-14 19:29:45', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (212, 10, 0, 'fenye_class_2.png', 'fenye_class_2.png', '', '/uploads/2018/01/fenye_class_2.png', 'picture', 'image/png', 1, '2018-01-14 19:29:45', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (213, 10, 0, '循环链表.png', '循环链表.png', '', '/uploads/2018/01/循环链表.png', 'picture', 'image/png', 1, '2018-01-15 03:51:13', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (214, 10, 0, '单链表.png', '单链表.png', '', '/uploads/2018/01/单链表.png', 'picture', 'image/png', 1, '2018-01-15 03:51:13', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (215, 10, 0, '双向链表.png', '双向链表.png', '', '/uploads/2018/01/双向链表.png', 'picture', 'image/png', 1, '2018-01-15 03:51:13', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (216, 10, 0, '栈.png', '栈.png', '', '/uploads/2018/01/栈.png', 'picture', 'image/png', 1, '2018-01-15 04:11:20', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (217, 10, 0, '队列.png', '队列.png', '', '/uploads/2018/01/队列.png', 'picture', 'image/png', 1, '2018-01-15 04:30:44', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (218, 10, 0, '树.png', '树.png', '', '/uploads/2018/01/树.png', 'picture', 'image/png', 1, '2018-01-15 06:05:57', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (219, 10, 0, '树_普通.png', '树_普通.png', '', '/uploads/2018/01/树_普通.png', 'picture', 'image/png', 1, '2018-01-15 06:48:08', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (220, 10, 0, '树_完全二叉树.png', '树_完全二叉树.png', '', '/uploads/2018/01/树_完全二叉树.png', 'picture', 'image/png', 1, '2018-01-15 06:48:08', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (221, 10, 0, '树_完全二叉树_2.png', '树_完全二叉树_2.png', '', '/uploads/2018/01/树_完全二叉树_2.png', 'picture', 'image/png', 1, '2018-01-15 06:48:08', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (222, 10, 0, '最小堆.png', '最小堆.png', '', '/uploads/2018/01/最小堆.png', 'picture', 'image/png', 1, '2018-01-16 09:29:11', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (223, 10, 0, '最大堆.png', '最大堆.png', '', '/uploads/2018/01/最大堆.png', 'picture', 'image/png', 1, '2018-01-16 09:29:11', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (224, 10, 0, '二叉排序树.png', '二叉排序树.png', '', '/uploads/2018/01/二叉排序树.png', 'picture', 'image/png', 1, '2018-01-16 09:29:11', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (225, 10, 0, '平衡二叉树.png', '平衡二叉树.png', '', '/uploads/2018/01/平衡二叉树.png', 'picture', 'image/png', 1, '2018-01-16 09:29:11', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (226, 10, 0, 'leetcode-logo.png', 'leetcode-logo.png', '', '/uploads/cover/leetcode-logo.png', 'picture', 'image/png', 1, '2018-01-24 06:18:30', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (227, 10, 0, 'golang-logo2.png', 'golang-logo2.png', '', '/uploads/cover/golang-logo2.png', 'picture', 'image/png', 1, '2018-01-24 09:38:21', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (228, 10, 0, 'install_docker_in_centos.png', 'install_docker_in_centos.png', '', '/uploads/2018/02/install_docker_in_centos.png', 'picture', 'image/png', 1, '2018-02-08 02:51:30', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (229, 10, 0, 'docker_dockerfile.jpg', 'docker_dockerfile.jpg', '', '/uploads/2018/02/docker_dockerfile.jpg', 'picture', 'image/jpeg', 1, '2018-02-10 19:13:27', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (230, 10, 0, 'swiper1.gif', 'swiper1.gif', '', '/uploads/2018/02/swiper1.gif', 'picture', 'image/gif', 1, '2018-02-17 09:22:40', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (231, 10, 0, 'swiper3.gif', 'swiper3.gif', '', '/uploads/2018/02/swiper3.gif', 'picture', 'image/gif', 1, '2018-02-17 09:22:40', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (232, 10, 0, 'swiper2.gif', 'swiper2.gif', '', '/uploads/2018/02/swiper2.gif', 'picture', 'image/gif', 1, '2018-02-17 09:22:40', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (233, 10, 0, 'aliyun_CAA.png', 'aliyun_CAA.png', '', '/uploads/2018/02/aliyun_CAA.png', 'picture', 'image/png', 1, '2018-02-25 19:04:46', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (234, 10, 0, 'HTTPS_Security.png', 'HTTPS_Security.png', '', '/uploads/2018/02/HTTPS_Security.png', 'picture', 'image/png', 1, '2018-02-25 19:04:46', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (235, 10, 0, 'HTTPS_Security2.png', 'HTTPS_Security2.png', '', '/uploads/2018/02/HTTPS_Security2.png', 'picture', 'image/png', 1, '2018-02-25 19:11:43', '0000-00-00 00:00:00', NULL);
INSERT INTO `pt_resource` VALUES (236, 10, 0, 'IMG_2875.PNG', 'IMG_2875', 'asdasdasdasd', '/uploads/2019/01/c74724b558a4a8f6a058861e2c999dc5.PNG', 'picture', 'image/png', 1, '2019-01-27 08:35:11', '2019-01-27 08:36:32', '2019-01-27 08:36:48');

-- ----------------------------
-- Table structure for pt_resource_meta
-- ----------------------------
DROP TABLE IF EXISTS `pt_resource_meta`;
CREATE TABLE `pt_resource_meta`  (
  `meta_id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT 'id',
  `resource_id` int(11) UNSIGNED NOT NULL DEFAULT 0 COMMENT '资源id',
  `meta_key` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT '' COMMENT '设置的key',
  `meta_value` text CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '设置的value',
  PRIMARY KEY (`meta_id`) USING BTREE,
  INDEX `resource_id`(`resource_id`) USING BTREE,
  INDEX `meta_key`(`meta_key`(191)) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Table structure for pt_subject
-- ----------------------------
DROP TABLE IF EXISTS `pt_subject`;
CREATE TABLE `pt_subject`  (
  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT '专题 id',
  `parent_id` int(11) NOT NULL DEFAULT 0 COMMENT '父id',
  `name` varchar(256) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '专题名称',
  `slug` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '专题缩略名',
  `description` varchar(500) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT '' COMMENT '描述',
  `cover_image` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '封面图',
  `is_end` tinyint(1) NOT NULL DEFAULT 0 COMMENT '是否末级；1是 0不是',
  `count` int(11) NOT NULL DEFAULT 0 COMMENT '拥有文章数量',
  `last_updated` datetime(0) NOT NULL DEFAULT '1000-01-01 00:00:00' COMMENT '上次更新',
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `subject_slug`(`slug`(191)) USING BTREE,
  INDEX `subkect_parent`(`parent_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 28 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci COMMENT = '专题表' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of pt_subject
-- ----------------------------
INSERT INTO `pt_subject` VALUES (1, 0, 'PHP', 'php', 'PHP相关的技术，框架，进阶等', 'uploads/cover/php-logo.jpg', 0, 17, '2018-02-20 01:12:51');
INSERT INTO `pt_subject` VALUES (2, 1, 'Phalcon', 'phalcon', 'Phalcon框架的系列文章；包含学习笔记，最佳实践，填坑记录等。', 'uploads/cover/phalcon-logo.png', 0, 3, '2018-02-20 01:12:51');
INSERT INTO `pt_subject` VALUES (3, 1, 'ThinkPHP', 'thinkphp', 'ThinkPHP框架的一些实践，封装等。', 'uploads/cover/thinkphp-logo-yellow.jpg', 0, 2, '2018-01-08 18:01:44');
INSERT INTO `pt_subject` VALUES (4, 1, 'workerman', 'workerman', '使用workerman构建应用的一些记录。', 'uploads/cover/workerman-logo2.png', 0, 3, '2018-02-06 11:33:12');
INSERT INTO `pt_subject` VALUES (5, 0, 'Golang', 'golang', 'go语言学习之路', 'uploads/cover/go-logo-none.png', 0, 1, '2018-01-24 17:38:47');
INSERT INTO `pt_subject` VALUES (6, 1, 'Swoole', 'swoole', '这里记录Swoole学习笔记，Swoole实践，解决方案等。', 'uploads/cover/swoole-logo.jpg', 0, 0, '1000-01-01 00:00:00');
INSERT INTO `pt_subject` VALUES (7, 1, 'PHP基础', 'basic-php', '这里记录PHP的一些基础知识，学习笔记。', 'uploads/cover/php-basic.png', 0, 4, '2018-01-11 01:36:33');
INSERT INTO `pt_subject` VALUES (8, 1, 'PHP技术进阶', 'php-development', '汇总PHP相关的技术进阶，特性实战，最佳实践，技巧等。', 'uploads/cover/php-development.jpg', 0, 1, '2018-01-05 17:26:56');
INSERT INTO `pt_subject` VALUES (9, 0, '数据库', 'database', '各种数据库的学习与实践。', 'uploads/cover/database-logo-white.jpg', 0, 1, '2018-01-08 15:58:50');
INSERT INTO `pt_subject` VALUES (10, 9, 'MySQL', 'mysql', 'MySQL数据库的学习笔记；MySQL优化；MySQL实践；填坑记录等。', 'uploads/cover/mysql-logo.png', 0, 1, '2018-01-08 15:58:50');
INSERT INTO `pt_subject` VALUES (11, 9, 'Redis', 'redis', 'Redis的使用姿势；Redis在各种应用场景中的实践。', 'uploads/cover/redis-logo.png', 0, 0, '1000-01-01 00:00:00');
INSERT INTO `pt_subject` VALUES (12, 0, '数据结构与算法', 'data-structures-and-algorithms', '修炼内功。', 'uploads/cover/using-computer.png', 0, 6, '2018-02-07 14:42:19');
INSERT INTO `pt_subject` VALUES (13, 12, '数据结构', 'data-structures', '记录数据结构的基础知识。', 'uploads/cover/datastruct-three.png', 0, 1, '2018-01-23 14:43:05');
INSERT INTO `pt_subject` VALUES (14, 12, '算法', 'algorithms', '算法是一条漫长的路。', 'uploads/cover/suanfa.png', 0, 0, '1000-01-01 00:00:00');
INSERT INTO `pt_subject` VALUES (15, 0, 'JavaScript', 'javascript', '后端程序猿中的JavaScript。', 'uploads/cover/javascript-logo.png', 0, 7, '2018-02-17 20:55:22');
INSERT INTO `pt_subject` VALUES (16, 15, 'JQuery', 'jquery', '老夫觉得JQuery永垂不朽。', 'uploads/cover/jquery-logo.png', 0, 0, '1000-01-01 00:00:00');
INSERT INTO `pt_subject` VALUES (17, 15, 'JS实例库', 'javascript-demo', '有时候我们只需要做大自然的搬运工，这里存储以后可能会用到的砖头。', 'uploads/cover/js-shili.jpg', 0, 4, '2018-01-08 17:41:57');
INSERT INTO `pt_subject` VALUES (18, 0, '系统和运维', 'system-and-operation', '容器技术，运维技术等系统相关。', 'uploads/cover/server-operating-system.png', 0, 9, '2018-05-02 04:14:22');
INSERT INTO `pt_subject` VALUES (19, 18, 'Linux', 'linux-system', 'Linux系统学习和实战。', 'uploads/cover/linux-logo.jpg', 0, 4, '2018-05-02 04:14:22');
INSERT INTO `pt_subject` VALUES (20, 18, 'Docker', 'docker', 'Docker技术的应用。', 'uploads/cover/docker-logo.png', 0, 5, '2018-02-11 11:30:46');
INSERT INTO `pt_subject` VALUES (21, 0, 'Git', 'git', 'Git版本管理工具的使用。', 'uploads/cover/git-logo.jpg', 0, 3, '2018-01-10 00:06:27');
INSERT INTO `pt_subject` VALUES (22, 0, '网络和通信', 'network-and-communication', '计算机通信和网络的应用。', 'uploads/cover/Information-communication.jpg', 0, 2, '2018-02-26 03:07:54');
INSERT INTO `pt_subject` VALUES (23, 0, '开发工具', 'development-tool', '在开发过程中用到的实用工具。', 'uploads/cover/junior-mechanical-system.png', 0, 4, '2018-01-11 10:34:33');
INSERT INTO `pt_subject` VALUES (24, 1, 'PHP类库集', 'php-libraries', '实用的类库，拓展，都在这里。下次需要信手拈来。', 'uploads/cover/php-library-logo.jpg', 0, 3, '2018-01-11 01:48:33');
INSERT INTO `pt_subject` VALUES (25, 15, 'JS类库集', 'javascript-libraries', '实用的类库的介绍，使用，实例等合集。', 'uploads/cover/javascript-libraries.jpg', 0, 3, '2018-02-17 20:55:22');
INSERT INTO `pt_subject` VALUES (26, 1, 'zPhal', 'zphal', '我的个人开源项目，基于Phalcon的博客系统。', 'uploads/cover/zphal-logo.png', 0, 1, '2018-01-13 10:39:15');
INSERT INTO `pt_subject` VALUES (27, 12, 'LeetCode', 'leetcode', 'LeetCode刷题笔记', 'uploads/cover/leetcode-logo.png', 0, 5, '2018-02-07 14:42:19');
INSERT INTO `pt_subject` VALUES (28, 5, 'Golang基础', 'golang-basic', '记录Go语言的一些基础知识和学习笔记。', 'uploads/cover/golang-logo2.png', 0, 1, '2018-01-24 17:38:47');

-- ----------------------------
-- Table structure for pt_subject_relationships
-- ----------------------------
DROP TABLE IF EXISTS `pt_subject_relationships`;
CREATE TABLE `pt_subject_relationships`  (
  `object_id` int(11) UNSIGNED NOT NULL DEFAULT 0 COMMENT '附属于专题的项目id（一般是文章）',
  `subject_id` int(11) UNSIGNED NOT NULL DEFAULT 0 COMMENT '专题id',
  `order_num` int(11) NOT NULL DEFAULT 0 COMMENT '排序值',
  PRIMARY KEY (`object_id`, `subject_id`) USING BTREE,
  INDEX `subject_id`(`subject_id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci COMMENT = '专题关系表' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of pt_subject_relationships
-- ----------------------------
INSERT INTO `pt_subject_relationships` VALUES (3, 0, 0);
INSERT INTO `pt_subject_relationships` VALUES (4, 0, 0);
INSERT INTO `pt_subject_relationships` VALUES (6, 0, 0);
INSERT INTO `pt_subject_relationships` VALUES (7, 0, 0);
INSERT INTO `pt_subject_relationships` VALUES (8, 4, 0);
INSERT INTO `pt_subject_relationships` VALUES (9, 8, 0);
INSERT INTO `pt_subject_relationships` VALUES (11, 0, 0);
INSERT INTO `pt_subject_relationships` VALUES (13, 17, 0);
INSERT INTO `pt_subject_relationships` VALUES (16, 17, 0);
INSERT INTO `pt_subject_relationships` VALUES (18, 17, 0);
INSERT INTO `pt_subject_relationships` VALUES (22, 10, 0);
INSERT INTO `pt_subject_relationships` VALUES (23, 7, 0);
INSERT INTO `pt_subject_relationships` VALUES (24, 19, 0);
INSERT INTO `pt_subject_relationships` VALUES (25, 17, 0);
INSERT INTO `pt_subject_relationships` VALUES (26, 3, 0);
INSERT INTO `pt_subject_relationships` VALUES (27, 3, 0);
INSERT INTO `pt_subject_relationships` VALUES (30, 7, 0);
INSERT INTO `pt_subject_relationships` VALUES (31, 21, 0);
INSERT INTO `pt_subject_relationships` VALUES (32, 21, 0);
INSERT INTO `pt_subject_relationships` VALUES (37, 19, 0);
INSERT INTO `pt_subject_relationships` VALUES (40, 0, 0);
INSERT INTO `pt_subject_relationships` VALUES (43, 21, 0);
INSERT INTO `pt_subject_relationships` VALUES (44, 7, 0);
INSERT INTO `pt_subject_relationships` VALUES (45, 0, 0);
INSERT INTO `pt_subject_relationships` VALUES (46, 23, 0);
INSERT INTO `pt_subject_relationships` VALUES (48, 23, 0);
INSERT INTO `pt_subject_relationships` VALUES (49, 20, 0);
INSERT INTO `pt_subject_relationships` VALUES (50, 24, 0);
INSERT INTO `pt_subject_relationships` VALUES (51, 24, 0);
INSERT INTO `pt_subject_relationships` VALUES (52, 25, 0);
INSERT INTO `pt_subject_relationships` VALUES (53, 25, 0);
INSERT INTO `pt_subject_relationships` VALUES (55, 7, 0);
INSERT INTO `pt_subject_relationships` VALUES (56, 24, 0);
INSERT INTO `pt_subject_relationships` VALUES (57, 23, 0);
INSERT INTO `pt_subject_relationships` VALUES (58, 23, 0);
INSERT INTO `pt_subject_relationships` VALUES (59, 20, 0);
INSERT INTO `pt_subject_relationships` VALUES (61, 26, 0);
INSERT INTO `pt_subject_relationships` VALUES (62, 2, 0);
INSERT INTO `pt_subject_relationships` VALUES (63, 0, 0);
INSERT INTO `pt_subject_relationships` VALUES (64, 4, 0);
INSERT INTO `pt_subject_relationships` VALUES (65, 13, 0);
INSERT INTO `pt_subject_relationships` VALUES (66, 27, 0);
INSERT INTO `pt_subject_relationships` VALUES (67, 28, 0);
INSERT INTO `pt_subject_relationships` VALUES (68, 27, 0);
INSERT INTO `pt_subject_relationships` VALUES (69, 22, 0);
INSERT INTO `pt_subject_relationships` VALUES (71, 27, 0);
INSERT INTO `pt_subject_relationships` VALUES (72, 2, 0);
INSERT INTO `pt_subject_relationships` VALUES (73, 4, 0);
INSERT INTO `pt_subject_relationships` VALUES (74, 27, 0);
INSERT INTO `pt_subject_relationships` VALUES (75, 27, 0);
INSERT INTO `pt_subject_relationships` VALUES (76, 20, 0);
INSERT INTO `pt_subject_relationships` VALUES (77, 20, 0);
INSERT INTO `pt_subject_relationships` VALUES (79, 20, 0);
INSERT INTO `pt_subject_relationships` VALUES (80, 25, 0);
INSERT INTO `pt_subject_relationships` VALUES (81, 2, 0);
INSERT INTO `pt_subject_relationships` VALUES (82, 22, 0);
INSERT INTO `pt_subject_relationships` VALUES (83, 19, 0);
INSERT INTO `pt_subject_relationships` VALUES (84, 0, 0);
INSERT INTO `pt_subject_relationships` VALUES (85, 0, 0);
INSERT INTO `pt_subject_relationships` VALUES (86, 19, 0);

-- ----------------------------
-- Table structure for pt_term
-- ----------------------------
DROP TABLE IF EXISTS `pt_term`;
CREATE TABLE `pt_term`  (
  `term_id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT '条件id',
  `name` varchar(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '条件名称',
  `slug` varchar(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT '' COMMENT '缩略名',
  `description` varchar(500) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT '' COMMENT '描述',
  `count` int(11) UNSIGNED NOT NULL DEFAULT 0 COMMENT '拥有的数目',
  PRIMARY KEY (`term_id`) USING BTREE,
  INDEX `slug`(`slug`(191)) USING BTREE,
  INDEX `name`(`name`(191)) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 74 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of pt_term
-- ----------------------------
INSERT INTO `pt_term` VALUES (1, '未分类', 'uncategorized', '', 0);
INSERT INTO `pt_term` VALUES (2, '随笔', 'essay', '', 0);
INSERT INTO `pt_term` VALUES (3, '生活', 'life', '', 0);
INSERT INTO `pt_term` VALUES (4, '杂谈', 'tattle', '', 0);
INSERT INTO `pt_term` VALUES (5, '学习笔记', 'study-notes', '', 0);
INSERT INTO `pt_term` VALUES (6, 'PHP', 'php', '', 0);
INSERT INTO `pt_term` VALUES (7, 'ThinkPHP', 'thinkphp', '', 0);
INSERT INTO `pt_term` VALUES (8, 'Phalcon', 'phalcon', '', 0);
INSERT INTO `pt_term` VALUES (9, 'Swoole', 'swoole', '', 0);
INSERT INTO `pt_term` VALUES (10, 'Golang', 'golang', '', 0);
INSERT INTO `pt_term` VALUES (11, 'JavaScript', 'javascript', '', 0);
INSERT INTO `pt_term` VALUES (12, 'JQuery', 'jquery', '', 0);
INSERT INTO `pt_term` VALUES (13, '数据库', 'database', '', 0);
INSERT INTO `pt_term` VALUES (14, 'MySQL', 'mysql', '', 0);
INSERT INTO `pt_term` VALUES (15, 'Redis', 'redis', '', 0);
INSERT INTO `pt_term` VALUES (16, 'WebServer', 'webserver', '', 0);
INSERT INTO `pt_term` VALUES (17, 'Apache', 'apache', '', 0);
INSERT INTO `pt_term` VALUES (18, 'Nginx', 'nginx', '', 0);
INSERT INTO `pt_term` VALUES (19, '前端综合', 'frontend', '', 0);
INSERT INTO `pt_term` VALUES (20, '后端综合', 'backend', '', 0);
INSERT INTO `pt_term` VALUES (21, '二次开发', 'secondary-development', '', 0);
INSERT INTO `pt_term` VALUES (22, '微信开发', 'wechat-development', '', 0);
INSERT INTO `pt_term` VALUES (23, 'WordPress', 'wordpress', '', 0);
INSERT INTO `pt_term` VALUES (24, '计算机基础', 'basical-computer', '', 0);
INSERT INTO `pt_term` VALUES (25, 'Linux', 'linux', '', 0);
INSERT INTO `pt_term` VALUES (26, '数据结构和算法', 'data-structure-and-algorithm', '', 0);
INSERT INTO `pt_term` VALUES (27, '架构与设计', 'architecture-and-design', '', 0);
INSERT INTO `pt_term` VALUES (28, '类库与拓展', 'library-and-expansion', '', 0);
INSERT INTO `pt_term` VALUES (29, '系统运维', 'system-operation-and-maintenance', '', 0);
INSERT INTO `pt_term` VALUES (30, 'Docker', 'docker', '', 0);
INSERT INTO `pt_term` VALUES (31, '感悟', '感悟', '', 0);
INSERT INTO `pt_term` VALUES (32, '学习', '学习', '', 0);
INSERT INTO `pt_term` VALUES (33, '生活', '生活', '', 0);
INSERT INTO `pt_term` VALUES (34, 'workerman', 'workerman', '', 0);
INSERT INTO `pt_term` VALUES (35, 'workerman', 'workerman', '', 0);
INSERT INTO `pt_term` VALUES (36, 'PHP', 'PHP', '', 0);
INSERT INTO `pt_term` VALUES (37, 'Redis', 'Redis', '', 0);
INSERT INTO `pt_term` VALUES (38, '消息队列', '消息队列', '', 0);
INSERT INTO `pt_term` VALUES (39, '公众号', '公众号', '', 0);
INSERT INTO `pt_term` VALUES (40, '微信', '微信', '', 0);
INSERT INTO `pt_term` VALUES (41, 'JavaScript', 'JavaScript', '', 0);
INSERT INTO `pt_term` VALUES (42, 'JQuery', 'JQuery', '', 0);
INSERT INTO `pt_term` VALUES (44, 'ThinkPHP', 'ThinkPHP', '', 0);
INSERT INTO `pt_term` VALUES (45, '算法', '算法', '', 0);
INSERT INTO `pt_term` VALUES (46, 'MySQL', 'MySQL', '', 0);
INSERT INTO `pt_term` VALUES (47, 'Linux', 'Linux', '', 0);
INSERT INTO `pt_term` VALUES (48, 'Nginx', 'Nginx', '', 0);
INSERT INTO `pt_term` VALUES (49, 'composer', 'composer', '', 0);
INSERT INTO `pt_term` VALUES (50, '数据', '数据', '', 0);
INSERT INTO `pt_term` VALUES (51, '网络安全', '网络安全', '', 0);
INSERT INTO `pt_term` VALUES (52, '版本控制', '版本控制', '', 0);
INSERT INTO `pt_term` VALUES (53, '开发工具', 'develop-tools', '', 0);
INSERT INTO `pt_term` VALUES (54, 'Git', 'git', '', 0);
INSERT INTO `pt_term` VALUES (55, 'WordPress', 'WordPress', '', 0);
INSERT INTO `pt_term` VALUES (56, '前端', '前端', '', 0);
INSERT INTO `pt_term` VALUES (57, 'HTTPS', 'HTTPS', '', 0);
INSERT INTO `pt_term` VALUES (58, 'Apache', 'Apache', '', 0);
INSERT INTO `pt_term` VALUES (59, 'HTTP2', 'HTTP2', '', 0);
INSERT INTO `pt_term` VALUES (60, 'OSS', 'OSS', '', 0);
INSERT INTO `pt_term` VALUES (62, '压力测试', '压力测试', '', 0);
INSERT INTO `pt_term` VALUES (63, '文档', '文档', '', 0);
INSERT INTO `pt_term` VALUES (64, '容器技术', '容器技术', '', 0);
INSERT INTO `pt_term` VALUES (65, 'Guzzle', 'Guzzle', '', 0);
INSERT INTO `pt_term` VALUES (66, '网络抓包', '网络抓包', '', 0);
INSERT INTO `pt_term` VALUES (67, 'zPhal', 'zphal', '', 0);
INSERT INTO `pt_term` VALUES (68, 'zPhal', 'zPhal', '', 0);
INSERT INTO `pt_term` VALUES (69, 'Phalcon', 'Phalcon', '', 0);
INSERT INTO `pt_term` VALUES (70, '通讯', '通讯', '', 0);
INSERT INTO `pt_term` VALUES (71, 'LeetCode', 'LeetCode', '', 0);
INSERT INTO `pt_term` VALUES (72, 'go', 'go', '', 0);
INSERT INTO `pt_term` VALUES (73, 'Docker', 'Docker', '', 0);
INSERT INTO `pt_term` VALUES (74, 'Git', 'Git', '', 0);
INSERT INTO `pt_term` VALUES (75, 'test', 'test', '123', 1);
INSERT INTO `pt_term` VALUES (76, 'test2', 'test2', '123333', 1);
INSERT INTO `pt_term` VALUES (78, 'test', 'test', '123', 1);

-- ----------------------------
-- Table structure for pt_term_meta
-- ----------------------------
DROP TABLE IF EXISTS `pt_term_meta`;
CREATE TABLE `pt_term_meta`  (
  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT 'id',
  `term_id` int(11) UNSIGNED NOT NULL DEFAULT 0 COMMENT '分类条目id',
  `meta_key` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT '' COMMENT '属性名称',
  `meta_value` text CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '属性值',
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `term_id`(`term_id`) USING BTREE,
  INDEX `meta_key`(`meta_key`(191)) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Table structure for pt_term_relationships
-- ----------------------------
DROP TABLE IF EXISTS `pt_term_relationships`;
CREATE TABLE `pt_term_relationships`  (
  `object_id` int(11) UNSIGNED NOT NULL DEFAULT 0 COMMENT '归属分类的对象id',
  `term_taxonomy_id` int(11) UNSIGNED NOT NULL DEFAULT 0 COMMENT '所属分类id',
  `term_order` int(11) NOT NULL DEFAULT 0 COMMENT '排序',
  PRIMARY KEY (`object_id`, `term_taxonomy_id`) USING BTREE,
  INDEX `term_taxonomy_id`(`term_taxonomy_id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of pt_term_relationships
-- ----------------------------
INSERT INTO `pt_term_relationships` VALUES (3, 2, 0);
INSERT INTO `pt_term_relationships` VALUES (3, 4, 0);
INSERT INTO `pt_term_relationships` VALUES (3, 31, 0);
INSERT INTO `pt_term_relationships` VALUES (4, 5, 0);
INSERT INTO `pt_term_relationships` VALUES (4, 32, 0);
INSERT INTO `pt_term_relationships` VALUES (5, 2, 0);
INSERT INTO `pt_term_relationships` VALUES (5, 4, 0);
INSERT INTO `pt_term_relationships` VALUES (5, 31, 0);
INSERT INTO `pt_term_relationships` VALUES (6, 3, 0);
INSERT INTO `pt_term_relationships` VALUES (6, 33, 0);
INSERT INTO `pt_term_relationships` VALUES (7, 3, 0);
INSERT INTO `pt_term_relationships` VALUES (7, 32, 0);
INSERT INTO `pt_term_relationships` VALUES (8, 6, 0);
INSERT INTO `pt_term_relationships` VALUES (8, 34, 0);
INSERT INTO `pt_term_relationships` VALUES (8, 35, 0);
INSERT INTO `pt_term_relationships` VALUES (9, 6, 0);
INSERT INTO `pt_term_relationships` VALUES (9, 15, 0);
INSERT INTO `pt_term_relationships` VALUES (9, 36, 0);
INSERT INTO `pt_term_relationships` VALUES (9, 37, 0);
INSERT INTO `pt_term_relationships` VALUES (9, 38, 0);
INSERT INTO `pt_term_relationships` VALUES (10, 3, 0);
INSERT INTO `pt_term_relationships` VALUES (10, 33, 0);
INSERT INTO `pt_term_relationships` VALUES (11, 21, 0);
INSERT INTO `pt_term_relationships` VALUES (11, 22, 0);
INSERT INTO `pt_term_relationships` VALUES (11, 39, 0);
INSERT INTO `pt_term_relationships` VALUES (11, 40, 0);
INSERT INTO `pt_term_relationships` VALUES (12, 21, 0);
INSERT INTO `pt_term_relationships` VALUES (12, 22, 0);
INSERT INTO `pt_term_relationships` VALUES (12, 39, 0);
INSERT INTO `pt_term_relationships` VALUES (12, 40, 0);
INSERT INTO `pt_term_relationships` VALUES (13, 11, 0);
INSERT INTO `pt_term_relationships` VALUES (13, 41, 0);
INSERT INTO `pt_term_relationships` VALUES (14, 3, 0);
INSERT INTO `pt_term_relationships` VALUES (14, 33, 0);
INSERT INTO `pt_term_relationships` VALUES (15, 3, 0);
INSERT INTO `pt_term_relationships` VALUES (15, 33, 0);
INSERT INTO `pt_term_relationships` VALUES (16, 11, 0);
INSERT INTO `pt_term_relationships` VALUES (16, 41, 0);
INSERT INTO `pt_term_relationships` VALUES (17, 3, 0);
INSERT INTO `pt_term_relationships` VALUES (17, 33, 0);
INSERT INTO `pt_term_relationships` VALUES (18, 11, 0);
INSERT INTO `pt_term_relationships` VALUES (18, 12, 0);
INSERT INTO `pt_term_relationships` VALUES (18, 41, 0);
INSERT INTO `pt_term_relationships` VALUES (18, 42, 0);
INSERT INTO `pt_term_relationships` VALUES (19, 6, 0);
INSERT INTO `pt_term_relationships` VALUES (19, 7, 0);
INSERT INTO `pt_term_relationships` VALUES (19, 11, 0);
INSERT INTO `pt_term_relationships` VALUES (19, 36, 0);
INSERT INTO `pt_term_relationships` VALUES (19, 41, 0);
INSERT INTO `pt_term_relationships` VALUES (19, 44, 0);
INSERT INTO `pt_term_relationships` VALUES (20, 6, 0);
INSERT INTO `pt_term_relationships` VALUES (20, 7, 0);
INSERT INTO `pt_term_relationships` VALUES (20, 36, 0);
INSERT INTO `pt_term_relationships` VALUES (20, 44, 0);
INSERT INTO `pt_term_relationships` VALUES (21, 6, 0);
INSERT INTO `pt_term_relationships` VALUES (21, 26, 0);
INSERT INTO `pt_term_relationships` VALUES (21, 36, 0);
INSERT INTO `pt_term_relationships` VALUES (21, 45, 0);
INSERT INTO `pt_term_relationships` VALUES (22, 13, 0);
INSERT INTO `pt_term_relationships` VALUES (22, 14, 0);
INSERT INTO `pt_term_relationships` VALUES (22, 46, 0);
INSERT INTO `pt_term_relationships` VALUES (23, 6, 0);
INSERT INTO `pt_term_relationships` VALUES (23, 36, 0);
INSERT INTO `pt_term_relationships` VALUES (24, 25, 0);
INSERT INTO `pt_term_relationships` VALUES (24, 47, 0);
INSERT INTO `pt_term_relationships` VALUES (25, 11, 0);
INSERT INTO `pt_term_relationships` VALUES (25, 41, 0);
INSERT INTO `pt_term_relationships` VALUES (26, 7, 0);
INSERT INTO `pt_term_relationships` VALUES (26, 18, 0);
INSERT INTO `pt_term_relationships` VALUES (26, 44, 0);
INSERT INTO `pt_term_relationships` VALUES (26, 48, 0);
INSERT INTO `pt_term_relationships` VALUES (27, 6, 0);
INSERT INTO `pt_term_relationships` VALUES (27, 7, 0);
INSERT INTO `pt_term_relationships` VALUES (27, 36, 0);
INSERT INTO `pt_term_relationships` VALUES (27, 44, 0);
INSERT INTO `pt_term_relationships` VALUES (28, 6, 0);
INSERT INTO `pt_term_relationships` VALUES (28, 49, 0);
INSERT INTO `pt_term_relationships` VALUES (29, 5, 0);
INSERT INTO `pt_term_relationships` VALUES (29, 6, 0);
INSERT INTO `pt_term_relationships` VALUES (29, 50, 0);
INSERT INTO `pt_term_relationships` VALUES (30, 6, 0);
INSERT INTO `pt_term_relationships` VALUES (30, 51, 0);
INSERT INTO `pt_term_relationships` VALUES (31, 52, 0);
INSERT INTO `pt_term_relationships` VALUES (31, 53, 0);
INSERT INTO `pt_term_relationships` VALUES (31, 54, 0);
INSERT INTO `pt_term_relationships` VALUES (32, 52, 0);
INSERT INTO `pt_term_relationships` VALUES (32, 53, 0);
INSERT INTO `pt_term_relationships` VALUES (32, 54, 0);
INSERT INTO `pt_term_relationships` VALUES (33, 16, 0);
INSERT INTO `pt_term_relationships` VALUES (33, 18, 0);
INSERT INTO `pt_term_relationships` VALUES (33, 48, 0);
INSERT INTO `pt_term_relationships` VALUES (34, 21, 0);
INSERT INTO `pt_term_relationships` VALUES (34, 23, 0);
INSERT INTO `pt_term_relationships` VALUES (34, 55, 0);
INSERT INTO `pt_term_relationships` VALUES (35, 23, 0);
INSERT INTO `pt_term_relationships` VALUES (35, 55, 0);
INSERT INTO `pt_term_relationships` VALUES (36, 19, 0);
INSERT INTO `pt_term_relationships` VALUES (36, 56, 0);
INSERT INTO `pt_term_relationships` VALUES (37, 6, 0);
INSERT INTO `pt_term_relationships` VALUES (37, 25, 0);
INSERT INTO `pt_term_relationships` VALUES (37, 36, 0);
INSERT INTO `pt_term_relationships` VALUES (37, 47, 0);
INSERT INTO `pt_term_relationships` VALUES (38, 23, 0);
INSERT INTO `pt_term_relationships` VALUES (38, 55, 0);
INSERT INTO `pt_term_relationships` VALUES (38, 57, 0);
INSERT INTO `pt_term_relationships` VALUES (39, 17, 0);
INSERT INTO `pt_term_relationships` VALUES (39, 20, 0);
INSERT INTO `pt_term_relationships` VALUES (39, 25, 0);
INSERT INTO `pt_term_relationships` VALUES (39, 58, 0);
INSERT INTO `pt_term_relationships` VALUES (40, 18, 0);
INSERT INTO `pt_term_relationships` VALUES (40, 20, 0);
INSERT INTO `pt_term_relationships` VALUES (40, 25, 0);
INSERT INTO `pt_term_relationships` VALUES (40, 57, 0);
INSERT INTO `pt_term_relationships` VALUES (40, 59, 0);
INSERT INTO `pt_term_relationships` VALUES (41, 18, 0);
INSERT INTO `pt_term_relationships` VALUES (41, 20, 0);
INSERT INTO `pt_term_relationships` VALUES (41, 25, 0);
INSERT INTO `pt_term_relationships` VALUES (41, 57, 0);
INSERT INTO `pt_term_relationships` VALUES (42, 7, 0);
INSERT INTO `pt_term_relationships` VALUES (42, 60, 0);
INSERT INTO `pt_term_relationships` VALUES (43, 52, 0);
INSERT INTO `pt_term_relationships` VALUES (43, 53, 0);
INSERT INTO `pt_term_relationships` VALUES (43, 54, 0);
INSERT INTO `pt_term_relationships` VALUES (44, 6, 0);
INSERT INTO `pt_term_relationships` VALUES (44, 36, 0);
INSERT INTO `pt_term_relationships` VALUES (45, 21, 0);
INSERT INTO `pt_term_relationships` VALUES (45, 23, 0);
INSERT INTO `pt_term_relationships` VALUES (45, 55, 0);
INSERT INTO `pt_term_relationships` VALUES (46, 53, 0);
INSERT INTO `pt_term_relationships` VALUES (46, 62, 0);
INSERT INTO `pt_term_relationships` VALUES (47, 21, 0);
INSERT INTO `pt_term_relationships` VALUES (47, 23, 0);
INSERT INTO `pt_term_relationships` VALUES (47, 55, 0);
INSERT INTO `pt_term_relationships` VALUES (48, 54, 0);
INSERT INTO `pt_term_relationships` VALUES (48, 63, 0);
INSERT INTO `pt_term_relationships` VALUES (49, 29, 0);
INSERT INTO `pt_term_relationships` VALUES (49, 30, 0);
INSERT INTO `pt_term_relationships` VALUES (49, 64, 0);
INSERT INTO `pt_term_relationships` VALUES (49, 73, 0);
INSERT INTO `pt_term_relationships` VALUES (50, 6, 0);
INSERT INTO `pt_term_relationships` VALUES (50, 28, 0);
INSERT INTO `pt_term_relationships` VALUES (50, 36, 0);
INSERT INTO `pt_term_relationships` VALUES (51, 6, 0);
INSERT INTO `pt_term_relationships` VALUES (51, 28, 0);
INSERT INTO `pt_term_relationships` VALUES (51, 36, 0);
INSERT INTO `pt_term_relationships` VALUES (52, 11, 0);
INSERT INTO `pt_term_relationships` VALUES (52, 12, 0);
INSERT INTO `pt_term_relationships` VALUES (52, 28, 0);
INSERT INTO `pt_term_relationships` VALUES (52, 41, 0);
INSERT INTO `pt_term_relationships` VALUES (52, 42, 0);
INSERT INTO `pt_term_relationships` VALUES (53, 11, 0);
INSERT INTO `pt_term_relationships` VALUES (53, 28, 0);
INSERT INTO `pt_term_relationships` VALUES (53, 41, 0);
INSERT INTO `pt_term_relationships` VALUES (54, 11, 0);
INSERT INTO `pt_term_relationships` VALUES (54, 19, 0);
INSERT INTO `pt_term_relationships` VALUES (54, 56, 0);
INSERT INTO `pt_term_relationships` VALUES (55, 5, 0);
INSERT INTO `pt_term_relationships` VALUES (55, 6, 0);
INSERT INTO `pt_term_relationships` VALUES (55, 36, 0);
INSERT INTO `pt_term_relationships` VALUES (56, 6, 0);
INSERT INTO `pt_term_relationships` VALUES (56, 28, 0);
INSERT INTO `pt_term_relationships` VALUES (56, 65, 0);
INSERT INTO `pt_term_relationships` VALUES (57, 53, 0);
INSERT INTO `pt_term_relationships` VALUES (57, 66, 0);
INSERT INTO `pt_term_relationships` VALUES (58, 53, 0);
INSERT INTO `pt_term_relationships` VALUES (58, 66, 0);
INSERT INTO `pt_term_relationships` VALUES (59, 29, 0);
INSERT INTO `pt_term_relationships` VALUES (59, 30, 0);
INSERT INTO `pt_term_relationships` VALUES (59, 64, 0);
INSERT INTO `pt_term_relationships` VALUES (59, 73, 0);
INSERT INTO `pt_term_relationships` VALUES (61, 67, 0);
INSERT INTO `pt_term_relationships` VALUES (61, 68, 0);
INSERT INTO `pt_term_relationships` VALUES (62, 8, 0);
INSERT INTO `pt_term_relationships` VALUES (62, 69, 0);
INSERT INTO `pt_term_relationships` VALUES (63, 6, 0);
INSERT INTO `pt_term_relationships` VALUES (63, 36, 0);
INSERT INTO `pt_term_relationships` VALUES (64, 6, 0);
INSERT INTO `pt_term_relationships` VALUES (64, 34, 0);
INSERT INTO `pt_term_relationships` VALUES (64, 35, 0);
INSERT INTO `pt_term_relationships` VALUES (64, 70, 0);
INSERT INTO `pt_term_relationships` VALUES (65, 5, 0);
INSERT INTO `pt_term_relationships` VALUES (65, 26, 0);
INSERT INTO `pt_term_relationships` VALUES (65, 32, 0);
INSERT INTO `pt_term_relationships` VALUES (66, 5, 0);
INSERT INTO `pt_term_relationships` VALUES (66, 26, 0);
INSERT INTO `pt_term_relationships` VALUES (66, 71, 0);
INSERT INTO `pt_term_relationships` VALUES (67, 5, 0);
INSERT INTO `pt_term_relationships` VALUES (67, 10, 0);
INSERT INTO `pt_term_relationships` VALUES (67, 32, 0);
INSERT INTO `pt_term_relationships` VALUES (67, 72, 0);
INSERT INTO `pt_term_relationships` VALUES (68, 5, 0);
INSERT INTO `pt_term_relationships` VALUES (68, 26, 0);
INSERT INTO `pt_term_relationships` VALUES (68, 71, 0);
INSERT INTO `pt_term_relationships` VALUES (69, 18, 0);
INSERT INTO `pt_term_relationships` VALUES (69, 20, 0);
INSERT INTO `pt_term_relationships` VALUES (69, 34, 0);
INSERT INTO `pt_term_relationships` VALUES (69, 35, 0);
INSERT INTO `pt_term_relationships` VALUES (69, 48, 0);
INSERT INTO `pt_term_relationships` VALUES (70, 1, 0);
INSERT INTO `pt_term_relationships` VALUES (71, 5, 0);
INSERT INTO `pt_term_relationships` VALUES (71, 26, 0);
INSERT INTO `pt_term_relationships` VALUES (71, 71, 0);
INSERT INTO `pt_term_relationships` VALUES (72, 8, 0);
INSERT INTO `pt_term_relationships` VALUES (72, 69, 0);
INSERT INTO `pt_term_relationships` VALUES (73, 34, 0);
INSERT INTO `pt_term_relationships` VALUES (73, 35, 0);
INSERT INTO `pt_term_relationships` VALUES (74, 5, 0);
INSERT INTO `pt_term_relationships` VALUES (74, 26, 0);
INSERT INTO `pt_term_relationships` VALUES (74, 71, 0);
INSERT INTO `pt_term_relationships` VALUES (75, 5, 0);
INSERT INTO `pt_term_relationships` VALUES (75, 26, 0);
INSERT INTO `pt_term_relationships` VALUES (75, 71, 0);
INSERT INTO `pt_term_relationships` VALUES (76, 30, 0);
INSERT INTO `pt_term_relationships` VALUES (76, 64, 0);
INSERT INTO `pt_term_relationships` VALUES (76, 73, 0);
INSERT INTO `pt_term_relationships` VALUES (77, 30, 0);
INSERT INTO `pt_term_relationships` VALUES (77, 64, 0);
INSERT INTO `pt_term_relationships` VALUES (77, 73, 0);
INSERT INTO `pt_term_relationships` VALUES (79, 30, 0);
INSERT INTO `pt_term_relationships` VALUES (79, 64, 0);
INSERT INTO `pt_term_relationships` VALUES (79, 73, 0);
INSERT INTO `pt_term_relationships` VALUES (80, 11, 0);
INSERT INTO `pt_term_relationships` VALUES (80, 28, 0);
INSERT INTO `pt_term_relationships` VALUES (80, 41, 0);
INSERT INTO `pt_term_relationships` VALUES (81, 6, 0);
INSERT INTO `pt_term_relationships` VALUES (81, 8, 0);
INSERT INTO `pt_term_relationships` VALUES (81, 69, 0);
INSERT INTO `pt_term_relationships` VALUES (82, 16, 0);
INSERT INTO `pt_term_relationships` VALUES (82, 20, 0);
INSERT INTO `pt_term_relationships` VALUES (82, 29, 0);
INSERT INTO `pt_term_relationships` VALUES (82, 51, 0);
INSERT INTO `pt_term_relationships` VALUES (82, 57, 0);
INSERT INTO `pt_term_relationships` VALUES (83, 5, 0);
INSERT INTO `pt_term_relationships` VALUES (83, 25, 0);
INSERT INTO `pt_term_relationships` VALUES (83, 47, 0);
INSERT INTO `pt_term_relationships` VALUES (84, 2, 0);
INSERT INTO `pt_term_relationships` VALUES (84, 32, 0);
INSERT INTO `pt_term_relationships` VALUES (85, 1, 0);
INSERT INTO `pt_term_relationships` VALUES (86, 20, 0);
INSERT INTO `pt_term_relationships` VALUES (86, 25, 0);
INSERT INTO `pt_term_relationships` VALUES (86, 47, 0);
INSERT INTO `pt_term_relationships` VALUES (86, 73, 0);
INSERT INTO `pt_term_relationships` VALUES (86, 74, 0);
INSERT INTO `pt_term_relationships` VALUES (87, 75, 0);
INSERT INTO `pt_term_relationships` VALUES (87, 76, 0);
INSERT INTO `pt_term_relationships` VALUES (87, 78, 0);

-- ----------------------------
-- Table structure for pt_term_taxonomy
-- ----------------------------
DROP TABLE IF EXISTS `pt_term_taxonomy`;
CREATE TABLE `pt_term_taxonomy`  (
  `term_taxonomy_id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT '分类方式id',
  `term_id` int(11) UNSIGNED NOT NULL DEFAULT 0 COMMENT 'term_id',
  `parent_term_id` int(11) UNSIGNED NOT NULL DEFAULT 0 COMMENT '父term_id',
  `level` int(11) NOT NULL DEFAULT 1 COMMENT '层级',
  `taxonomy` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT '' COMMENT '分类方式',
  `term_group` int(11) UNSIGNED NOT NULL DEFAULT 0 COMMENT '分组',
  PRIMARY KEY (`term_taxonomy_id`) USING BTREE,
  UNIQUE INDEX `term_id_taxonomy`(`term_id`, `taxonomy`) USING BTREE,
  INDEX `taxonomy`(`taxonomy`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 74 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of pt_term_taxonomy
-- ----------------------------
INSERT INTO `pt_term_taxonomy` VALUES (1, 1, 0, 1, 'category', 0);
INSERT INTO `pt_term_taxonomy` VALUES (2, 2, 0, 1, 'category', 0);
INSERT INTO `pt_term_taxonomy` VALUES (3, 3, 2, 2, 'category', 0);
INSERT INTO `pt_term_taxonomy` VALUES (4, 4, 2, 2, 'category', 0);
INSERT INTO `pt_term_taxonomy` VALUES (5, 5, 0, 1, 'category', 0);
INSERT INTO `pt_term_taxonomy` VALUES (6, 6, 0, 1, 'category', 0);
INSERT INTO `pt_term_taxonomy` VALUES (7, 7, 6, 2, 'category', 0);
INSERT INTO `pt_term_taxonomy` VALUES (8, 8, 6, 2, 'category', 0);
INSERT INTO `pt_term_taxonomy` VALUES (9, 9, 6, 2, 'category', 0);
INSERT INTO `pt_term_taxonomy` VALUES (10, 10, 0, 1, 'category', 0);
INSERT INTO `pt_term_taxonomy` VALUES (11, 11, 0, 1, 'category', 0);
INSERT INTO `pt_term_taxonomy` VALUES (12, 12, 11, 2, 'category', 0);
INSERT INTO `pt_term_taxonomy` VALUES (13, 13, 0, 1, 'category', 0);
INSERT INTO `pt_term_taxonomy` VALUES (14, 14, 13, 2, 'category', 0);
INSERT INTO `pt_term_taxonomy` VALUES (15, 15, 13, 2, 'category', 0);
INSERT INTO `pt_term_taxonomy` VALUES (16, 16, 0, 1, 'category', 0);
INSERT INTO `pt_term_taxonomy` VALUES (17, 17, 16, 2, 'category', 0);
INSERT INTO `pt_term_taxonomy` VALUES (18, 18, 16, 2, 'category', 0);
INSERT INTO `pt_term_taxonomy` VALUES (19, 19, 0, 1, 'category', 0);
INSERT INTO `pt_term_taxonomy` VALUES (20, 20, 0, 1, 'category', 0);
INSERT INTO `pt_term_taxonomy` VALUES (21, 21, 0, 1, 'category', 0);
INSERT INTO `pt_term_taxonomy` VALUES (22, 22, 21, 2, 'category', 0);
INSERT INTO `pt_term_taxonomy` VALUES (23, 23, 21, 2, 'category', 0);
INSERT INTO `pt_term_taxonomy` VALUES (24, 24, 0, 1, 'category', 0);
INSERT INTO `pt_term_taxonomy` VALUES (25, 25, 24, 2, 'category', 0);
INSERT INTO `pt_term_taxonomy` VALUES (26, 26, 24, 2, 'category', 0);
INSERT INTO `pt_term_taxonomy` VALUES (27, 27, 0, 1, 'category', 0);
INSERT INTO `pt_term_taxonomy` VALUES (28, 28, 0, 1, 'category', 0);
INSERT INTO `pt_term_taxonomy` VALUES (29, 29, 0, 1, 'category', 0);
INSERT INTO `pt_term_taxonomy` VALUES (30, 30, 29, 2, 'category', 0);
INSERT INTO `pt_term_taxonomy` VALUES (31, 31, 0, 1, 'tag', 0);
INSERT INTO `pt_term_taxonomy` VALUES (32, 32, 0, 1, 'tag', 0);
INSERT INTO `pt_term_taxonomy` VALUES (33, 33, 0, 1, 'tag', 0);
INSERT INTO `pt_term_taxonomy` VALUES (34, 34, 6, 2, 'category', 0);
INSERT INTO `pt_term_taxonomy` VALUES (35, 35, 0, 1, 'tag', 0);
INSERT INTO `pt_term_taxonomy` VALUES (36, 36, 0, 1, 'tag', 0);
INSERT INTO `pt_term_taxonomy` VALUES (37, 37, 0, 1, 'tag', 0);
INSERT INTO `pt_term_taxonomy` VALUES (38, 38, 0, 1, 'tag', 0);
INSERT INTO `pt_term_taxonomy` VALUES (39, 39, 0, 1, 'tag', 0);
INSERT INTO `pt_term_taxonomy` VALUES (40, 40, 0, 1, 'tag', 0);
INSERT INTO `pt_term_taxonomy` VALUES (41, 41, 0, 1, 'tag', 0);
INSERT INTO `pt_term_taxonomy` VALUES (42, 42, 0, 1, 'tag', 0);
INSERT INTO `pt_term_taxonomy` VALUES (44, 44, 0, 1, 'tag', 0);
INSERT INTO `pt_term_taxonomy` VALUES (45, 45, 0, 1, 'tag', 0);
INSERT INTO `pt_term_taxonomy` VALUES (46, 46, 0, 1, 'tag', 0);
INSERT INTO `pt_term_taxonomy` VALUES (47, 47, 0, 1, 'tag', 0);
INSERT INTO `pt_term_taxonomy` VALUES (48, 48, 0, 1, 'tag', 0);
INSERT INTO `pt_term_taxonomy` VALUES (49, 49, 0, 1, 'tag', 0);
INSERT INTO `pt_term_taxonomy` VALUES (50, 50, 0, 1, 'tag', 0);
INSERT INTO `pt_term_taxonomy` VALUES (51, 51, 0, 1, 'tag', 0);
INSERT INTO `pt_term_taxonomy` VALUES (52, 52, 0, 1, 'tag', 0);
INSERT INTO `pt_term_taxonomy` VALUES (53, 53, 0, 1, 'category', 0);
INSERT INTO `pt_term_taxonomy` VALUES (54, 54, 53, 2, 'category', 0);
INSERT INTO `pt_term_taxonomy` VALUES (55, 55, 0, 1, 'tag', 0);
INSERT INTO `pt_term_taxonomy` VALUES (56, 56, 0, 1, 'tag', 0);
INSERT INTO `pt_term_taxonomy` VALUES (57, 57, 0, 1, 'tag', 0);
INSERT INTO `pt_term_taxonomy` VALUES (58, 58, 0, 1, 'tag', 0);
INSERT INTO `pt_term_taxonomy` VALUES (59, 59, 0, 1, 'tag', 0);
INSERT INTO `pt_term_taxonomy` VALUES (60, 60, 0, 1, 'tag', 0);
INSERT INTO `pt_term_taxonomy` VALUES (62, 62, 0, 1, 'tag', 0);
INSERT INTO `pt_term_taxonomy` VALUES (63, 63, 0, 1, 'tag', 0);
INSERT INTO `pt_term_taxonomy` VALUES (64, 64, 0, 1, 'tag', 0);
INSERT INTO `pt_term_taxonomy` VALUES (65, 65, 0, 1, 'tag', 0);
INSERT INTO `pt_term_taxonomy` VALUES (66, 66, 0, 1, 'tag', 0);
INSERT INTO `pt_term_taxonomy` VALUES (67, 67, 6, 2, 'category', 0);
INSERT INTO `pt_term_taxonomy` VALUES (68, 68, 0, 1, 'tag', 0);
INSERT INTO `pt_term_taxonomy` VALUES (69, 69, 0, 1, 'tag', 0);
INSERT INTO `pt_term_taxonomy` VALUES (70, 70, 0, 1, 'tag', 0);
INSERT INTO `pt_term_taxonomy` VALUES (71, 71, 0, 1, 'tag', 0);
INSERT INTO `pt_term_taxonomy` VALUES (72, 72, 0, 1, 'tag', 0);
INSERT INTO `pt_term_taxonomy` VALUES (73, 73, 0, 1, 'tag', 0);
INSERT INTO `pt_term_taxonomy` VALUES (74, 74, 0, 1, 'tag', 0);
INSERT INTO `pt_term_taxonomy` VALUES (75, 75, 0, 1, 'category', 0);
INSERT INTO `pt_term_taxonomy` VALUES (76, 76, 75, 2, 'category', 0);
INSERT INTO `pt_term_taxonomy` VALUES (78, 78, 0, 1, 'tag', 0);

-- ----------------------------
-- Table structure for pt_user
-- ----------------------------
DROP TABLE IF EXISTS `pt_user`;
CREATE TABLE `pt_user`  (
  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT 'id',
  `account` varchar(60) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT '' COMMENT '登录帐号',
  `password` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT '' COMMENT '登录密码',
  `nickname` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT '' COMMENT '昵称',
  `email` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT '' COMMENT '邮箱',
  `avatar` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT '' COMMENT '头像',
  `page_url` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT '' COMMENT '主页链接',
  `status` int(11) NOT NULL DEFAULT 0 COMMENT '状态.1激活2冻结',
  `role` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT 'subscriber' COMMENT '用户角色',
  `created_time` datetime(0) NOT NULL COMMENT '注册时间(UTC)',
  `updated_time` datetime(0) NOT NULL COMMENT '更新时间(UTC)',
  `deleted_time` datetime(0) NULL DEFAULT NULL COMMENT '删除时间(UTC)',
  PRIMARY KEY (`id`) USING BTREE,
  UNIQUE INDEX `user_login`(`account`) USING BTREE,
  UNIQUE INDEX `user_email_2`(`email`) USING BTREE,
  INDEX `user_login_key`(`account`) USING BTREE,
  INDEX `user_nicename`(`nickname`) USING BTREE,
  INDEX `user_email`(`email`) USING BTREE,
  INDEX `user_delete`(`deleted_time`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 11 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of pt_user
-- ----------------------------
INSERT INTO `pt_user` VALUES (10, 'gzp', '$2a$10$ikWgi6sCzRyVqT1JEx81ZezWX9NqXB71.FcyBXpZFJpu2yesVe9M2', 'gzp', 'example@example.com', '/upload/users/default.jpg', '', 1, 'administrator', '2018-07-24 02:51:38', '2019-01-26 21:14:51', NULL);
INSERT INTO `pt_user` VALUES (11, 'gzp2', '$2a$10$GeYscqOe2aCxGzosZpAEpu0hVwiW9xnOh.JeouLerRKTVlUkZ4FEq', 'gzp2', 'gzp2@123.com', '', '', 1, 'administrator', '2019-01-27 06:56:42', '2019-01-27 06:58:03', '2019-01-27 06:58:47');

-- ----------------------------
-- Table structure for pt_user_meta
-- ----------------------------
DROP TABLE IF EXISTS `pt_user_meta`;
CREATE TABLE `pt_user_meta`  (
  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT 'id',
  `user_id` int(11) UNSIGNED NOT NULL DEFAULT 0 COMMENT '用户id',
  `meta_key` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT '' COMMENT '设置的key',
  `meta_value` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '设置的value',
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `user_id`(`user_id`) USING BTREE,
  INDEX `meta_key`(`meta_key`(191)) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 4 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of pt_user_meta
-- ----------------------------
INSERT INTO `pt_user_meta` VALUES (1, 1, 'description', '超级管理员');
INSERT INTO `pt_user_meta` VALUES (2, 1, 'session_tokens', '');
INSERT INTO `pt_user_meta` VALUES (3, 2, 'description', '');
INSERT INTO `pt_user_meta` VALUES (4, 2, 'session_tokens', '');

SET FOREIGN_KEY_CHECKS = 1;
